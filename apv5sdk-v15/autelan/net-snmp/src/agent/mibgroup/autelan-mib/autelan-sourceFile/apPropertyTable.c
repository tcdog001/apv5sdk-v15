/**********************************************************************************
* Copyright (c) 2008-2011  Beijing Autelan Technology Co. Ltd.
* All rights reserved.
*
* filename: apPropertyTable.c
* description:  implementation for the common property of AP
* 
*
* 
************************************************************************************/

/*
 * Note: this file originally auto-generated by mib2c using
 *        : mib2c.old-api.conf 14476 2006-04-18 17:36:51Z hardaker $
 */

#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>
#include "apPropertyTable.h"
#include <ap_interface.h>
#define TABLE_SIZE   1
#define IFNAME_MAX 1000
#define IFNAME_LEN 20
#ifndef UCHAR
  typedef unsigned char UCHAR;
#endif


static int    apGetMinutesFromString(char *timeString);


//int fun=0;
char  vap1[20]="ath0";
char  vap2[20]="ath1";
char sys_cmd[256];

/* 
 * apPropertyTable_variables_oid:
 *   this is the top level oid that we want to register under.  This
 *   is essentially a prefix, with the suffix appearing in the
 *   variable below.
 */

//oid apPropertyTable_variables_oid[] = { 1,3,6,1,4,1,31656,2,3,2,1,8 };
oid *apPropertyTable_variables_oid;

/* 
 * variable4 apPropertyTable_variables:
 *   this variable defines function callbacks and type return information 
 *   for the apPropertyTable mib section 
 */

struct variable4 apPropertyTable_variables[] = {
/*  magic number        , variable type , ro/rw , callback fn  , L, oidsuffix */

#define APDOMAINNAME		1
{APDOMAINNAME,  ASN_OCTET_STR,  RONLY,   var_apPropertyTable, 2,  {  1, 1 }},
#define APASSOCIUSRCOUNT		2
{APASSOCIUSRCOUNT,  ASN_INTEGER,  RONLY,   var_apPropertyTable, 2,  {1, 2 }},
#define APUSRTOTALTIME		3
{APUSRTOTALTIME,  ASN_INTEGER,  RONLY,   var_apPropertyTable, 2,  { 1, 3 }},
#define APNOISELEVEL		4
{APNOISELEVEL,  ASN_OCTET_STR,  RONLY,   var_apPropertyTable, 2,  { 1, 4 }},
#define APQOSWMMFUNCTION		5
{APQOSWMMFUNCTION,  ASN_INTEGER,  RWRITE,  var_apPropertyTable, 2,  { 1, 5 }},
#define APWIRELESSQOSCONFIG		6
{APWIRELESSQOSCONFIG,  ASN_OCTET_STR,  RWRITE,  var_apPropertyTable, 2,  { 1, 6 }},
#define APWEPVAP1ASCIIKEY1		7
{APWEPVAP1ASCIIKEY1,  ASN_OCTET_STR,  RWRITE,  var_apPropertyTable, 2,  { 1, 7 }},
#define APWEPVAP1ASCIIKEY2		8
{APWEPVAP1ASCIIKEY2,  ASN_OCTET_STR,  RWRITE,  var_apPropertyTable, 2,  { 1, 8 }},
#define APWEPVAP1ASCIIKEY3		9
{APWEPVAP1ASCIIKEY3,  ASN_OCTET_STR,  RWRITE,  var_apPropertyTable, 2,  { 1, 9 }},
#define APWEPVAP1ASCIIKEY4		10
{APWEPVAP1ASCIIKEY4,  ASN_OCTET_STR,  RWRITE,  var_apPropertyTable, 2,  {1, 10 }},
#define APWEPVAP2ASCIIKEY1		11
{APWEPVAP2ASCIIKEY1,  ASN_OCTET_STR,  RWRITE,  var_apPropertyTable, 2,  {1, 11 }},
#define APWEPVAP2ASCIIKEY2		12
{APWEPVAP2ASCIIKEY2,  ASN_OCTET_STR,  RWRITE,  var_apPropertyTable, 2,  { 1, 12 }},
#define APWEPVAP2ASCIIKEY3		13
{APWEPVAP2ASCIIKEY3,  ASN_OCTET_STR,  RWRITE,  var_apPropertyTable, 2,  { 1, 13 }},
#define APWEPVAP2ASCIIKEY4		14
{APWEPVAP2ASCIIKEY4,  ASN_OCTET_STR,  RWRITE,  var_apPropertyTable, 2,  { 1, 14 }},
#define APWEPVAP1HEXKEY1		15
{APWEPVAP1HEXKEY1,  ASN_OCTET_STR,  RWRITE,  var_apPropertyTable, 2,  {1, 15 }},
#define APWEPVAP1HEXKEY2		16
{APWEPVAP1HEXKEY2,  ASN_OCTET_STR,  RWRITE,  var_apPropertyTable, 2,  { 1, 16 }},
#define APWEPVAP1HEXKEY3		17
{APWEPVAP1HEXKEY3,  ASN_OCTET_STR,  RWRITE,  var_apPropertyTable, 2,  { 1, 17 }},
#define APWEPVAP1HEXKEY4		18
{APWEPVAP1HEXKEY4,  ASN_OCTET_STR,  RWRITE,   var_apPropertyTable, 2,  { 1, 18 }},
#define APWEPVAP2HEXKEY1		19
{APWEPVAP2HEXKEY1,  ASN_OCTET_STR,  RWRITE,  var_apPropertyTable, 2,  {1, 19 }},
#define APWEPVAP2HEXKEY2		20
{APWEPVAP2HEXKEY2,  ASN_OCTET_STR,  RWRITE,  var_apPropertyTable, 2,  { 1, 20 }},
#define APWEPVAP2HEXKEY3		21
{APWEPVAP2HEXKEY3,  ASN_OCTET_STR,  RWRITE,  var_apPropertyTable, 2,  { 1, 21 }},
#define APWEPVAP2HEXKEY4		22
{APWEPVAP2HEXKEY4,  ASN_OCTET_STR,  RWRITE,  var_apPropertyTable, 2,  {1, 22 }},
};
/*    (L = length of the oidsuffix) */


/** Initializes the apPropertyTable module */
void
init_apPropertyTable(void)
{
  	FILE *fp;
  	char oid_str[64]={0};
  	char oid_tmp[64]={0};
  	int  oid_len=0;
  	int  count = 0;
  	char *p = NULL;
  	char *ptr=NULL;
	
    fp=fopen( "/jffs/.OEM/.vendor_oid","r");
    if(fp)
    {
		memset(oid_str,0,64);
    	fgets(oid_str,sizeof(oid_str),fp);
	    oid_str[strlen(oid_str)-1] = '\0';
		fclose(fp);
    }
    else
     {
		memset(oid_str,0,64);
     	strcpy(oid_str, "1.3.6.1.4.1.31656"); 
	 }
	

	memset(oid_tmp,0,64);
	strcpy(oid_tmp,oid_str);
		 
    ptr = strtok(oid_tmp, "."); 
	while(NULL != ptr)
	{
		oid_len++;
		ptr = strtok(NULL,".");
	 }
	
    oid_len = oid_len + 5;	
	apPropertyTable_variables_oid = (oid *)malloc(sizeof(oid)*(oid_len));


    p = strtok(oid_str, ".");
    while( NULL != p)
    {
      apPropertyTable_variables_oid[count++] = (oid)atoi(p);
      p = strtok(NULL,".");
    }


    apPropertyTable_variables_oid[count ++] = 2;
    apPropertyTable_variables_oid[count ++] = 3;
    apPropertyTable_variables_oid[count ++] = 2;
    apPropertyTable_variables_oid[count ++] = 1;
    apPropertyTable_variables_oid[count ++] = 8;

    DEBUGMSGTL(("apPropertyTable", "Initializing\n"));

    /* register ourselves with the agent to handle our mib tree */
    REGISTER_MIB_NEW("apPropertyTable", apPropertyTable_variables, variable4,
               apPropertyTable_variables_oid,count); 

    /* place any other initialization junk you need here */
}


/*
 * var_apPropertyTable():
 *   Handle this table separately from the scalar value case.
 *   The workings of this are basically the same as for var_apPropertyTable above.
 */
unsigned char *
var_apPropertyTable(struct variable *vp,
    	    oid     *name,
    	    size_t  *length,
    	    int     exact,
    	    size_t  *var_len,
    	    WriteMethod **write_method)
{
    /* variables we may use later */
    static long long_ret;
    static u_long ulong_ret;
    static unsigned char string[256];
    static oid objid[128];
    static struct counter64 c64;
	   FILE  *fp1,*fp2;
	 char cmd_n[200];
	 char cmd_u[200];
	 char time[200];
          int  if1_min=0;
	   int  if2_min=0;  
	   int  buf1_min=0;
	   int  buf2_min=0;
	   int   total_min=0;
	   int  num_row = 0;
	   int i=0,j=0,temp_ret=0;
	   int tableSize=0;
	   static char ifname[IFNAME_MAX],tempIfname[IFNAME_MAX];
	   char *ip,*tq,*iq;
	//   struct wlan_info_t wlaninfo;
            char bfr[128];

//heyanhua add 2010-4-27 ---start
	printf("1111111111111\n\n");
	if(iw_get_wifis()==0)  return 0;

	bzero(ifname,IFNAME_MAX);
	bzero(tempIfname,IFNAME_MAX);
//	memset(&wlaninfo,0,sizeof(wlaninfo));

	temp_ret=iw_enum_wlan_interface(tempIfname);
	printf("temp_ret=%d\n",temp_ret);

	if(temp_ret!=0){
		tq=tempIfname;
		iq=ifname;
		for(j=0,tableSize=0;j<temp_ret;tq=tq+IFNAME_LEN,j++){
			if(strstr(tq,"awlan")==NULL){
				strcpy(iq,tq);
				tableSize++;
				printf("iq=%s \t tableSize=%d\n",iq,tableSize);
				iq=iq+IFNAME_LEN;
				}
			}
		ip=ifname;
		}
	else{
		tableSize=1;
		ip=NULL;
		}
	//heyanhua add 2010-4-27 ---end
			
    /* 
   * This assumes that the table is a 'simple' table.
   *	See the implementation documentation for the meaning of this.
   *	You will need to provide the correct value for the TABLE_SIZE parameter
   *
   * If this table does not meet the requirements for a simple table,
   *	you will need to provide the replacement code yourself.
   *	Mib2c is not smart enough to write this for you.
   *    Again, see the implementation documentation for what is required.
   */
    if (header_simple_table(vp,name,length,exact,var_len,write_method, tableSize)
                                                == MATCH_FAILED )
    return NULL;

	if(name[*length - 1] > tableSize)
	{
		DEBUGMSGTL(("apPropertyTable","apPropertyTable -- no match:%lu\n",i));
		return NULL;
	}

	for(i=1;i<name[*length - 1];i++)
	{
		DEBUGMSGTL(("apPropertyTable","apPropertyTable -- %lu != %lu\n",i,name[*length - 1]));
	if(temp_ret!=0){
		ip=ip+IFNAME_LEN;
		}	
	}

    /* 
   * this is where we do the value assignments for the mib results.
   */
    switch(vp->magic) {
    case APDOMAINNAME:
	strcpy(nPk.apDomainName,"China Region");
       *var_len = strlen ( pk->apDomainName  );
	return ( UCHAR * ) pk->apDomainName ;

	//heyanhua modify 2010-4-20 ---start
    case APASSOCIUSRCOUNT:

{ FILE *fp;
  char *q;
  int i,count=0;
  char bfr[256],cmd[256];
/*  fp=fopen("/proc/net/dev","r");
  if(fp!=NULL)
	{
		char line[2048];
		memset(line, 0, 2048);
		while(fgets(line, sizeof(line), fp))
		{		
			q = strstr(line, "ath");
			if(q != NULL)
			count++;
		}
		fclose(fp);
	}
  nPk.apAssociUsrCount=0;
  for(i=0; i<count;i++)
  	{
  	*/
  		memset(cmd,0,256);
  		sprintf(cmd,"%s%s%s","cat /proc/sys/net/",ip,"/users_join_counter");
		printf("heyanhua test! cmd:%s\n",cmd);
  fp=popen(cmd,"r");
  if(fp)
   {
  	 memset(bfr, 0, 256 );
  	 fgets(bfr,sizeof(bfr),fp);
	 printf("bfr:%s",bfr);
	 bfr[strlen(bfr)-1] = '\0';
	  nPk.apAssociUsrCount=atoi(bfr);
	 pclose(fp);

   }
  //	}
  	 return ( UCHAR * )& pk->apAssociUsrCount ;
} 
//heyanhua modify 2010-4-20 ----end

    case APUSRTOTALTIME:

 /*    memset(cmd_n,0, 200);
	 memset(cmd_u,0, 200);
     sprintf(cmd_n, "%s %s %s", "/usr/sbin/wlanconfig",ip,"list |wc -l");
     fp1=popen(cmd_n,"r");
	 if(fp1)
	   {
	   pk->apUsrTotalTime=0;
	   memset( bfr, 0, 128 );
	   fgets(bfr,sizeof(bfr),fp1);
	   bfr[strlen(bfr)-1] = '\0';
	   num_row=atoi(bfr);
	   if(num_row>=2)
	   	{
	               for(i=2;i<= num_row;i++)
		           {
					sprintf(cmd_u,"%s %s %s %d %s","/usr/sbin/wlanconfig",ip,"list|awk 'NR==",i,"{print $13}'");
					fp2=popen(cmd_u,"r");
					if(fp2)
					  {
						 memset( time, 0, 200 );
						 fgets(time,sizeof(time),fp2);
						 time[strlen(time)-1] = '\0';
						 pclose(fp2);
						 if1_min=apGetMinutesFromString(time) ;
						 pk->apUsrTotalTime=if1_min;
						 printf("buf1_min:%d\n",pk->apUsrTotalTime);
				      }

			       }
	      }
	   pclose(fp1);
	}
*/
    memset(cmd_n,0, 200);
	memset(cmd_u,0, 200);
    sprintf(cmd_n, "%s", "/usr/sbin/wlanconfig ath1 list |wc -l");
    fp1=popen(cmd_n,"r");
	if(fp1)
	{
	   memset( bfr, 0, 128 ); 
	   fgets(bfr,sizeof(bfr),fp1);
	   bfr[strlen(bfr)-1] = '\0';
	   num_row=atoi(bfr);
	   if(num_row>=2)
	   	{
	       for(i=2;i<= num_row;i++)
           {
			  sprintf(cmd_u,"%s %d %s","/usr/sbin/wlanconfig  ath1  list|awk 'NR==",i,"{print $13}'");
              fp2=popen(cmd_u,"r");
			  if(fp2)
			  {
					memset( time, 0, 200 );
					fgets(time,sizeof(time),fp2);
					time[strlen(time)-1] = '\0';
					pclose(fp2);
					if2_min=apGetMinutesFromString(time) ;
					buf2_min+=if2_min;
					printf("buf1_min:%d\n",buf1_min);
			  }
		   }
	    }
	   pclose(fp1);
   }

long_ret=buf1_min+buf2_min;
printf("long_ret:%d\n",long_ret);

return ( UCHAR * )&long_ret ;





		
    case APNOISELEVEL:
     strcpy(nPk.apNoiseLevel,"-96");
       *var_len = strlen ( pk->apNoiseLevel  );
	return ( UCHAR * ) pk->apNoiseLevel ;

//heyanhua modify 2010-4-27	
    case APQOSWMMFUNCTION:
     *write_method = write_apQoswmmFunction;
 //      nPk.apQoswmmFunction=fun;
 	{
 		FILE *fp;
		char line[128],cmd[128];
		sprintf(cmd,"%s %s %s","/usr/sbin/iwpriv",ip,"get_wmm |awk -F : '{print $2}'");
		fp=popen(cmd,"r");
		if(fp)
			{
				pk->apQoswmmFunction=0;
				memset(line, 0, 128);
				fgets(line, sizeof(line), fp);
			//	line[strlen(line)-1] = '\0';
				printf("heyh test for line:%s\n",line);
			//	sprintf(pk->apQoswmmFunction,"Autelan private wmm config : get tos flag :: %ld",line);
			 	sscanf(line, "%ld",&pk->apQoswmmFunction);
				printf("hyh test:pk->apQoswmmfunction:%ld\n",pk->apQoswmmFunction);
				pclose(fp);
			}

 	}
	return ( UCHAR * ) &pk->apQoswmmFunction ;
	
    case APWIRELESSQOSCONFIG:
	 *write_method = write_apWirelessQosConfig;
       strcpy(nPk.apWirelessQosConfig,"CAR");

       *var_len = strlen ( pk->apWirelessQosConfig  );
	return ( UCHAR * ) pk->apWirelessQosConfig ;
	
    case APWEPVAP1ASCIIKEY1:
        *write_method = write_apWEPVap1asciiKey1;
           strcpy(nPk.apWEPVap1asciiKey1,"set ascii vap1 key1");
       *var_len = strlen ( pk->apWEPVap1asciiKey1  );
	return ( UCHAR * ) pk->apWEPVap1asciiKey1 ;

	
    case APWEPVAP1ASCIIKEY2:
		  *write_method = write_apWEPVap1asciiKey2;
           strcpy(nPk.apWEPVap1asciiKey2,"set ascii vap1 key2");
       *var_len = strlen ( pk->apWEPVap1asciiKey2  );
	return ( UCHAR * ) pk->apWEPVap1asciiKey2 ;

	
    case APWEPVAP1ASCIIKEY3:
	 *write_method = write_apWEPVap1asciiKey3;
	strcpy(nPk.apWEPVap1asciiKey3,"set ascii vap1 key3");
       *var_len = strlen ( pk->apWEPVap1asciiKey3  );
	return ( UCHAR * ) pk->apWEPVap1asciiKey3 ;

	
    case APWEPVAP1ASCIIKEY4:
  *write_method = write_apWEPVap1asciiKey4;
	strcpy(nPk.apWEPVap1asciiKey4,"set ascii vap1 key4");
       *var_len = strlen ( pk->apWEPVap1asciiKey4  );
	return ( UCHAR * ) pk->apWEPVap1asciiKey4 ;

	
    case APWEPVAP2ASCIIKEY1:
		        *write_method = write_apWEPVap2asciiKey1;
	strcpy(nPk.apWEPVap2asciiKey1,"set ascii vap2 key1");
       *var_len = strlen ( pk->apWEPVap2asciiKey1  );
	return ( UCHAR * ) pk->apWEPVap2asciiKey1 ;

	
    case APWEPVAP2ASCIIKEY2:
		        *write_method = write_apWEPVap2asciiKey2;

	strcpy(nPk.apWEPVap2asciiKey2,"set ascii vap2 key2");
       *var_len = strlen ( pk->apWEPVap2asciiKey2  );
	return ( UCHAR * ) pk->apWEPVap2asciiKey2 ;

    case APWEPVAP2ASCIIKEY3:
		        *write_method = write_apWEPVap2asciiKey3;

	strcpy(nPk.apWEPVap2asciiKey3,"set ascii vap2 key3");
       *var_len = strlen ( pk->apWEPVap2asciiKey3  );
	return ( UCHAR * ) pk->apWEPVap2asciiKey3 ;
	
    case APWEPVAP2ASCIIKEY4:
		 *write_method = write_apWEPVap2asciiKey4;
	     strcpy(nPk.apWEPVap2asciiKey4,"set ascii vap2 key4");
         *var_len = strlen ( pk->apWEPVap2asciiKey4  );
	     return ( UCHAR * ) pk->apWEPVap2asciiKey4 ;
	
    case APWEPVAP1HEXKEY1:
	    *write_method = write_apWEPVap1hexKey1;
	    strcpy(nPk.apWEPVap1hexKey1,"set hex vap1 key1");
        *var_len = strlen ( pk->apWEPVap1hexKey1  );
	    return ( UCHAR * ) pk->apWEPVap1hexKey1 ;
	
    case APWEPVAP1HEXKEY2:
		*write_method = write_apWEPVap1hexKey2;
	    strcpy(nPk.apWEPVap1hexKey2,"set hex vap1 key2");
        *var_len = strlen ( pk->apWEPVap1hexKey2  );
	    return ( UCHAR * ) pk->apWEPVap1hexKey2 ;
	
    case APWEPVAP1HEXKEY3:
		*write_method = write_apWEPVap1hexKey3;
	    strcpy(nPk.apWEPVap1hexKey3,"set hex vap1 key3");
        *var_len = strlen ( pk->apWEPVap1hexKey3  );
	    return ( UCHAR * ) pk->apWEPVap1hexKey3 ;
	
    case APWEPVAP1HEXKEY4:
        *write_method = write_apWEPVap1hexKey4;
	    strcpy(nPk.apWEPVap1hexKey4,"set hex vap1 key4");
        *var_len = strlen ( pk->apWEPVap1hexKey4  );
	    return ( UCHAR * ) pk->apWEPVap1hexKey4 ;
	
    case APWEPVAP2HEXKEY1:
	    *write_method = write_apWEPVap2hexKey1;
	    strcpy(nPk.apWEPVap2hexKey1,"set hex vap2 key1");
        *var_len = strlen ( pk->apWEPVap2hexKey1  );
	    return ( UCHAR * ) pk->apWEPVap2hexKey1 ;
	
    case APWEPVAP2HEXKEY2:
        *write_method = write_apWEPVap2hexKey2;
	    strcpy(nPk.apWEPVap2hexKey2,"set hex vap2 key2");
        *var_len = strlen ( pk->apWEPVap2hexKey2  );
	    return ( UCHAR * ) pk->apWEPVap2hexKey2 ;
	
    case APWEPVAP2HEXKEY3:
	    *write_method = write_apWEPVap2hexKey3;
	    strcpy(nPk.apWEPVap2hexKey3,"set hex vap2 key3");
        *var_len = strlen ( pk->apWEPVap2hexKey3  );
	    return ( UCHAR * ) pk->apWEPVap2hexKey3 ;
	
    case APWEPVAP2HEXKEY4:
		*write_method = write_apWEPVap2hexKey4;
	    strcpy(nPk.apWEPVap2hexKey4,"set hex vap2 key4");
        *var_len = strlen ( pk->apWEPVap2hexKey4  );
	    return ( UCHAR * ) pk->apWEPVap2hexKey4 ;
    default:
      ERROR_MSG("");
    }
    return NULL;
}



int
write_apQoswmmFunction(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
   long n;
   long value;
	char cmd[256];
	char temp_str[128];
	char temp_cmd[256];

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to apPropertyTable not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to apPropertyTable: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
         // size  = var_val_len;
          //value = * (long *) var_val;

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
             // heyanhua modify for SET QoswmmFunction  ---2010-4-28
			{ 
			FILE *fp;
			 memset(cmd, 0, 256);
			 memset(temp_str,0,128);
			 memset(temp_cmd,0,256);
			 printf("heyanhua test ---1---\n");
			  n=name[name_len-1];
			  printf("n:%ld\n",n);
			  sprintf(temp_cmd,"%s %d %s","cat /proc/net/wireless |awk -F : 'NR==",n+2," {print $1}'");
			  printf("heyanhua test ---2---\n");
			  printf("temp_cmd:%s\n",temp_cmd);
			  fp=popen(temp_cmd,"r");
			  if(fp){
			  	fgets(temp_str,sizeof(temp_str),fp);
				temp_str[strlen(temp_str)-1]='\0';
				pclose(fp);
			  	}
			// printf("oid *name:%d\n\n",name);
			 value=*(long *)var_val;
			 printf("value:%ld\n",value);
			 sprintf(cmd,"%s %s %s %ld", "/usr/sbin/iwpriv",temp_str,"wmm",value);
			 printf("cmd :%s\n",cmd);
			 system(cmd);
             }
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_apWirelessQosConfig(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    char value;
    int size;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to apPropertyTable not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(value)) {
              fprintf(stderr,"write to apPropertyTable: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          size  = var_val_len;
          value = * (char *) var_val;

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_apWEPVap1asciiKey1(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
     char string[256];
    char value[256];
    int size;
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to apPropertyTable not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(value)) {
              fprintf(stderr,"write to apPropertyTable: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          //size  = var_val_len;
          //value = * (long *) var_val;

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
		memcpy(string,var_val,var_val_len);
		string[var_val_len]='\0';
		printf("string:%s\n\n",string);
		printf("vap1:%s\n\n",vap1);
	//wireless_sec_set_type(get_vnum_by_vname(vap1),"wep");
    //         wireless_sec_set_wepkey( get_vnum_by_vname(vap1), 
    //                         "1","ascii",string,1);
	 sprintf(sys_cmd,"iwconfig    ath0    key    off");
	 system(sys_cmd);
        sprintf(sys_cmd,"ifconfig ath0 down");
        system(sys_cmd);
        sprintf(sys_cmd,"/usr/sbin/iwconfig ath0 key [1] s:%s open",string);
        system(sys_cmd);
        sprintf(sys_cmd,"/usr/sbin/iwpriv ath0 authmode 2");
        system(sys_cmd);
        sprintf(sys_cmd,"ifconfig ath0 up");
        system(sys_cmd);
		
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_apWEPVap1asciiKey2(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
  char string[256];
      char value[256];

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to apPropertyTable not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(value)) {
              fprintf(stderr,"write to apPropertyTable: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
        //  size  = var_val_len;
       //   value = * (long *) var_val;

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
            		memcpy(string,var_val,var_val_len);
		string[var_val_len]='\0';
        
	 sprintf(sys_cmd,"iwconfig    ath0    key    off");
	 system(sys_cmd);
	 sprintf(sys_cmd,"ifconfig ath0 down");
        system(sys_cmd);
        sprintf(sys_cmd,"/usr/sbin/iwconfig ath0 key [2] s:%s open",string);
        system(sys_cmd);
        sprintf(sys_cmd,"/usr/sbin/iwpriv ath0 authmode 2");
        system(sys_cmd);
        sprintf(sys_cmd,"ifconfig ath0 up");
        system(sys_cmd);


          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_apWEPVap1asciiKey3(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
  char string[256];
    char value[256];

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to apPropertyTable not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(value)) {
              fprintf(stderr,"write to apPropertyTable: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
       memcpy(string,var_val,var_val_len);
	string[var_val_len]='\0';
	 sprintf(sys_cmd,"iwconfig    ath0    key    off");
	 system(sys_cmd);
	sprintf(sys_cmd,"ifconfig ath0 down");
        system(sys_cmd);
        sprintf(sys_cmd,"/usr/sbin/iwconfig ath0 key [3] s:%s open",string);
        system(sys_cmd);
        sprintf(sys_cmd,"/usr/sbin/iwpriv ath0 authmode 2");
        system(sys_cmd);
        sprintf(sys_cmd,"ifconfig ath0 up");
        system(sys_cmd);

          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_apWEPVap1asciiKey4(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
char string[256];
    char value[256];

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to apPropertyTable not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(value)) {
              fprintf(stderr,"write to apPropertyTable: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
        memcpy(string,var_val,var_val_len);
	string[var_val_len]='\0';
	sprintf(sys_cmd,"iwconfig    ath0    key    off");
	 system(sys_cmd);
	sprintf(sys_cmd,"ifconfig ath0 down");
        system(sys_cmd);
        sprintf(sys_cmd,"/usr/sbin/iwconfig ath0 key [4] s:%s open",string);
        system(sys_cmd);
        sprintf(sys_cmd,"/usr/sbin/iwpriv ath0 authmode 2");
        system(sys_cmd);
        sprintf(sys_cmd,"ifconfig ath0 up");
        system(sys_cmd);


          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_apWEPVap2asciiKey1(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
char string[256];
    char value[256];

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to apPropertyTable not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(value)) {
              fprintf(stderr,"write to apPropertyTable: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
        
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
        memcpy(string,var_val,var_val_len);
	string[var_val_len]='\0';
	sprintf(sys_cmd,"iwconfig    ath1    key    off");
	 system(sys_cmd);
	sprintf(sys_cmd,"ifconfig ath1 down");
        system(sys_cmd);
        sprintf(sys_cmd,"/usr/sbin/iwconfig ath1 key [1] s:%s open",string);
        system(sys_cmd);
        sprintf(sys_cmd,"/usr/sbin/iwpriv ath1 authmode 2");
        system(sys_cmd);
        sprintf(sys_cmd,"ifconfig ath1 up");
        system(sys_cmd);


          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_apWEPVap2asciiKey2(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
   char string[256];
    char value[256];

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to apPropertyTable not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(value)) {
              fprintf(stderr,"write to apPropertyTable: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
      
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
         memcpy(string,var_val,var_val_len);
	string[var_val_len]='\0';
	 sprintf(sys_cmd,"iwconfig    ath1    key    off");
	 system(sys_cmd);
	 sprintf(sys_cmd,"ifconfig ath1 down");
        system(sys_cmd);
        sprintf(sys_cmd,"/usr/sbin/iwconfig ath1 key [2] s:%s open",string);
        system(sys_cmd);
        sprintf(sys_cmd,"/usr/sbin/iwpriv ath1 authmode 2");
        system(sys_cmd);
        sprintf(sys_cmd,"ifconfig ath1 up");
        system(sys_cmd);


          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_apWEPVap2asciiKey3(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
  char string[256];
       char value[256];

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to apPropertyTable not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(value)) {
              fprintf(stderr,"write to apPropertyTable: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
    

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
        memcpy(string,var_val,var_val_len);
	string[var_val_len]='\0';
	 sprintf(sys_cmd,"iwconfig    ath1    key    off");
	 system(sys_cmd);
	sprintf(sys_cmd,"ifconfig ath1 down");
        system(sys_cmd);
        sprintf(sys_cmd,"/usr/sbin/iwconfig ath1 key [3] s:%s open",string);
        system(sys_cmd);
        sprintf(sys_cmd,"/usr/sbin/iwpriv ath1 authmode 2");
        system(sys_cmd);
        sprintf(sys_cmd,"ifconfig ath1 up");
        system(sys_cmd);


          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_apWEPVap2asciiKey4(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
   char string[256];
      char value[256];

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to apPropertyTable not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(value)) {
              fprintf(stderr,"write to apPropertyTable: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
        

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
              memcpy(string,var_val,var_val_len);
		string[var_val_len]='\0';
		sprintf(sys_cmd,"iwconfig    ath1    key    off");
		 system(sys_cmd);
		sprintf(sys_cmd,"ifconfig ath1 down");
	        system(sys_cmd);
	        sprintf(sys_cmd,"/usr/sbin/iwconfig ath1 key [4] s:%s open",string);
	        system(sys_cmd);
	        sprintf(sys_cmd,"/usr/sbin/iwpriv ath1 authmode 2");
	        system(sys_cmd);
	        sprintf(sys_cmd,"ifconfig ath1 up");
	        system(sys_cmd);

          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_apWEPVap1hexKey1(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    char string[256];
    char value[256];
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to apPropertyTable not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(value)) {
              fprintf(stderr,"write to apPropertyTable: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
      

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
               memcpy(string,var_val,var_val_len);
		string[var_val_len]='\0';
		 sprintf(sys_cmd,"iwconfig    ath0    key    off");
	 	system(sys_cmd);
		sprintf(sys_cmd,"ifconfig ath0 down");
	        system(sys_cmd);
	        sprintf(sys_cmd,"/usr/sbin/iwconfig ath0 key [1] %s open",string);
	        system(sys_cmd);
	        sprintf(sys_cmd,"/usr/sbin/iwpriv ath0 authmode 2");
	        system(sys_cmd);
	        sprintf(sys_cmd,"ifconfig ath0 up");
	        system(sys_cmd);

	      //printf("");

          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_apWEPVap1hexKey2(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    char string[256];
     char value[256];

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to apPropertyTable not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(value)) {
              fprintf(stderr,"write to apPropertyTable: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
     
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
                memcpy(string,var_val,var_val_len);
		string[var_val_len]='\0';
		 sprintf(sys_cmd,"iwconfig    ath0    key    off");
	 	system(sys_cmd);
		sprintf(sys_cmd,"ifconfig ath0 down");
        system(sys_cmd);
        sprintf(sys_cmd,"/usr/sbin/iwconfig ath0 key [2] %s open",string);
        system(sys_cmd);
        sprintf(sys_cmd,"/usr/sbin/iwpriv ath0 authmode 2");
        system(sys_cmd);
        sprintf(sys_cmd,"ifconfig ath0 up");
        system(sys_cmd);

          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_apWEPVap1hexKey3(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
  char string[256];
      char value[256];

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to apPropertyTable not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(value)) {
              fprintf(stderr,"write to apPropertyTable: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
         

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
                 memcpy(string,var_val,var_val_len);
		string[var_val_len]='\0';
		 sprintf(sys_cmd,"iwconfig    ath0    key    off");
	 	system(sys_cmd);
		sprintf(sys_cmd,"ifconfig ath0 down");
        system(sys_cmd);
        sprintf(sys_cmd,"/usr/sbin/iwconfig ath0 key [3] %s open",string);
        system(sys_cmd);
        sprintf(sys_cmd,"/usr/sbin/iwpriv ath0 authmode 2");
        system(sys_cmd);
        sprintf(sys_cmd,"ifconfig ath0 up");
        system(sys_cmd);


          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}




int
write_apWEPVap1hexKey4(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
  char string[256];
    char value[256];

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to apPropertyTable not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(value)) {
              fprintf(stderr,"write to apPropertyTable: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
         

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
                    memcpy(string,var_val,var_val_len);
		string[var_val_len]='\0';
		 sprintf(sys_cmd,"iwconfig    ath0    key    off");
	 	system(sys_cmd);
		sprintf(sys_cmd,"ifconfig ath0 down");
        system(sys_cmd);
        sprintf(sys_cmd,"/usr/sbin/iwconfig ath0 key [4] %s open",string);
        system(sys_cmd);
        sprintf(sys_cmd,"/usr/sbin/iwpriv ath0 authmode 2");
        system(sys_cmd);
        sprintf(sys_cmd,"ifconfig ath0 up");
        system(sys_cmd);


          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_apWEPVap2hexKey1(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    char string[256];
    char value[256];

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to apPropertyTable not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(value)) {
              fprintf(stderr,"write to apPropertyTable: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
        
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
              memcpy(string,var_val,var_val_len);
		string[var_val_len]='\0';
		 sprintf(sys_cmd,"iwconfig    ath1    key    off");
	 	system(sys_cmd);
		sprintf(sys_cmd,"ifconfig ath1 down");
        system(sys_cmd);
        sprintf(sys_cmd,"/usr/sbin/iwconfig ath1 key [1] %s open",string);
        system(sys_cmd);
        sprintf(sys_cmd,"/usr/sbin/iwpriv ath1 authmode 2");
        system(sys_cmd);
        sprintf(sys_cmd,"ifconfig ath1 up");
        system(sys_cmd);

          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_apWEPVap2hexKey2(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
   char string[256];
    char value[256];

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to apPropertyTable not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(value)) {
              fprintf(stderr,"write to apPropertyTable: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
         //size  = var_val_len;
        //  value = * (long *) var_val;

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
               memcpy(string,var_val,var_val_len);
		string[var_val_len]='\0';
			 sprintf(sys_cmd,"iwconfig    ath1    key    off");
	 	system(sys_cmd);

		sprintf(sys_cmd,"ifconfig ath1 down");
        system(sys_cmd);
        sprintf(sys_cmd,"/usr/sbin/iwconfig ath1 key [2] %s open",string);
        system(sys_cmd);
        sprintf(sys_cmd,"/usr/sbin/iwpriv ath1 authmode 2");
        system(sys_cmd);
        sprintf(sys_cmd,"ifconfig ath1 up");
        system(sys_cmd);

            
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_apWEPVap2hexKey3(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
  char string[256];
    char value[256];
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to apPropertyTable not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(value)) {
              fprintf(stderr,"write to apPropertyTable: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
        //  size  = var_val_len;
        //  value = * (long *) var_val;

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
               memcpy(string,var_val,var_val_len);
		string[var_val_len]='\0';
		sprintf(sys_cmd,"iwconfig    ath1    key    off");
	 	system(sys_cmd);
		sprintf(sys_cmd,"ifconfig ath1 down");
	        system(sys_cmd);
	        sprintf(sys_cmd,"/usr/sbin/iwconfig ath1 key [3] %s open",string);
	        system(sys_cmd);
	        sprintf(sys_cmd,"/usr/sbin/iwpriv ath1 authmode 2");
	        system(sys_cmd);
	        sprintf(sys_cmd,"ifconfig ath1 up");
	        system(sys_cmd);


          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}



int
write_apWEPVap2hexKey4(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
   char string[256];
    char value[256];

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to apPropertyTable not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(value)) {
              fprintf(stderr,"write to apPropertyTable: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
         // size  = var_val_len;
        //  value = * (long *) var_val;

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
                memcpy(string,var_val,var_val_len);
		string[var_val_len]='\0';
		sprintf(sys_cmd,"iwconfig    ath1    key    off");
	 	system(sys_cmd);
		sprintf(sys_cmd,"ifconfig ath1 down");
	        system(sys_cmd);
	        sprintf(sys_cmd,"/usr/sbin/iwconfig ath1 key [4] %s open",string);
	        system(sys_cmd);
	        sprintf(sys_cmd,"/usr/sbin/iwpriv ath1 authmode 2");
	        system(sys_cmd);
	        sprintf(sys_cmd,"ifconfig ath1 up");
	        system(sys_cmd);


          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}





int    apGetMinutesFromString(char *timeString)
{
	//变量定义
	int  total = 0;
	char hour[3];
	char minute[3];
	char second[3];
        int i=0;
	 int j=0;
	 int k=0;
	 int  tem = 0; 
	//从字符串中取数

    for (i=0;i<2;i++)
    {
        hour[i] = timeString[i];
    }
	hour[2]='\0';

	
   tem = atoi(hour) * 60;
   total += tem;

    for ( j=0;j<2;j++)
    {
	minute[j] = timeString[3+j];
    }
	minute[2]='\0';

	tem = atoi(minute);
	total +=tem;

#if 0
	for(k = 0;k<2;k++)
	{
		second[k] = timeString[6+k];
	}
     	second[2]='\0';

	tem = atof(second)/60.0;

	total +=tem;
	#endif

	return total;

}

