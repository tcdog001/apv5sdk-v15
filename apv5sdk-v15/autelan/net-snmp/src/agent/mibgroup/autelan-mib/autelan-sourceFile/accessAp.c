/**********************************************************************************
* Copyright (c) 2008-2011  Beijing Autelan Technology Co. Ltd.
* All rights reserved.
*
* filename: accessAp.c
* description:  implementation for the access control and QoS of AP
* 
*
* 
************************************************************************************/

/*
 * Note: this file originally auto-generated by mib2c using
 *        : mib2c.old-api.conf 14476 2006-04-18 17:36:51Z hardaker $
 */

#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>
#include "accessAp.h"
#include <ap_interface.h>
#include "wapi/wapicgifunc.h"
#include "wapi/iwlib.h"

#define SNMP_QOS_CONF   "/etc/snmp/qos.conf"
//#define DISPLAYWIEXT                        // display wireless ext info
#define MINLOADFREQ  30        // min reload frequency in seconds
//#define MINLOADFREQ 5                       // min reload frequency in seconds      // for testing
#define PROC_NET_DEV      "/proc/net/dev"
#define PROC_NET_WIRELESS "/proc/net/wireless"

#define  ACCESS_BUF    128
#define  ACCESS_STR    256

/* 
 * accessAp_variables_oid:
 *   this is the top level oid that we want to register under.  This
 *   is essentially a prefix, with the suffix appearing in the
 *   variable below.
 */

static void load_Tables();
static void load_WiExt ( int, char *, struct wireless_info * );
static void load_80211Structs ( int, char *, struct wireless_info * );
static void init_Structs();

// Wireless Extensions Specific Functions
static void load_WiExtTo80211Structs ( int, char *, struct wireless_info * );

// Linked List Functions
static void add_List ( char *, char *, int );
static void init_Lists();                    // initialize all the linked lists
static void flush_Lists();                   // flush all the linked lists
static void flush_List ( char * );           // flush a single linked list

// Utility Functions
static int   open_Socket ( void );
static char *h_to_b ( char * );
static int  has_Changed ( char *, int );

static unsigned long lastLoad = 0;          // ET in secs at last table load

static struct avNode *lastNode, *newNode, *np;

//oid accessAp_variables_oid[] = { 1,3,6,1,4,1,31656,2,3,3 };
oid *accessAp_variables_oid;

/* 
 * variable4 accessAp_variables:
 *   this variable defines function callbacks and type return information 
 *   for the accessAp mib section 
 */

struct variable4 accessAp_variables[] = {
/*  magic number        , variable type , ro/rw , callback fn  , L, oidsuffix */

#define APLISTFILTERMACINDEX		1
{APLISTFILTERMACINDEX,  ASN_INTEGER,  RONLY,   var_apListFilterMacTable, 4,  { 1,1, 1, 1 }},
#define APLISTFILTERMACVALUE		2
{APLISTFILTERMACVALUE,  ASN_OCTET_STR,  RONLY,   var_apListFilterMacTable, 4,  { 1,1, 1, 2 }},
#define APUSEFILTERMACVALUE		3
{APUSEFILTERMACVALUE,  ASN_OCTET_STR,  RWRITE,  var_apFilterConfigTable, 4,  { 1,2, 1, 1 }},
#define APMODEFILTERMACVALUE		4
{APMODEFILTERMACVALUE,  ASN_OCTET_STR,  RWRITE,  var_apFilterConfigTable, 4,  { 1,2, 1, 2 }},
#define APADDFILTERMACVALUE		5
{APADDFILTERMACVALUE,  ASN_OCTET_STR,  RWRITE,  var_apFilterConfigTable, 4,  { 1,2, 1, 3 }},
#define APDELFILTERMACVALUE		6
{APDELFILTERMACVALUE,  ASN_OCTET_STR,  RWRITE,  var_apFilterConfigTable, 4,  { 1,2, 1, 4 }},
#define QOSTRAFFICCLASS		7
{QOSTRAFFICCLASS,  ASN_INTEGER,  RWRITE,  var_apWmmQosRadioTable, 4,  { 1,3, 1, 1 }},
#define QOSCHOOSEAPSTATION		8
{QOSCHOOSEAPSTATION,  ASN_INTEGER,  RWRITE,  var_apWmmQosRadioTable, 4,  { 1,3, 1, 2 }},
#define QOSAIFS		9
{QOSAIFS,  ASN_INTEGER,  RWRITE,  var_apWmmQosRadioTable, 4,  { 1,3, 1, 3 }},
#define QOSCWMIN		10
{QOSCWMIN,  ASN_INTEGER,  RWRITE,  var_apWmmQosRadioTable, 4,  { 1,3, 1, 4 }},
#define QOSCWMAX		11
{QOSCWMAX,  ASN_INTEGER,  RWRITE,  var_apWmmQosRadioTable, 4,  { 1,3, 1, 5 }},
#define QOSTXOPLIM		12
{QOSTXOPLIM,  ASN_INTEGER,  RWRITE,  var_apWmmQosRadioTable, 4,  { 1,3, 1, 6 }},
#define QOSENABLED		13
{QOSENABLED,  ASN_INTEGER,  RWRITE,  var_apQosBasicConfigTable, 4,  { 1,4, 1, 1 }},
#define QOSBW		14
{QOSBW,  ASN_INTEGER,  RWRITE,  var_apQosBasicConfigTable, 4,  { 1,4, 1, 2 }},
#define QOSRESPERCENT		15
{QOSRESPERCENT,  ASN_INTEGER,  RWRITE,  var_apQosBasicConfigTable, 4,  { 1,4, 1, 3 }},
#define QOSSHAREDBW		16
{QOSSHAREDBW,  ASN_INTEGER,  RWRITE,  var_apQosBasicConfigTable, 4,  { 1,4, 1, 4 }},
#define QOSSHAREDBWPERCENT		17
{QOSSHAREDBWPERCENT,  ASN_INTEGER,  RWRITE,  var_apQosBasicConfigTable, 4,  { 1,4, 1, 5 }},
#define SCHEDALGNAME		18
{SCHEDALGNAME,  ASN_OCTET_STR,  RWRITE,  var_apQosBasicConfigTable, 4,  { 1,4, 1, 6 }},
#define RESPOLICYENABLED		19
{RESPOLICYENABLED,  ASN_INTEGER,  RWRITE,  var_apQosBasicConfigTable, 4,  { 1,4, 1, 7 }},
#define RESPOLICYNAME		20
{RESPOLICYNAME,  ASN_OCTET_STR,  RWRITE,  var_apQosBasicConfigTable, 4,  { 1,4, 1, 8 }},
#define BACKGROUNDSVCAVGSPEED		21
{BACKGROUNDSVCAVGSPEED,  ASN_INTEGER,  RWRITE,  var_apQosBasicConfigTable, 4,  { 1,4, 1, 9 }},
#define BACKGROUNDSVCMAXBURST		22
{BACKGROUNDSVCMAXBURST,  ASN_INTEGER,  RWRITE,  var_apQosBasicConfigTable, 4,  { 1,4, 1, 10 }},
#define BACKGROUNDSVCPRIORITY		23
{BACKGROUNDSVCPRIORITY,  ASN_INTEGER,  RWRITE,  var_apQosBasicConfigTable, 4,  { 1,4, 1, 11 }},
#define BACKGROUNDSVCRESPRIORITY		24
{BACKGROUNDSVCRESPRIORITY,  ASN_INTEGER,  RWRITE,  var_apQosBasicConfigTable, 4,  { 1,4, 1, 12 }},
#define BESTEFFORTSVCAVGSPEED		25
{BESTEFFORTSVCAVGSPEED,  ASN_INTEGER,  RWRITE,  var_apQosBasicConfigTable, 4,  { 1,4, 1, 13 }},
#define BESTEFFORTSVCMAXBURST		26
{BESTEFFORTSVCMAXBURST,  ASN_INTEGER,  RWRITE,  var_apQosBasicConfigTable, 4,  { 1,4, 1, 14 }},
#define BESTEFFORTSVCPRIORITY		27
{BESTEFFORTSVCPRIORITY,  ASN_INTEGER,  RWRITE,  var_apQosBasicConfigTable, 4,  { 1,4, 1, 15 }},
#define BESTEFFORTSVCRESPRIORITY		28
{BESTEFFORTSVCRESPRIORITY,  ASN_INTEGER,  RWRITE,  var_apQosBasicConfigTable, 4,  { 1,4, 1, 16 }},
#define VOICESVCAVGSPEED		29
{VOICESVCAVGSPEED,  ASN_INTEGER,  RWRITE,  var_apQosBasicConfigTable, 4,  { 1,4, 1, 17 }},
#define VOICESVCMAXBURST		30
{VOICESVCMAXBURST,  ASN_INTEGER,  RWRITE,  var_apQosBasicConfigTable, 4,  { 1,4, 1, 18 }},
#define VOICESVCPRIORITY		31
{VOICESVCPRIORITY,  ASN_INTEGER,  RWRITE,  var_apQosBasicConfigTable, 4,  { 1,4, 1, 19 }},
#define VOICESVCRESPRIORITY		32
{VOICESVCRESPRIORITY,  ASN_INTEGER,  RWRITE,  var_apQosBasicConfigTable, 4,  { 1,4, 1, 20 }},
#define VIDEOSVCAVGSPEED		33
{VIDEOSVCAVGSPEED,  ASN_INTEGER,  RWRITE,  var_apQosBasicConfigTable, 4,  { 1,4, 1, 21 }},
#define VIDEOSVCMAXBURST		34
{VIDEOSVCMAXBURST,  ASN_INTEGER,  RWRITE,  var_apQosBasicConfigTable, 4,  { 1,4, 1, 22 }},
#define VIDEOSVCPRIORITY		35
{VIDEOSVCPRIORITY,  ASN_INTEGER,  RWRITE,  var_apQosBasicConfigTable, 4,  { 1,4, 1, 23 }},
#define VIDEOSVCRESPRIORITY		36
{VIDEOSVCRESPRIORITY,  ASN_INTEGER,  RWRITE,  var_apQosBasicConfigTable, 4,  { 1,4, 1, 24 }},
#define BGMAXSVCCNT		37
{BGMAXSVCCNT,  ASN_INTEGER,  RWRITE,  var_apQosBasicConfigTable, 4,  { 1,4, 1, 25 }},
#define BGSVCBW		38
{BGSVCBW,  ASN_INTEGER,  RWRITE,  var_apQosBasicConfigTable, 4,  { 1,4, 1, 26 }},
#define BGSVCBWPERCENT		39
{BGSVCBWPERCENT,  ASN_INTEGER,  RWRITE,  var_apQosBasicConfigTable, 4,  { 1,4, 1, 27 }},
#define BGISUSEWREDALG		40
{BGISUSEWREDALG,  ASN_INTEGER,  RWRITE,  var_apQosBasicConfigTable, 4,  { 1,4, 1, 28 }},
#define BGISUSETRAFFICSHAPING		41
{BGISUSETRAFFICSHAPING,  ASN_INTEGER,  RWRITE,  var_apQosBasicConfigTable, 4,  { 1,4, 1, 29 }},
#define BEMAXSVCCNT		42
{BEMAXSVCCNT,  ASN_INTEGER,  RWRITE,  var_apQosBasicConfigTable, 4,  { 1,4, 1, 30 }},
#define BESVCBW		43
{BESVCBW,  ASN_INTEGER,  RWRITE,  var_apQosBasicConfigTable, 4,  { 1,4, 1, 31 }},
#define BESVCBWPERCENT		44
{BESVCBWPERCENT,  ASN_INTEGER,  RWRITE,  var_apQosBasicConfigTable, 4,  { 1,4, 1, 32 }},
#define BEISUSEWREDALG		45
{BEISUSEWREDALG,  ASN_INTEGER,  RWRITE,  var_apQosBasicConfigTable, 4,  { 1,4, 1, 33 }},
#define BEISUSETRAFFICSHAPING		46
{BEISUSETRAFFICSHAPING,  ASN_INTEGER,  RWRITE,  var_apQosBasicConfigTable, 4,  { 1,4, 1, 34 }},
#define VOICEMAXSVCCNT		47
{VOICEMAXSVCCNT,  ASN_INTEGER,  RWRITE,  var_apQosBasicConfigTable, 4,  { 1,4, 1, 35 }},
#define VOICESVCBW		48
{VOICESVCBW,  ASN_INTEGER,  RWRITE,  var_apQosBasicConfigTable, 4,  { 1,4, 1, 36 }},
#define VOICESVCBWPERCENT		49
{VOICESVCBWPERCENT,  ASN_INTEGER,  RWRITE,  var_apQosBasicConfigTable, 4,  { 1,4, 1, 37 }},
#define VOICEISUSESTREAMBASEDQUEUE		50
{VOICEISUSESTREAMBASEDQUEUE,  ASN_INTEGER,  RWRITE,  var_apQosBasicConfigTable, 4,  { 1,4, 1, 38 }},
#define VOICESTREAMMAXQUEUELEN		51
{VOICESTREAMMAXQUEUELEN,  ASN_INTEGER,  RWRITE,  var_apQosBasicConfigTable, 4,  { 1,4, 1, 39 }},
#define VOICESTREAMAVGSPEED		52
{VOICESTREAMAVGSPEED,  ASN_INTEGER,  RWRITE,  var_apQosBasicConfigTable, 4,  { 1,4, 1, 40 }},
#define VOICESTREAMMAXBURST		53
{VOICESTREAMMAXBURST,  ASN_INTEGER,  RWRITE,  var_apQosBasicConfigTable, 4,  { 1,4, 1, 41 }},
#define VOICEISUSEWREDALG		54
{VOICEISUSEWREDALG,  ASN_INTEGER,  RWRITE,  var_apQosBasicConfigTable, 4,  { 1,4, 1, 42 }},
#define VOICEISUSETRAFFICSHAPING		55
{VOICEISUSETRAFFICSHAPING,  ASN_INTEGER,  RWRITE,  var_apQosBasicConfigTable, 4,  { 1,4, 1, 43 }},
#define VIDEOMAXSVCCNT		56
{VIDEOMAXSVCCNT,  ASN_INTEGER,  RWRITE,  var_apQosBasicConfigTable, 4,  { 1,4, 1, 44 }},
#define VIDEOESVCBW		57
{VIDEOESVCBW,  ASN_INTEGER,  RWRITE,  var_apQosBasicConfigTable, 4,  { 1,4, 1, 45 }},
#define VIDEOSVCBWPERCENT		58
{VIDEOSVCBWPERCENT,  ASN_INTEGER,  RWRITE,  var_apQosBasicConfigTable, 4,  { 1,4, 1, 46 }},
#define VIDEOISUSESTREAMBASEDQUEUE		59
{VIDEOISUSESTREAMBASEDQUEUE,  ASN_INTEGER,  RWRITE,  var_apQosBasicConfigTable, 4,  { 1,4, 1, 47 }},
#define VIDEOSTREAMMAXQUEUELEN		60
{VIDEOSTREAMMAXQUEUELEN,  ASN_INTEGER,  RWRITE,  var_apQosBasicConfigTable, 4,  { 1,4, 1, 48 }},
#define VIDEOSTREAMAVGSPEED		61
{VIDEOSTREAMAVGSPEED,  ASN_INTEGER,  RWRITE,  var_apQosBasicConfigTable, 4,  { 1,4, 1, 49 }},
#define VIDEOSTREAMMAXBURST		62
{VIDEOSTREAMMAXBURST,  ASN_INTEGER,  RWRITE,  var_apQosBasicConfigTable, 4,  { 1,4, 1, 50 }},
#define VIDEOISUSEWREDALG		63
{VIDEOISUSEWREDALG,  ASN_INTEGER,  RWRITE,  var_apQosBasicConfigTable, 4,  { 1,4, 1, 51 }},
#define VIDEOISUSETRAFFICSHAPING		64
{VIDEOISUSETRAFFICSHAPING,  ASN_INTEGER,  RWRITE,  var_apQosBasicConfigTable, 4,  { 1,4, 1, 52 }},
};


/*    (L = length of the oidsuffix) */


/** Initializes the accessAp module */
void
init_accessAp(void)
{

  //  'cat  /jffs/.OEM/.vendor_oid'
  FILE *fp;
  char oid_str[64]={0};
  char oid_tmp[64]={0};
  int  oid_len=0;
  int  count = 0;
  char *p = NULL;
  char *ptr=NULL;
  
  fp=fopen( "/jffs/.OEM/.vendor_oid","r");
  if(fp)
  {
	  memset(oid_str,0,64);
	  fgets(oid_str,sizeof(oid_str),fp);
	  oid_str[strlen(oid_str)-1] = '\0';
	  fclose(fp);
  }
  else
   {
	  memset(oid_str,0,64);
	  strcpy(oid_str, "1.3.6.1.4.1.31656"); 
   }
  
  
  memset(oid_tmp,0,64);
  strcpy(oid_tmp,oid_str);
	   
  ptr = strtok(oid_tmp, "."); 
  while(NULL != ptr)
  {
	  oid_len++;
	  ptr = strtok(NULL,".");
   }
  
  oid_len = oid_len + 3;  
  accessAp_variables_oid = (oid *)malloc(sizeof(oid)*(oid_len));

   p = strtok(oid_str, ".");
   while( NULL != p)
   {
         accessAp_variables_oid[count++] = (oid)atoi(p);
         p = strtok(NULL,".");
    }
    accessAp_variables_oid[count ++] = 2;
    accessAp_variables_oid[count ++] = 3;
    accessAp_variables_oid[count ++] = 3;
   

	
    DEBUGMSGTL(("accessAp", "Initializing\n"));


    /* register ourselves with the agent to handle our mib tree */
    REGISTER_MIB_NEW("accessAp", accessAp_variables, variable4,
               accessAp_variables_oid, count); 
	

    /* place any other initialization junk you need here */
}

/*
 * var_accessAp():
 *   This function is called every time the agent gets a request for
 *   a scalar variable that might be found within your mib section
 *   registered above.  It is up to you to do the right thing and
 *   return the correct value.
 *     You should also correct the value of "var_len" if necessary.
 *
 *   Please see the documentation for more information about writing
 *   module extensions, and check out the examples in the examples
 *   and mibII directories.
 */

void shutdown_contorlAp ( void )
{
 flush_Lists();
}

unsigned char *
var_accessAp(struct variable *vp, 
                oid     *name, 
                size_t  *length, 
                int     exact, 
                size_t  *var_len, 
                WriteMethod **write_method)
{
    /* variables we may use later */
    static long long_ret;
    static u_long ulong_ret;
    static unsigned char string[SPRINT_MAX_LEN];
    static oid objid[MAX_OID_LEN];
    static struct counter64 c64;

	load_Tables();
    if (header_generic(vp,name,length,exact,var_len,write_method)
                                  == MATCH_FAILED )
    return NULL;

    /* 
   * this is where we do the value assignments for the mib results.
   */
    switch(vp->magic) {
    default:
      ERROR_MSG("");
    }
    return NULL;
}




unsigned char *
var_apListFilterMacTable(struct variable *vp,
    	    oid     *name,
    	    size_t  *length,
    	    int     exact,
    	    size_t  *var_len,
    	    WriteMethod **write_method)
{
  int found = FALSE;
  oid rName [ MAX_OID_LEN ];                            // OID to be returned
  static long long_ret;
  static u_long ulong_ret;
  static unsigned char string[SPRINT_MAX_LEN];
  static oid objid[MAX_OID_LEN];
  static struct counter64 c64;
  load_Tables();
  memcpy (( char * ) rName, ( char * ) vp->name, ( int ) vp->namelen * sizeof ( oid ));
  for (np = LIST_FIRST ( &lfList ); np != NULL; np = LIST_NEXT (np, nodes )) {
    lf = ( struct Lf_Tbl_data * ) np->data;
    rName[vp->namelen + 0] = lf->ifIndex;
    rName[vp->namelen + 1] = lf->apListFilterMacIndex;
    if ((  exact && ( snmp_oid_compare ( rName, vp->namelen + 2, name, *length ) == 0 )) ||
        ( !exact && ( snmp_oid_compare ( rName, vp->namelen + 2, name, *length ) >  0 ))) {
      switch ( vp->magic ) {
          case APLISTFILTERMACVALUE:
          if ( lf->haveApListFilterMacValue  ) found = TRUE; break;
      }
    }
    if ( found )
      break;
  }

  if ( !found ) 
    return NULL;

  memcpy (( char * ) name, ( char * ) rName, ( vp->namelen + 2 ) * sizeof ( oid ));
  *length = vp->namelen + 2;
  *var_len = sizeof ( long );
  *write_method = NULL;

  switch ( vp->magic ) {

      case APLISTFILTERMACVALUE :
	  *var_len = strlen (  lf->apListFilterMacValue );
	   return ( UCHAR * ) lf->apListFilterMacValue;
        
    default:
      ERROR_MSG ( "" );
  }

  return NULL;
}






unsigned char *
var_apFilterConfigTable(struct variable *vp,
    	    oid     *name,
    	    size_t  *length,
    	    int     exact,
    	    size_t  *var_len,
    	    WriteMethod **write_method)

{
  int found = FALSE;
  oid rName [ MAX_OID_LEN ];                            // OID to be returned
  static long long_ret;
  static u_long ulong_ret;
  static unsigned char string[SPRINT_MAX_LEN];
  static oid objid[MAX_OID_LEN];
  static struct counter64 c64;
  load_Tables();
  memcpy (( char * ) rName, ( char * ) vp->name, ( int ) vp->namelen * sizeof ( oid ));
  for ( np = LIST_FIRST ( &cfList ); np != NULL; np = LIST_NEXT ( np, nodes )) {
    cf = ( struct Cf_Tbl_data * ) np->data;
    rName[vp->namelen] = cf->ifIndex;
    if ((  exact && ( snmp_oid_compare ( rName, vp->namelen + 1, name, *length ) == 0 )) ||
        ( !exact && ( snmp_oid_compare ( rName, vp->namelen + 1, name, *length ) >  0 ))) {
  switch ( vp->magic ) {
   case     APUSEFILTERMACVALUE:
    if (cf->haveApUseFilterMacValue     ) found = TRUE; break;

   case APMODEFILTERMACVALUE :
	if (cf->haveApModeFilterMacValue     ) found = TRUE; break;

   case APADDFILTERMACVALUE :	
	if (cf->haveApAddFilterMacValue      ) found = TRUE; break;

   case APDELFILTERMACVALUE :
	if (cf->haveApDelFilterMacValue      ) found = TRUE; break;
	 
      }      
    }
    if ( found )
      break;
  }

  if ( !found ) 
    return NULL;

   memcpy (( char * ) name, ( char * ) rName, ( vp->namelen + 1 ) * sizeof ( oid ));
  *length = vp->namelen + 1;
  *var_len = sizeof ( long );
  *write_method = NULL;

  switch ( vp->magic ) {

    case APUSEFILTERMACVALUE:
	  *write_method = write_apUseFilterMacValue;
	  *var_len = strlen (  cf->apUseFilterMacValue );
      return ( UCHAR * ) cf->apUseFilterMacValue ;

   case APMODEFILTERMACVALUE :
      *write_method = write_apModeFilterMacValue;
	  *var_len = strlen (  cf->apModeFilterMacValue );
      return ( UCHAR * ) cf->apModeFilterMacValue ;

   case APADDFILTERMACVALUE :	
      *write_method = write_apAddFilterMacValue;
	  *var_len = strlen (  cf->apAddFilterMacValue );
      return ( UCHAR * ) cf->apAddFilterMacValue ;

   case APDELFILTERMACVALUE :
      *write_method = write_apDelFilterMacValue;
	  *var_len = strlen (  cf->apDelFilterMacValue );
      return ( UCHAR * ) cf->apDelFilterMacValue ;
        
 default:
      ERROR_MSG ( "" );
  }

  return NULL;
}






unsigned char *
var_apWmmQosRadioTable(struct variable *vp,
    	    oid     *name,
    	    size_t  *length,
    	    int     exact,
    	    size_t  *var_len,
    	    WriteMethod **write_method)

{
  int found = FALSE;
  oid rName [ MAX_OID_LEN ];                            // OID to be returned
  static long long_ret;
  static u_long ulong_ret;
  static unsigned char string[SPRINT_MAX_LEN];
  static oid objid[MAX_OID_LEN];
  static struct counter64 c64;
  load_Tables();
  memcpy (( char * ) rName, ( char * ) vp->name, ( int ) vp->namelen * sizeof ( oid ));
  for ( np = LIST_FIRST ( &qsList ); np != NULL; np = LIST_NEXT ( np, nodes )) {
    qs = ( struct Qs_Tbl_data * ) np->data;
    rName[vp->namelen] = qs->ifIndex;
    if ((  exact && ( snmp_oid_compare ( rName, vp->namelen + 1, name, *length ) == 0 )) ||
        ( !exact && ( snmp_oid_compare ( rName, vp->namelen + 1, name, *length ) >  0 ))) {
  switch ( vp->magic ) {
	    case QOSTRAFFICCLASS:
	    if (qs->haveQosTrafficClass     ) found = TRUE; break;
	    case QOSCHOOSEAPSTATION:
		if (qs->haveQosChooseApStation     ) found = TRUE; break;
	    case QOSAIFS:
		if (qs->haveQosAIFS      ) found = TRUE; break;
	    case QOSCWMIN:
		if (qs->haveQosCWmin      ) found = TRUE; break;
	    case QOSCWMAX:
		if (qs->haveQosCWmax      ) found = TRUE; break;
	    case QOSTXOPLIM:
		if (qs->haveQosTXOPLim      ) found = TRUE; break;
      }      
    }
    if ( found )
      break;
  }

  if ( !found ) 
    return NULL;

   memcpy (( char * ) name, ( char * ) rName, ( vp->namelen + 1 ) * sizeof ( oid ));
  *length = vp->namelen + 1;
  *var_len = sizeof ( long );
  *write_method = NULL;

  switch ( vp->magic ) {
	    case QOSTRAFFICCLASS:
		    *write_method = write_QosTrafficClass;
		    return ( UCHAR * ) &qs->QosTrafficClass ;
		 
	    case QOSCHOOSEAPSTATION:
    		*write_method = write_QosChooseApStation;
		    return ( UCHAR * ) &qs->QosChooseApStation ;
		 
	    case QOSAIFS:
	        *write_method = write_QosAIFS;
		    return ( UCHAR * ) &qs->QosAIFS ;
		 
	    case QOSCWMIN:
	       *write_method = write_QosCWmin;
		   return ( UCHAR * ) &qs->QosCWmin ;
		 
	    case QOSCWMAX:
	       *write_method = write_QosCWmax;
		   return ( UCHAR * ) &qs->QosCWmax ;
		 
	    case QOSTXOPLIM:
       		*write_method = write_QosTXOPLim;
		    return ( UCHAR * ) &qs->QosTXOPLim ;
        
 default:
      ERROR_MSG ( "" );
  }

  return NULL;
}




unsigned char *
var_apQosBasicConfigTable(struct variable *vp,
    	    oid     *name,
    	    size_t  *length,
    	    int     exact,
    	    size_t  *var_len,
    	    WriteMethod **write_method)
{
  int found = FALSE;
  oid rName [ MAX_OID_LEN ];                            // OID to be returned
  static long long_ret;
  static u_long ulong_ret;
  static unsigned char string[SPRINT_MAX_LEN];
  static oid objid[MAX_OID_LEN];
  static struct counter64 c64;
  load_Tables();
  memcpy (( char * ) rName, ( char * ) vp->name, ( int ) vp->namelen * sizeof ( oid ));
  for (np = LIST_FIRST ( &qcList ); np != NULL; np = LIST_NEXT (np, nodes )) {
    qc = ( struct Qc_Tbl_data * ) np->data;
    rName[vp->namelen + 0] = qc->ifIndex;
    if ((  exact && ( snmp_oid_compare ( rName, vp->namelen +1, name, *length ) == 0 )) ||
        ( !exact && ( snmp_oid_compare ( rName, vp->namelen +1, name, *length ) >  0 ))) {
      switch ( vp->magic ) {
    case QOSENABLED:
	if (qc->haveQosEnabled     ) found = TRUE; break;
    case QOSBW:
	if (qc->haveQosBW     ) found = TRUE; break;
    case QOSRESPERCENT:
	if (qc->haveQoSResPercent     ) found = TRUE; break;
    case QOSSHAREDBW:
	if (qc->haveQossharedBW     ) found = TRUE; break;
    case QOSSHAREDBWPERCENT:
	if (qc->haveQossharedBWPercent     ) found = TRUE; break;	
    case SCHEDALGNAME:
	if (qc->haveSchedAlgName     ) found = TRUE; break;
    case RESPOLICYENABLED:
	if (qc->haveResPolicyEnabled     ) found = TRUE; break;
    case RESPOLICYNAME:
	if (qc->haveResPolicyName     ) found = TRUE; break;
	
    case BACKGROUNDSVCAVGSPEED:
	if (qc->haveBackgroundSvcAvgSpeed     ) found = TRUE; break;
    case BACKGROUNDSVCMAXBURST:
	if (qc->haveBackgroundSvcMaxBurst     ) found = TRUE; break;
    case BACKGROUNDSVCPRIORITY:
	if (qc->haveBackgroundSvcPriority     ) found = TRUE; break;
    case BACKGROUNDSVCRESPRIORITY:
	if (qc->haveBackgroundSvcResPriority     ) found = TRUE; break;

	
    case BESTEFFORTSVCAVGSPEED:
	if (qc->haveBestEffortSvcAvgSpeed     ) found = TRUE; break;
    case BESTEFFORTSVCMAXBURST:
	if (qc->haveBestEffortSvcMaxBurst     ) found = TRUE; break;
    case BESTEFFORTSVCPRIORITY:
	if (qc->haveBestEffortSvcPriority     ) found = TRUE; break;
    case BESTEFFORTSVCRESPRIORITY:
	if (qc->haveBestEffortSvcResPriority     ) found = TRUE; break;

	
    case VOICESVCAVGSPEED:
	if (qc->haveVoiceSvcAvgSpeed     ) found = TRUE; break;
    case VOICESVCMAXBURST:
	if (qc->haveVoiceSvcMaxBurst     ) found = TRUE; break;
    case VOICESVCPRIORITY:
	if (qc->haveVoiceSvcPriority     ) found = TRUE; break;
    case VOICESVCRESPRIORITY:
	if (qc->haveVoiceSvcResPriority     ) found = TRUE; break;

	
    case VIDEOSVCAVGSPEED:
	if (qc->haveVideoSvcAvgSpeed     ) found = TRUE; break;
    case VIDEOSVCMAXBURST:
	if (qc->haveVideoSvcMaxBurst     ) found = TRUE; break;
    case VIDEOSVCPRIORITY:
	if (qc->haveVideoSvcPriority     ) found = TRUE; break;
    case VIDEOSVCRESPRIORITY:
	if (qc->haveVideoSvcResPriority     ) found = TRUE; break;

	
    case BGMAXSVCCNT:
	if (qc->haveBgMaxSvcCnt     ) found = TRUE; break;
    case BGSVCBW:
	if (qc->haveBgSvcBW     ) found = TRUE; break;
    case BGSVCBWPERCENT:
	if (qc->haveBgSvcBWPercent     ) found = TRUE; break;
    case BGISUSEWREDALG:
	if (qc->haveBgIsUseWREDAlg     ) found = TRUE; break;
    case BGISUSETRAFFICSHAPING:
	if (qc->haveBgIsUseTrafficShaping     ) found = TRUE; break;

	
    case BEMAXSVCCNT:
	if (qc->haveBeMaxSvcCnt     ) found = TRUE; break;
    case BESVCBW:
	if (qc->haveBeSvcBW     ) found = TRUE; break;
    case BESVCBWPERCENT:
	if (qc->haveBeSvcBWPercent     ) found = TRUE; break;
    case BEISUSEWREDALG:
	if (qc->haveBeIsUseWREDAlg     ) found = TRUE; break;
    case BEISUSETRAFFICSHAPING:
	if (qc->haveBeIsUseTrafficShaping     ) found = TRUE; break;


	
    case VOICEMAXSVCCNT:
	if (qc->haveVoiceMaxSvcCnt     ) found = TRUE; break;	
    case VOICESVCBW:
	if (qc->haveVoiceSvcBW     ) found = TRUE; break;
    case VOICESVCBWPERCENT:
	if (qc->haveVoiceSvcBWPercent     ) found = TRUE; break;
    case VOICEISUSESTREAMBASEDQUEUE:
	if (qc->haveVoiceIsUseStreamBasedQueue     ) found = TRUE; break;
    case VOICESTREAMMAXQUEUELEN:
	if (qc->haveVoiceStreamMaxQueueLen     ) found = TRUE; break;
    case VOICESTREAMAVGSPEED:
	if (qc->haveVoiceStreamAvgSpeed     ) found = TRUE; break;
    case VOICESTREAMMAXBURST:
	if (qc->haveVoiceStreamMaxBurst     ) found = TRUE; break;
    case VOICEISUSEWREDALG:
	if (qc->haveVoiceIsUseWREDAlg     ) found = TRUE; break;
    case VOICEISUSETRAFFICSHAPING:
	if (qc->haveVoiceIsUseTrafficShaping     ) found = TRUE; break;

	
    case VIDEOMAXSVCCNT:
	if (qc->haveVideoMaxSvcCnt     ) found = TRUE; break;
    case VIDEOESVCBW:
	if (qc->haveVideoeSvcBW     ) found = TRUE; break;
    case VIDEOSVCBWPERCENT:
	if (qc->haveVideoSvcBWPercent     ) found = TRUE; break;
    case VIDEOISUSESTREAMBASEDQUEUE:
	if (qc->haveVideoIsUseStreamBasedQueue     ) found = TRUE; break;
    case VIDEOSTREAMMAXQUEUELEN:
	if (qc->haveVideoStreamMaxQueueLen     ) found = TRUE; break;
    case VIDEOSTREAMAVGSPEED:
	if (qc->haveVideoStreamAvgSpeed     ) found = TRUE; break;
    case VIDEOSTREAMMAXBURST:
	if (qc->haveVideoStreamMaxBurst     ) found = TRUE; break;
    case VIDEOISUSEWREDALG:
	if (qc->haveVideoIsUseWREDAlg     ) found = TRUE; break;
    case VIDEOISUSETRAFFICSHAPING:
	if (qc->haveVideoIsUseTrafficShaping     ) found = TRUE; break;



		  
      }
    }
    if ( found )
      break;
  }

  if ( !found ) 
    return NULL;

   memcpy (( char * ) name, ( char * ) rName, ( vp->namelen + 1 ) * sizeof ( oid ));
  *length = vp->namelen + 1;
  *var_len = sizeof ( long );
  *write_method = NULL;

  switch ( vp->magic ) {

		    case QOSENABLED:
		        *write_method = write_QosEnabled;
		        return ( UCHAR * ) &qc->QosEnabled ;
		    case QOSBW:
		        *write_method = write_QosBW;
		        return ( UCHAR * ) &qc->QosBW ;
		    case QOSRESPERCENT:
		        *write_method = write_QoSResPercent;
		        return ( UCHAR * ) &qc->QoSResPercent ;
		    case QOSSHAREDBW:
		        *write_method = write_QossharedBW;
		        return ( UCHAR * ) &qc->QossharedBW ;
		    case QOSSHAREDBWPERCENT:
		        *write_method = write_QossharedBWPercent;
		        return ( UCHAR * ) &qc->QossharedBWPercent ;
		    case SCHEDALGNAME:
		        *write_method = write_SchedAlgName;
	  		    *var_len = strlen (  qc->SchedAlgName );
		        return ( UCHAR * )qc->SchedAlgName ;
		    case RESPOLICYENABLED:
		        *write_method = write_ResPolicyEnabled;
		        return ( UCHAR * ) &qc->ResPolicyEnabled ;
		    case RESPOLICYNAME:
		        *write_method = write_ResPolicyName;
	  		    *var_len = strlen (  qc->SchedAlgName );
		        return ( UCHAR * ) qc->ResPolicyName ;
		    case BACKGROUNDSVCAVGSPEED:
		        *write_method = write_BackgroundSvcAvgSpeed;
		        return ( UCHAR * ) &qc->BackgroundSvcAvgSpeed ;
		    case BACKGROUNDSVCMAXBURST:
		        *write_method = write_BackgroundSvcMaxBurst;
		        return ( UCHAR * ) &qc->BackgroundSvcMaxBurst ;
		    case BACKGROUNDSVCPRIORITY:
		        *write_method = write_BackgroundSvcPriority;
		        return ( UCHAR * ) &qc->BackgroundSvcPriority ;
		    case BACKGROUNDSVCRESPRIORITY:
		        *write_method = write_BackgroundSvcResPriority;
		        return ( UCHAR * ) &qc->BackgroundSvcResPriority ;
		    case BESTEFFORTSVCAVGSPEED:
		        *write_method = write_BestEffortSvcAvgSpeed;
		        return ( UCHAR * ) &qc->BestEffortSvcAvgSpeed ;
		    case BESTEFFORTSVCMAXBURST:
		        *write_method = write_BestEffortSvcMaxBurst;
		        return ( UCHAR * ) &qc->BestEffortSvcMaxBurst ;
		    case BESTEFFORTSVCPRIORITY:
		        *write_method = write_BestEffortSvcPriority;
		        return ( UCHAR * ) &qc->BestEffortSvcPriority ;
		    case BESTEFFORTSVCRESPRIORITY:
		        *write_method = write_BestEffortSvcResPriority;
		        return ( UCHAR * ) &qc->BestEffortSvcResPriority ;
		    case VOICESVCAVGSPEED:
		        *write_method = write_VoiceSvcAvgSpeed;
		        return ( UCHAR * ) &qc->VoiceSvcAvgSpeed ;
		    case VOICESVCMAXBURST:
		        *write_method = write_VoiceSvcMaxBurst;
		        return ( UCHAR * ) &qc->VoiceSvcMaxBurst ;
		    case VOICESVCPRIORITY:
		        *write_method = write_VoiceSvcPriority;
		        return ( UCHAR * ) &qc->VoiceSvcPriority ;
		    case VOICESVCRESPRIORITY:
		        *write_method = write_VoiceSvcResPriority;
		        return ( UCHAR * ) &qc->VoiceSvcResPriority ;
		    case VIDEOSVCAVGSPEED:
		        *write_method = write_VideoSvcAvgSpeed;
		        return ( UCHAR * ) &qc->VideoSvcAvgSpeed ;
		    case VIDEOSVCMAXBURST:
		        *write_method = write_VideoSvcMaxBurst;
		        return ( UCHAR * ) &qc->VideoSvcMaxBurst ;
		    case VIDEOSVCPRIORITY:
		        *write_method = write_VideoSvcPriority;
		        return ( UCHAR * ) &qc->VideoSvcPriority ;
		    case VIDEOSVCRESPRIORITY:
		        *write_method = write_VideoSvcResPriority;
		        return ( UCHAR * ) &qc->VideoSvcResPriority ;
		    case BGMAXSVCCNT:
		        *write_method = write_BgMaxSvcCnt;
		        return ( UCHAR * ) &qc->BgMaxSvcCnt ;
		    case BGSVCBW:
		        *write_method = write_BgSvcBW;
		        return ( UCHAR * ) &qc->BgSvcBW ;
		    case BGSVCBWPERCENT:
		        *write_method = write_BgSvcBWPercent;
		        return ( UCHAR * ) &qc->BgSvcBWPercent ;
		    case BGISUSEWREDALG:
		        *write_method = write_BgIsUseWREDAlg;
		        return ( UCHAR * ) &qc->BgIsUseWREDAlg ;
		    case BGISUSETRAFFICSHAPING:
		        *write_method = write_BgIsUseTrafficShaping;
		        return ( UCHAR * ) &qc->BgIsUseTrafficShaping ;
		    case BEMAXSVCCNT:
		        *write_method = write_BeMaxSvcCnt;
		        return ( UCHAR * ) &qc->BeMaxSvcCnt ;
		    case BESVCBW:
		        *write_method = write_BeSvcBW;
		        return ( UCHAR * ) &qc->BeSvcBW ;
		    case BESVCBWPERCENT:
		        *write_method = write_BeSvcBWPercent;
		        return ( UCHAR * ) &qc->BeSvcBWPercent ;
		    case BEISUSEWREDALG:
		        *write_method = write_BeIsUseWREDAlg;
		        return ( UCHAR * ) &qc->BeIsUseWREDAlg ;
		    case BEISUSETRAFFICSHAPING:
		        *write_method = write_BeIsUseTrafficShaping;
		        return ( UCHAR * ) &qc->BeIsUseTrafficShaping ;
		    case VOICEMAXSVCCNT:
		        *write_method = write_VoiceMaxSvcCnt;
		        return ( UCHAR * ) &qc->VoiceMaxSvcCnt ;
		    case VOICESVCBW:
		        *write_method = write_VoiceSvcBW;
		        return ( UCHAR * ) &qc->VoiceSvcBW ;
		    case VOICESVCBWPERCENT:
		        *write_method = write_VoiceSvcBWPercent;
		        return ( UCHAR * ) &qc->VoiceSvcBWPercent ;
		    case VOICEISUSESTREAMBASEDQUEUE:
		        *write_method = write_VoiceIsUseStreamBasedQueue;
		        return ( UCHAR * ) &qc->VoiceIsUseStreamBasedQueue ;
		    case VOICESTREAMMAXQUEUELEN:
		        *write_method = write_VoiceStreamMaxQueueLen;
		        return ( UCHAR * ) &qc->VoiceStreamMaxQueueLen ;
		    case VOICESTREAMAVGSPEED:
		        *write_method = write_VoiceStreamAvgSpeed;
		        return ( UCHAR * ) &qc->VoiceStreamAvgSpeed ;
		    case VOICESTREAMMAXBURST:
		        *write_method = write_VoiceStreamMaxBurst;
		        return ( UCHAR * ) &qc->VoiceStreamMaxBurst ;
		    case VOICEISUSEWREDALG:
		        *write_method = write_VoiceIsUseWREDAlg;
		        return ( UCHAR * ) &qc->VoiceIsUseWREDAlg ;
		    case VOICEISUSETRAFFICSHAPING:
		        *write_method = write_VoiceIsUseTrafficShaping;
		        return ( UCHAR * ) &qc->VoiceIsUseTrafficShaping ;
		    case VIDEOMAXSVCCNT:
		        *write_method = write_VideoMaxSvcCnt;
		        return ( UCHAR * ) &qc->VideoMaxSvcCnt ;
		    case VIDEOESVCBW:
		        *write_method = write_VideoeSvcBW;
		        return ( UCHAR * ) &qc->VideoeSvcBW  ;
		    case VIDEOSVCBWPERCENT:
		        *write_method = write_VideoSvcBWPercent;
		        return ( UCHAR * ) &qc->VideoSvcBWPercent ;
		    case VIDEOISUSESTREAMBASEDQUEUE:
		        *write_method = write_VideoIsUseStreamBasedQueue;
		        return ( UCHAR * ) &qc->VideoIsUseStreamBasedQueue ;
		    case VIDEOSTREAMMAXQUEUELEN:
		        *write_method = write_VideoStreamMaxQueueLen;
		        return ( UCHAR * ) &qc->VideoStreamMaxQueueLen ;
		    case VIDEOSTREAMAVGSPEED:
		        *write_method = write_VideoStreamAvgSpeed;
		        return ( UCHAR * ) &qc->VideoStreamAvgSpeed ;
		    case VIDEOSTREAMMAXBURST:
		        *write_method = write_VideoStreamMaxBurst;
		        return ( UCHAR * ) &qc->VideoStreamMaxBurst ;
		    case VIDEOISUSEWREDALG:
		        *write_method = write_VideoIsUseWREDAlg;
		        return ( UCHAR * ) &qc->VideoIsUseWREDAlg ;
		    case VIDEOISUSETRAFFICSHAPING:
		        *write_method = write_VideoIsUseTrafficShaping;
		        return ( UCHAR * ) &qc->VideoIsUseTrafficShaping ;
        
    default:
      ERROR_MSG ( "" );
  }

  return NULL;
}





write_apUseFilterMacValue(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    char value[SNMP_STR_LEN+ 1 ];
    int size;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to autelanAp not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(value)) {
              fprintf(stderr,"write to autelanAp: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;
		  

        case RESERVE2:
         // size  = var_val_len;
          //value = * (char *) var_val;

          break;

        case FREE:
          break;

        case ACTION:
	     memcpy(value,var_val,var_val_len);
		 value[var_val_len]='\0';
         wireless_security_macfilter(get_vnum_by_vname( nCf.ifName ),value);
			
          break;

        case UNDO:
          break;

        case COMMIT:
          break;
    }
    return SNMP_ERR_NOERROR;
}


            
write_apModeFilterMacValue(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    char value[SNMP_STR_LEN+ 1 ];
    int size;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to autelanAp not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(value)) {
              fprintf(stderr,"write to autelanAp: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
         // size  = var_val_len;
          //value = * (char *) var_val;

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
		memcpy(value,var_val,var_val_len);
		 value[var_val_len]='\0';
         wireless_security_filtermode(get_vnum_by_vname( nCf.ifName ),value);
			
          break;

        case UNDO:
          break;

        case COMMIT:
          break;
    }
    return SNMP_ERR_NOERROR;
}


write_apAddFilterMacValue(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    char value[SNMP_STR_LEN+ 1 ];
    int size;
    //printf("name:%d\n\n",name);
   // printf("*name:%d\n\n",*name);

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to autelanAp not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(value)) {
              fprintf(stderr,"write to autelanAp: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
         // size  = var_val_len;
          //value = * (char *) var_val;

          break;

        case FREE:
          break;

        case ACTION:
		   memcpy(value,var_val,var_val_len);
		   value[var_val_len]='\0';
           wireless_security_filter_addmac(get_vnum_by_vname( nCf.ifName ),(char *)"mac3", value) ; 
          break;

        case UNDO:
          break;

        case COMMIT:
          break;
    }
    return SNMP_ERR_NOERROR;
}




write_apDelFilterMacValue(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    char value[SNMP_STR_LEN+ 1 ];
    int size;
	//printf("statP:%s\n\n",statP);
    //printf("name:%d\n\n",name);
	
   // printf("name:%ld\n\n",*name);

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to autelanAp not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(value)) {
              fprintf(stderr,"write to autelanAp: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
         // size  = var_val_len;
          //value = * (char *) var_val;

          break;

        case FREE:
            
          break;

        case ACTION:
		   memcpy(value,var_val,var_val_len);
		   value[var_val_len]='\0';
           wireless_security_filter_delmac(get_vnum_by_vname( nCf.ifName ), value);          
		  break;

        case UNDO:
          break;

        case COMMIT:
          break;
    }
    return SNMP_ERR_NOERROR;
}



int
write_QosTrafficClass(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    static   char  value[ACCESS_BUF];
    static   char  string[ACCESS_BUF];
    int size;
    static long  long_ret;
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to accessAp not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to accessAp: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
	        long_ret  =*((long *) var_val);
		printf("long_ret:%d\n",long_ret);
	   	if((long_ret<0)||(long_ret>3)){
              fprintf(stderr,"write to accessAp: bad value\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          //size  = var_val_len;
          //value = * (long *) var_val;

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
		memset(value,0,ACCESS_BUF);
		memset(string,0,ACCESS_BUF);
		memset(nQs.ifName,0,IFNAME_LEN + 1);
		for(size=0;size<name_len;size++)
		{
		  printf("name[%d]%d\n",size,name[size]);
		}
		nQs.ifIndex=name[name_len-1];
               printf("nQs.ifIndex==%d\n",nQs.ifIndex);
		 if_indextoname(nQs.ifIndex,nQs.ifName);
		 sprintf(string,"%s%s",nQs.ifName,"_TRAFFIC_CLASS");
		 sprintf(value,"%d",long_ret);
		 printf("string:%s,value:%s\n",string,value);
	 	 save_global_conf(SEP_EQUAL,SNMP_QOS_CONF,"",string,value);

		 
		
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_QosChooseApStation(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    static   char  value[ACCESS_BUF];
    static   char  string[ACCESS_BUF];
    int size;
    static long  long_ret;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to accessAp not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to accessAp: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
	        long_ret  =*((long *) var_val);
	   	if((long_ret!=0)&&(long_ret!=1)){
              fprintf(stderr,"write to accessAp: bad value\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
         // size  = var_val_len;
          //value = * (long *) var_val;

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
		memset(value,0,ACCESS_BUF);
		memset(string,0,ACCESS_BUF);
		memset(nQs.ifName,0,IFNAME_LEN + 1);
		for(size=0;size<name_len;size++)
		{
		  printf("name[%d]%d\n",size,name[size]);
		}
		nQs.ifIndex=name[name_len-1];
               printf("nQs.ifIndex==%d\n",nQs.ifIndex);
		 if_indextoname(nQs.ifIndex,nQs.ifName);
		 sprintf(string,"%s%s",nQs.ifName,"_AP_STAT");
		 sprintf(value,"%d",long_ret);
		 printf("string:%s,value:%s\n",string,value);
	 	 save_global_conf(SEP_EQUAL,SNMP_QOS_CONF,"",string,value);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_QosAIFS(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    static   char  para1[ACCESS_BUF];
    static   char  para2[ACCESS_BUF];
    static   char  string[ACCESS_BUF];
    static   char  buffer[ACCESS_BUF];
    static   char  value[ACCESS_BUF];
    int size;
    static long  long_ret;
    static struct counter64 c64;
    prop_data properties[255];
    int prop_count=0;
    int prop_numb=0;
	
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to accessAp not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to accessAp: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
	        long_ret  =*((long *) var_val);
          if ((long_ret)<1||(long_ret>15)) {
              fprintf(stderr,"write to accessAp: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
        //  size  = var_val_len;
        //  value = * (long *) var_val;

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
	memset(buffer,0,ACCESS_BUF);
	memset(string,0,ACCESS_BUF);
	memset(para1,0,ACCESS_BUF);
	memset(para2,0,ACCESS_BUF);
       memset(value,0,ACCESS_BUF);
	memset(nQs.ifName,0,IFNAME_LEN + 1);
	for(size=0;size<name_len;size++)
	{
	  printf("name[%d]%d\n",size,name[size]);
	}
	nQs.ifIndex=name[name_len-1];
           printf("nQs.ifIndex==%d\n",nQs.ifIndex);
	 if_indextoname(nQs.ifIndex,nQs.ifName);
	 sprintf(buffer,"%s%s",nQs.ifName,"_TRAFFIC_CLASS");
	 sprintf(string,"%s%s",nQs.ifName,"_AP_STAT");
 	prop_numb=load_prop(SEP_EQUAL,SNMP_QOS_CONF,properties);
   	get_prop(buffer,para1,properties,prop_numb);
    	free_prop(properties,prop_numb) ;//取出访问控制类ac类型
		
 	prop_count=load_prop(SEP_EQUAL,SNMP_QOS_CONF,properties);
   	get_prop(string,para2,properties,prop_count);
    	free_prop(properties,prop_count) ;//取出值ap或station	   
	printf("para1:%s,para2:%s\n",para1,para2);	
	 sprintf(value,"%s  %s  %s  %s  %s  %d","/usr/sbin/iwpriv",nQs.ifName,"aifs",para1,para2, long_ret);
	 printf("value:%s\n",value);
	 system(value);
	 
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_QosCWmin(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    static   char  para1[ACCESS_BUF];
    static   char  para2[ACCESS_BUF];
    static   char  string[ACCESS_BUF];
    static   char  buffer[ACCESS_BUF];
    static   char  value[ACCESS_BUF];
    int size;
    static long  long_ret;
    static struct counter64 c64;
    prop_data properties[255];
    int prop_count=0;
    int prop_numb=0;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to accessAp not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to accessAp: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
	      long_ret  =*((long *) var_val);
          if ((long_ret)<0||(long_ret>15)) {
              fprintf(stderr,"write to accessAp: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
         // size  = var_val_len;
         // value = * (long *) var_val;

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
	memset(buffer,0,ACCESS_BUF);
	memset(string,0,ACCESS_BUF);
	memset(para1,0,ACCESS_BUF);
	memset(para2,0,ACCESS_BUF);
       memset(value,0,ACCESS_BUF);
	memset(nQs.ifName,0,IFNAME_LEN + 1);
	for(size=0;size<name_len;size++)
	{
	  printf("name[%d]%d\n",size,name[size]);
	}
	nQs.ifIndex=name[name_len-1];
           printf("nQs.ifIndex==%d\n",nQs.ifIndex);
	 if_indextoname(nQs.ifIndex,nQs.ifName);
	 sprintf(buffer,"%s%s",nQs.ifName,"_TRAFFIC_CLASS");
	 sprintf(string,"%s%s",nQs.ifName,"_AP_STAT");
 	prop_numb=load_prop(SEP_EQUAL,SNMP_QOS_CONF,properties);
   	get_prop(buffer,para1,properties,prop_numb);
    	free_prop(properties,prop_numb) ;//取出访问控制类ac类型
		
 	prop_count=load_prop(SEP_EQUAL,SNMP_QOS_CONF,properties);
   	get_prop(string,para2,properties,prop_count);
    	free_prop(properties,prop_count) ;//取出值ap或station	   
	 sprintf(value,"%s  %s  %s  %s  %s  %d","/usr/sbin/iwpriv",nQs.ifName,"cwmin",para1,para2, long_ret);
	 printf("value:%s\n",value);
	 system(value);
	 
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_QosCWmax(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    static   char  para1[ACCESS_BUF];
    static   char  para2[ACCESS_BUF];
    static   char  string[ACCESS_BUF];
    static   char  buffer[ACCESS_BUF];
    static   char  value[ACCESS_BUF];
    int size;
    static long  long_ret;
    static struct counter64 c64;
    prop_data properties[255];
    int prop_count=0;
    int prop_numb=0;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to accessAp not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to accessAp: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
	      long_ret  =*((long *) var_val);
          if ((long_ret)<0||(long_ret>15)) {
              fprintf(stderr,"write to accessAp: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
		  
          break;

        case RESERVE2:
         // size  = var_val_len;
         // value = * (long *) var_val;

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
	memset(buffer,0,ACCESS_BUF);
	memset(string,0,ACCESS_BUF);
	memset(para1,0,ACCESS_BUF);
	memset(para2,0,ACCESS_BUF);
       memset(value,0,ACCESS_BUF);
	memset(nQs.ifName,0,IFNAME_LEN + 1);
	for(size=0;size<name_len;size++)
	{
	  printf("name[%d]%d\n",size,name[size]);
	}
	nQs.ifIndex=name[name_len-1];
           printf("nQs.ifIndex==%d\n",nQs.ifIndex);
	 if_indextoname(nQs.ifIndex,nQs.ifName);
	 sprintf(buffer,"%s%s",nQs.ifName,"_TRAFFIC_CLASS");
	 sprintf(string,"%s%s",nQs.ifName,"_AP_STAT");
 	prop_numb=load_prop(SEP_EQUAL,SNMP_QOS_CONF,properties);
   	get_prop(buffer,para1,properties,prop_numb);
    	free_prop(properties,prop_numb) ;//取出访问控制类ac类型
		
 	prop_count=load_prop(SEP_EQUAL,SNMP_QOS_CONF,properties);
   	get_prop(string,para2,properties,prop_count);
    	free_prop(properties,prop_count) ;//取出值ap或station	   
	 sprintf(value,"%s  %s  %s  %s  %s  %d","/usr/sbin/iwpriv",nQs.ifName,"cwmax",para1,para2, long_ret);
	 printf("value:%s\n",value);
	 system(value);
	 
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_QosTXOPLim(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    static   char  para1[ACCESS_BUF];
    static   char  para2[ACCESS_BUF];
    static   char  string[ACCESS_BUF];
    static   char  buffer[ACCESS_BUF];
    static   char  value[ACCESS_BUF];
    int size;
    static long  long_ret;
    static struct counter64 c64;
    prop_data properties[255];
    int prop_count=0;
    int prop_numb=0;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to accessAp not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to accessAp: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
	      long_ret  =*((long *) var_val);
          if ((long_ret)<0||(long_ret>65535)) {
              fprintf(stderr,"write to accessAp: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
        //  size  = var_val_len;
       //   value = * (long *) var_val;

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
	memset(buffer,0,ACCESS_BUF);
	memset(string,0,ACCESS_BUF);
	memset(para1,0,ACCESS_BUF);
	memset(para2,0,ACCESS_BUF);
       memset(value,0,ACCESS_BUF);
	memset(nQs.ifName,0,IFNAME_LEN + 1);
	for(size=0;size<name_len;size++)
	{
	  printf("name[%d]%d\n",size,name[size]);
	}
	nQs.ifIndex=name[name_len-1];
           printf("nQs.ifIndex==%d\n",nQs.ifIndex);
	 if_indextoname(nQs.ifIndex,nQs.ifName);
	 sprintf(buffer,"%s%s",nQs.ifName,"_TRAFFIC_CLASS");
	 sprintf(string,"%s%s",nQs.ifName,"_AP_STAT");
 	prop_numb=load_prop(SEP_EQUAL,SNMP_QOS_CONF,properties);
   	get_prop(buffer,para1,properties,prop_numb);
    	free_prop(properties,prop_numb) ;//取出访问控制类ac类型
		
 	prop_count=load_prop(SEP_EQUAL,SNMP_QOS_CONF,properties);
   	get_prop(string,para2,properties,prop_count);
    	free_prop(properties,prop_count) ;//取出值ap或station	   
	 sprintf(value,"%s  %s  %s  %s  %s  %d","/usr/sbin/iwpriv",nQs.ifName,"txoplimit",para1,para2, long_ret);
	 printf("value:%s\n",value);
	 system(value);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_QosEnabled(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    int size;
    static long  long_ret;
    static   char string[ACCESS_BUF];
    static   char  value[ACCESS_BUF];
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to accessAp not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to accessAp: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
	      long_ret  =*((long *) var_val);
	 if((long_ret!=0)&&(long_ret!=1)){
              fprintf(stderr,"write to accessAp: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
		  
          break;

        case RESERVE2:
          //size  = var_val_len;
         // value = * (long *) var_val;

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
		for(size=0;size<name_len;size++)
		{
		  printf("name[%d]%d\n",size,name[size]);
		}
		  nQc.ifIndex=name[name_len-1];
	          printf("nQc.ifIndex==%d\n",nQc.ifIndex);
		  if_indextoname(nQc.ifIndex,nQc.ifName);
		  memset(string,0,ACCESS_BUF);
		 sprintf(string,"%s %s %s %d","/usr/sbin/iwpriv",nQc.ifName,"wmm",long_ret);  
		  printf("string:%s\n",string);
		  system(string);
		   
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_QosBW(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    static   char string[ACCESS_BUF];
    static   char  value[ACCESS_BUF];
    static long  long_ret;
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to accessAp not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to accessAp: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
	      long_ret  =*((long *) var_val);
          break;

        case RESERVE2:

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
		  nQc.ifIndex=name[name_len-1];
	          printf("nQc.ifIndex==%d\n",nQc.ifIndex);
		  if_indextoname(nQc.ifIndex,nQc.ifName);
		 sprintf(string,"%s%s",nQc.ifName,"_QosBW");
		 sprintf(value,"%d",long_ret);
		 printf("string:%s,value:%s\n",string,value);
	 	 save_global_conf(SEP_EQUAL,SNMP_QOS_CONF,"",string,value);

          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_QoSResPercent(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    static   char string[ACCESS_BUF];
    static   char  value[ACCESS_BUF];
    static long  long_ret;
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to accessAp not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to accessAp: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
	      long_ret  =*((long *) var_val);
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
		  nQc.ifIndex=name[name_len-1];
	          printf("nQc.ifIndex==%d\n",nQc.ifIndex);
		  if_indextoname(nQc.ifIndex,nQc.ifName);
		 sprintf(string,"%s%s",nQc.ifName,"_QoSResPercent");
		 sprintf(value,"%d",long_ret);
		 printf("string:%s,value:%s\n",string,value);
	 	 save_global_conf(SEP_EQUAL,SNMP_QOS_CONF,"",string,value);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_QossharedBW(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    static   char  value[ACCESS_BUF];
    static   char  string[ACCESS_BUF];
    static long  long_ret;
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to accessAp not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to accessAp: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
	      long_ret  =*((long *) var_val);
          break;

        case RESERVE2:

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
		  nQc.ifIndex=name[name_len-1];
	          printf("nQc.ifIndex==%d\n",nQc.ifIndex);
		  if_indextoname(nQc.ifIndex,nQc.ifName);
		 sprintf(string,"%s%s",nQc.ifName,"_QossharedBW");
		 sprintf(value,"%d",long_ret);
		 printf("string:%s,value:%s\n",string,value);
	 	 save_global_conf(SEP_EQUAL,SNMP_QOS_CONF,"",string,value);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_QossharedBWPercent(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    static   char  value[ACCESS_BUF];
    static   char  string[ACCESS_BUF];
    static long  long_ret;
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to accessAp not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to accessAp: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
	      long_ret  =*((long *) var_val);
          break;

        case RESERVE2:

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
		  nQc.ifIndex=name[name_len-1];
	          printf("nQc.ifIndex==%d\n",nQc.ifIndex);
		  if_indextoname(nQc.ifIndex,nQc.ifName);
		 sprintf(string,"%s%s",nQc.ifName,"_QossharedBWPercent");
		 sprintf(value,"%d",long_ret);
		 printf("string:%s,value:%s\n",string,value);
	 	 save_global_conf(SEP_EQUAL,SNMP_QOS_CONF,"",string,value);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_SchedAlgName(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    static   char  value[ACCESS_BUF];
    static   char  string[ACCESS_BUF];
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to accessAp not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > 128*sizeof(char)) {
              fprintf(stderr,"write to accessAp: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
		  memset(value,0,ACCESS_BUF);
		  memset(string,0,ACCESS_BUF);
		  nQc.ifIndex=name[name_len-1];
	          printf("nQc.ifIndex==%d\n",nQc.ifIndex);
		  if_indextoname(nQc.ifIndex,nQc.ifName);
		  memcpy(value,var_val,var_val_len);
		  value[var_val_len]='\0';
 		 sprintf(string,"%s%s",nQc.ifName,"_SchedAlgName");
		 printf("string:%s,value:%s\n",string,value);
	 	 save_global_conf(SEP_EQUAL,SNMP_QOS_CONF,"",string,value);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_ResPolicyEnabled(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    static   char  value[ACCESS_BUF];
    static   char  string[ACCESS_BUF];
    static long  long_ret;
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to accessAp not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to accessAp: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
	      long_ret  =*((long *) var_val);
          break;

        case RESERVE2:

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
		  nQc.ifIndex=name[name_len-1];
	          printf("nQc.ifIndex==%d\n",nQc.ifIndex);
		  if_indextoname(nQc.ifIndex,nQc.ifName);
		 sprintf(string,"%s%s",nQc.ifName,"_ResPolicyEnabled");
		 sprintf(value,"%d",long_ret);
		 printf("string:%s,value:%s\n",string,value);
	 	 save_global_conf(SEP_EQUAL,SNMP_QOS_CONF,"",string,value);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_ResPolicyName(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    static   char  value[ACCESS_BUF];
    static   char  string[ACCESS_BUF];
    static long  long_ret;
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to accessAp not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len >128*sizeof(char)) {
              fprintf(stderr,"write to accessAp: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
		  memset(value,0,ACCESS_BUF);
		  memset(string,0,ACCESS_BUF);
		  nQc.ifIndex=name[name_len-1];
	          printf("nQc.ifIndex==%d\n",nQc.ifIndex);
		  if_indextoname(nQc.ifIndex,nQc.ifName);
		 sprintf(string,"%s%s",nQc.ifName,"_ResPolicyName");
		 sprintf(value,"%d",long_ret);
		 printf("string:%s,value:%s\n",string,value);
	 	 save_global_conf(SEP_EQUAL,SNMP_QOS_CONF,"",string,value);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_BackgroundSvcAvgSpeed(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    static   char  value[ACCESS_BUF];
    static   char  string[ACCESS_BUF];
    static long  long_ret;
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to accessAp not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to accessAp: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
	      long_ret  =*((long *) var_val);
          break;

        case RESERVE2:

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
		  memset(value,0,ACCESS_BUF);
		  memset(string,0,ACCESS_BUF);
		  nQc.ifIndex=name[name_len-1];
	          printf("nQc.ifIndex==%d\n",nQc.ifIndex);
		  if_indextoname(nQc.ifIndex,nQc.ifName);
		 sprintf(string,"%s%s",nQc.ifName,"_BackgroundSvcAvgSpeed");
		 sprintf(value,"%d",long_ret);
		 printf("string:%s,value:%s\n",string,value);
	 	 save_global_conf(SEP_EQUAL,SNMP_QOS_CONF,"",string,value);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_BackgroundSvcMaxBurst(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    static   char  value[ACCESS_BUF];
    static   char  string[ACCESS_BUF];
    static long  long_ret;
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to accessAp not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to accessAp: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
	      long_ret  =*((long *) var_val);
          break;

        case RESERVE2:

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
		  memset(value,0,ACCESS_BUF);
		  memset(string,0,ACCESS_BUF);
		  nQc.ifIndex=name[name_len-1];
	          printf("nQc.ifIndex==%d\n",nQc.ifIndex);
		  if_indextoname(nQc.ifIndex,nQc.ifName);
		 sprintf(string,"%s%s",nQc.ifName,"_BackgroundSvcMaxBurst");
		 sprintf(value,"%d",long_ret);
		 printf("string:%s,value:%s\n",string,value);
	 	 save_global_conf(SEP_EQUAL,SNMP_QOS_CONF,"",string,value);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_BackgroundSvcPriority(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    static   char  value[ACCESS_BUF];
    static   char  string[ACCESS_BUF];
    static long  long_ret;
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to accessAp not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to accessAp: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
	      long_ret  =*((long *) var_val);
          break;

        case RESERVE2:

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
		  memset(value,0,ACCESS_BUF);
		  memset(string,0,ACCESS_BUF);
		  nQc.ifIndex=name[name_len-1];
	          printf("nQc.ifIndex==%d\n",nQc.ifIndex);
		  if_indextoname(nQc.ifIndex,nQc.ifName);
 		 sprintf(string,"%s%s",nQc.ifName,"_BackgroundSvcPriority");
		 sprintf(value,"%d",long_ret);
		 printf("string:%s,value:%s\n",string,value);
	 	 save_global_conf(SEP_EQUAL,SNMP_QOS_CONF,"",string,value);
         break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_BackgroundSvcResPriority(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    static   char  value[ACCESS_BUF];
    static   char  string[ACCESS_BUF];
    static long  long_ret;
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to accessAp not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to accessAp: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
	      long_ret  =*((long *) var_val);
          break;

        case RESERVE2:

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
            	  nQc.ifIndex=name[name_len-1];
	          printf("nQc.ifIndex==%d\n",nQc.ifIndex);
		  if_indextoname(nQc.ifIndex,nQc.ifName);
		 sprintf(string,"%s%s",nQc.ifName,"_BackgroundSvcResPriority");
		 sprintf(value,"%d",long_ret);
		 printf("string:%s,value:%s\n",string,value);
	 	 save_global_conf(SEP_EQUAL,SNMP_QOS_CONF,"",string,value);

          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_BestEffortSvcAvgSpeed(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    static   char  value[ACCESS_BUF];
    static   char  string[ACCESS_BUF];
    static long  long_ret;
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to accessAp not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to accessAp: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
	      long_ret  =*((long *) var_val);
          break;

        case RESERVE2:

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
		  memset(value,0,ACCESS_BUF);
		  memset(string,0,ACCESS_BUF);
		  nQc.ifIndex=name[name_len-1];
	          printf("nQc.ifIndex==%d\n",nQc.ifIndex);
		  if_indextoname(nQc.ifIndex,nQc.ifName);
		 sprintf(string,"%s%s",nQc.ifName,"_BestEffortSvcAvgSpeed");
		 sprintf(value,"%d",long_ret);
		 printf("string:%s,value:%s\n",string,value);
	 	 save_global_conf(SEP_EQUAL,SNMP_QOS_CONF,"",string,value);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_BestEffortSvcMaxBurst(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    static   char  value[ACCESS_BUF];
    static   char  string[ACCESS_BUF];
    static long  long_ret;
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to accessAp not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to accessAp: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
	      long_ret  =*((long *) var_val);
          break;

        case RESERVE2:

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
		  memset(value,0,ACCESS_BUF);
		  memset(string,0,ACCESS_BUF);
		  nQc.ifIndex=name[name_len-1];
	          printf("nQc.ifIndex==%d\n",nQc.ifIndex);
		  if_indextoname(nQc.ifIndex,nQc.ifName);
  		 sprintf(string,"%s%s",nQc.ifName,"_BestEffortSvcMaxBurst");
		 sprintf(value,"%d",long_ret);
		 printf("string:%s,value:%s\n",string,value);
	 	 save_global_conf(SEP_EQUAL,SNMP_QOS_CONF,"",string,value);
        break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_BestEffortSvcPriority(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    static   char  value[ACCESS_BUF];
    static   char  string[ACCESS_BUF];
    static long  long_ret;
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to accessAp not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to accessAp: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
	      long_ret  =*((long *) var_val);
          break;

        case RESERVE2:

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
		  memset(value,0,ACCESS_BUF);
		  memset(string,0,ACCESS_BUF);
		  nQc.ifIndex=name[name_len-1];
	          printf("nQc.ifIndex==%d\n",nQc.ifIndex);
		  if_indextoname(nQc.ifIndex,nQc.ifName);
		 sprintf(string,"%s%s",nQc.ifName,"_BestEffortSvcPriority");
		 sprintf(value,"%d",long_ret);
		 printf("string:%s,value:%s\n",string,value);
	 	 save_global_conf(SEP_EQUAL,SNMP_QOS_CONF,"",string,value);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_BestEffortSvcResPriority(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    static   char  value[ACCESS_BUF];
    static   char  string[ACCESS_BUF];
    static long  long_ret;
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to accessAp not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to accessAp: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
	      long_ret  =*((long *) var_val);
          break;

        case RESERVE2:

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
		  memset(value,0,ACCESS_BUF);
		  memset(string,0,ACCESS_BUF);
		  nQc.ifIndex=name[name_len-1];
	          printf("nQc.ifIndex==%d\n",nQc.ifIndex);
		  if_indextoname(nQc.ifIndex,nQc.ifName);
		 sprintf(string,"%s%s",nQc.ifName,"_BestEffortSvcResPriority");
		 sprintf(value,"%d",long_ret);
		 printf("string:%s,value:%s\n",string,value);
	 	 save_global_conf(SEP_EQUAL,SNMP_QOS_CONF,"",string,value);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_VoiceSvcAvgSpeed(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    static   char  value[ACCESS_BUF];
    static   char  string[ACCESS_BUF];
    static long  long_ret;
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to accessAp not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to accessAp: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
	      long_ret  =*((long *) var_val);
          break;

        case RESERVE2:

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
		  memset(value,0,ACCESS_BUF);
		  memset(string,0,ACCESS_BUF);
		  nQc.ifIndex=name[name_len-1];
	          printf("nQc.ifIndex==%d\n",nQc.ifIndex);
		  if_indextoname(nQc.ifIndex,nQc.ifName);
		 sprintf(string,"%s%s",nQc.ifName,"_VoiceSvcAvgSpeed");
		 sprintf(value,"%d",long_ret);
		 printf("string:%s,value:%s\n",string,value);
	 	 save_global_conf(SEP_EQUAL,SNMP_QOS_CONF,"",string,value);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_VoiceSvcMaxBurst(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    static   char  value[ACCESS_BUF];
    static   char  string[ACCESS_BUF];
    static long  long_ret;
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to accessAp not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to accessAp: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
	      long_ret  =*((long *) var_val);
          break;

        case RESERVE2:

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
		  memset(value,0,ACCESS_BUF);
		  memset(string,0,ACCESS_BUF);
		  nQc.ifIndex=name[name_len-1];
	          printf("nQc.ifIndex==%d\n",nQc.ifIndex);
		  if_indextoname(nQc.ifIndex,nQc.ifName);
		 sprintf(string,"%s%s",nQc.ifName,"_VoiceSvcMaxBurst");
		 sprintf(value,"%d",long_ret);
		 printf("string:%s,value:%s\n",string,value);
	 	 save_global_conf(SEP_EQUAL,SNMP_QOS_CONF,"",string,value);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_VoiceSvcPriority(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    static   char  value[ACCESS_BUF];
    static   char  string[ACCESS_BUF];
    static long  long_ret;
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to accessAp not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to accessAp: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
	      long_ret  =*((long *) var_val);
          break;

        case RESERVE2:

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
		  memset(value,0,ACCESS_BUF);
		  memset(string,0,ACCESS_BUF);
		  nQc.ifIndex=name[name_len-1];
	          printf("nQc.ifIndex==%d\n",nQc.ifIndex);
		  if_indextoname(nQc.ifIndex,nQc.ifName);
		 sprintf(string,"%s%s",nQc.ifName,"_VoiceSvcPriority");
		 sprintf(value,"%d",long_ret);
		 printf("string:%s,value:%s\n",string,value);
	 	 save_global_conf(SEP_EQUAL,SNMP_QOS_CONF,"",string,value);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_VoiceSvcResPriority(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    static   char  value[ACCESS_BUF];
    static   char  string[ACCESS_BUF];
    static long  long_ret;
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to accessAp not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to accessAp: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
	      long_ret  =*((long *) var_val);
          break;

        case RESERVE2:

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
		  memset(value,0,ACCESS_BUF);
		  memset(string,0,ACCESS_BUF);
		  nQc.ifIndex=name[name_len-1];
	          printf("nQc.ifIndex==%d\n",nQc.ifIndex);
		  if_indextoname(nQc.ifIndex,nQc.ifName);
		 sprintf(string,"%s%s",nQc.ifName,"_VoiceSvcResPriority");
		 sprintf(value,"%d",long_ret);
		 printf("string:%s,value:%s\n",string,value);
	 	 save_global_conf(SEP_EQUAL,SNMP_QOS_CONF,"",string,value);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_VideoSvcAvgSpeed(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    static   char  value[ACCESS_BUF];
    static   char  string[ACCESS_BUF];
    static long  long_ret;
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to accessAp not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to accessAp: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
	      long_ret  =*((long *) var_val);
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
		  memset(value,0,ACCESS_BUF);
		  memset(string,0,ACCESS_BUF);
		  nQc.ifIndex=name[name_len-1];
	          printf("nQc.ifIndex==%d\n",nQc.ifIndex);
		  if_indextoname(nQc.ifIndex,nQc.ifName);
		 sprintf(string,"%s%s",nQc.ifName,"_VideoSvcAvgSpeed");
		 sprintf(value,"%d",long_ret);
		 printf("string:%s,value:%s\n",string,value);
	 	 save_global_conf(SEP_EQUAL,SNMP_QOS_CONF,"",string,value);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_VideoSvcMaxBurst(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    static   char  value[ACCESS_BUF];
    static   char  string[ACCESS_BUF];
    static long  long_ret;
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to accessAp not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to accessAp: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
	      long_ret  =*((long *) var_val);
          break;

        case RESERVE2:

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
		  memset(value,0,ACCESS_BUF);
		  memset(string,0,ACCESS_BUF);
		  nQc.ifIndex=name[name_len-1];
	          printf("nQc.ifIndex==%d\n",nQc.ifIndex);
		  if_indextoname(nQc.ifIndex,nQc.ifName);
		 sprintf(string,"%s%s",nQc.ifName,"_VideoSvcMaxBurst");
		 sprintf(value,"%d",long_ret);
		 printf("string:%s,value:%s\n",string,value);
	 	 save_global_conf(SEP_EQUAL,SNMP_QOS_CONF,"",string,value);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_VideoSvcPriority(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    static   char  value[ACCESS_BUF];
    static   char  string[ACCESS_BUF];
    static long  long_ret;
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to accessAp not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to accessAp: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
	      long_ret  =*((long *) var_val);
          break;

        case RESERVE2:

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
		  memset(value,0,ACCESS_BUF);
		  memset(string,0,ACCESS_BUF);
		  nQc.ifIndex=name[name_len-1];
	          printf("nQc.ifIndex==%d\n",nQc.ifIndex);
		  if_indextoname(nQc.ifIndex,nQc.ifName);
		 sprintf(string,"%s%s",nQc.ifName,"_VideoSvcPriority");
		 sprintf(value,"%d",long_ret);
		 printf("string:%s,value:%s\n",string,value);
	 	 save_global_conf(SEP_EQUAL,SNMP_QOS_CONF,"",string,value);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_VideoSvcResPriority(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    static   char  value[ACCESS_BUF];
    static   char  string[ACCESS_BUF];
    static long  long_ret;
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to accessAp not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to accessAp: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
	      long_ret  =*((long *) var_val);
          break;

        case RESERVE2:

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
		  memset(value,0,ACCESS_BUF);
		  memset(string,0,ACCESS_BUF);
		  nQs.ifIndex=name[name_len-1];
	          printf("nQs.ifIndex==%d\n",nQs.ifIndex);
		  if_indextoname(nQs.ifIndex,nQs.ifName);
		 sprintf(string,"%s%s",nQc.ifName,"_VideoSvcResPriority");
		 sprintf(value,"%d",long_ret);
		 printf("string:%s,value:%s\n",string,value);
	 	 save_global_conf(SEP_EQUAL,SNMP_QOS_CONF,"",string,value);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_BgMaxSvcCnt(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    static   char  value[ACCESS_BUF];
    static   char  string[ACCESS_BUF];
    static long  long_ret;
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to accessAp not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to accessAp: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
	      long_ret  =*((long *) var_val);
          break;

        case RESERVE2:

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
		  memset(value,0,ACCESS_BUF);
		  memset(string,0,ACCESS_BUF);
		  nQc.ifIndex=name[name_len-1];
	          printf("nQc.ifIndex==%d\n",nQc.ifIndex);
		  if_indextoname(nQc.ifIndex,nQc.ifName);
		 sprintf(string,"%s%s",nQc.ifName,"_BgMaxSvcCnt");
		 sprintf(value,"%d",long_ret);
		 printf("string:%s,value:%s\n",string,value);
	 	 save_global_conf(SEP_EQUAL,SNMP_QOS_CONF,"",string,value);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_BgSvcBW(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    static   char  value[ACCESS_BUF];
    static   char  string[ACCESS_BUF];
    static long  long_ret;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to accessAp not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to accessAp: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
	      long_ret  =*((long *) var_val);
          break;

        case RESERVE2:

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
		  memset(value,0,ACCESS_BUF);
		  memset(string,0,ACCESS_BUF);
		  nQc.ifIndex=name[name_len-1];
	          printf("nQc.ifIndex==%d\n",nQc.ifIndex);
		  if_indextoname(nQc.ifIndex,nQc.ifName);
		 sprintf(string,"%s%s",nQc.ifName,"_BgSvcBW");
		 sprintf(value,"%d",long_ret);
		 printf("string:%s,value:%s\n",string,value);
	 	 save_global_conf(SEP_EQUAL,SNMP_QOS_CONF,"",string,value);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_BgSvcBWPercent(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    static   char  value[ACCESS_BUF];
    static   char  string[ACCESS_BUF];
    static long  long_ret;
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to accessAp not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to accessAp: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
	      long_ret  =*((long *) var_val);
          break;

        case RESERVE2:

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
		  memset(value,0,ACCESS_BUF);
		  memset(string,0,ACCESS_BUF);
		  nQc.ifIndex=name[name_len-1];
	          printf("nQc.ifIndex==%d\n",nQc.ifIndex);
		  if_indextoname(nQc.ifIndex,nQc.ifName);
		 sprintf(string,"%s%s",nQc.ifName,"_BgSvcBWPercent");
		 sprintf(value,"%d",long_ret);
		 printf("string:%s,value:%s\n",string,value);
	 	 save_global_conf(SEP_EQUAL,SNMP_QOS_CONF,"",string,value);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_BgIsUseWREDAlg(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    static   char  value[ACCESS_BUF];
    static   char  string[ACCESS_BUF];
    static long  long_ret;
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to accessAp not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to accessAp: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
	      long_ret  =*((long *) var_val);
          break;

        case RESERVE2:

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
		  memset(value,0,ACCESS_BUF);
		  memset(string,0,ACCESS_BUF);
		  nQc.ifIndex=name[name_len-1];
	          printf("nQc.ifIndex==%d\n",nQc.ifIndex);
		  if_indextoname(nQc.ifIndex,nQc.ifName);
		 sprintf(string,"%s%s",nQc.ifName,"_BgIsUseWREDAlg");
		 sprintf(value,"%d",long_ret);
		 printf("string:%s,value:%s\n",string,value);
	 	 save_global_conf(SEP_EQUAL,SNMP_QOS_CONF,"",string,value);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_BgIsUseTrafficShaping(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    static   char  value[ACCESS_BUF];
    static   char  string[ACCESS_BUF];
    static long  long_ret;
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to accessAp not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to accessAp: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
	      long_ret  =*((long *) var_val);
          break;

        case RESERVE2:

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
		  memset(value,0,ACCESS_BUF);
		  memset(string,0,ACCESS_BUF);
		  nQc.ifIndex=name[name_len-1];
	          printf("nQc.ifIndex==%d\n",nQc.ifIndex);
		  if_indextoname(nQc.ifIndex,nQc.ifName);
		 sprintf(string,"%s%s",nQc.ifName,"_BgIsUseTrafficShaping");
		 sprintf(value,"%d",long_ret);
		 printf("string:%s,value:%s\n",string,value);
	 	 save_global_conf(SEP_EQUAL,SNMP_QOS_CONF,"",string,value);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_BeMaxSvcCnt(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    static   char  value[ACCESS_BUF];
    static   char  string[ACCESS_BUF];
    static long  long_ret;
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to accessAp not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to accessAp: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
	      long_ret  =*((long *) var_val);
          break;

        case RESERVE2:

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
		  memset(value,0,ACCESS_BUF);
		  memset(string,0,ACCESS_BUF);
		  nQc.ifIndex=name[name_len-1];
	          printf("nQc.ifIndex==%d\n",nQc.ifIndex);
		  if_indextoname(nQc.ifIndex,nQc.ifName);
		 sprintf(string,"%s%s",nQc.ifName,"_BeMaxSvcCnt");
		 sprintf(value,"%d",long_ret);
		 printf("string:%s,value:%s\n",string,value);
	 	 save_global_conf(SEP_EQUAL,SNMP_QOS_CONF,"",string,value);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_BeSvcBW(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    static   char  value[ACCESS_BUF];
    static   char  string[ACCESS_BUF];
    static long  long_ret;
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to accessAp not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to accessAp: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
	      long_ret  =*((long *) var_val);
          break;

        case RESERVE2:

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
		  memset(value,0,ACCESS_BUF);
		  memset(string,0,ACCESS_BUF);
		  nQc.ifIndex=name[name_len-1];
	          printf("nQc.ifIndex==%d\n",nQc.ifIndex);
		  if_indextoname(nQc.ifIndex,nQc.ifName);
		 sprintf(string,"%s%s",nQc.ifName,"_BeSvcBW");
		 sprintf(value,"%d",long_ret);
		 printf("string:%s,value:%s\n",string,value);
	 	 save_global_conf(SEP_EQUAL,SNMP_QOS_CONF,"",string,value);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_BeSvcBWPercent(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    static   char  value[ACCESS_BUF];
    static   char  string[ACCESS_BUF];
    static long  long_ret;
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to accessAp not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to accessAp: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
	      long_ret  =*((long *) var_val);
          break;

        case RESERVE2:

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
		  memset(value,0,ACCESS_BUF);
		  memset(string,0,ACCESS_BUF);
		  nQc.ifIndex=name[name_len-1];
	          printf("nQc.ifIndex==%d\n",nQc.ifIndex);
		  if_indextoname(nQc.ifIndex,nQc.ifName);
		 sprintf(string,"%s%s",nQc.ifName,"_BeSvcBWPercent");
		 sprintf(value,"%d",long_ret);
		 printf("string:%s,value:%s\n",string,value);
	 	 save_global_conf(SEP_EQUAL,SNMP_QOS_CONF,"",string,value);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_BeIsUseWREDAlg(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    static   char  value[ACCESS_BUF];
    static   char  string[ACCESS_BUF];
    static long  long_ret;
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to accessAp not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to accessAp: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
	      long_ret  =*((long *) var_val);
          break;

        case RESERVE2:

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
		  memset(value,0,ACCESS_BUF);
		  memset(string,0,ACCESS_BUF);
		  nQc.ifIndex=name[name_len-1];
	          printf("nQc.ifIndex==%d\n",nQc.ifIndex);
		  if_indextoname(nQc.ifIndex,nQc.ifName);
		 sprintf(string,"%s%s",nQc.ifName,"_BeIsUseWREDAlg");
		 sprintf(value,"%d",long_ret);
		 printf("string:%s,value:%s\n",string,value);
	 	 save_global_conf(SEP_EQUAL,SNMP_QOS_CONF,"",string,value);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_BeIsUseTrafficShaping(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    static   char  value[ACCESS_BUF];
    static   char  string[ACCESS_BUF];
    static long  long_ret;
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to accessAp not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to accessAp: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
	      long_ret  =*((long *) var_val);
          break;

        case RESERVE2:

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
		  memset(value,0,ACCESS_BUF);
		  memset(string,0,ACCESS_BUF);
		  nQc.ifIndex=name[name_len-1];
	          printf("nQc.ifIndex==%d\n",nQc.ifIndex);
		  if_indextoname(nQc.ifIndex,nQc.ifName);
		 sprintf(string,"%s%s",nQc.ifName,"_BeIsUseTrafficShaping");
		 sprintf(value,"%d",long_ret);
		 printf("string:%s,value:%s\n",string,value);
	 	 save_global_conf(SEP_EQUAL,SNMP_QOS_CONF,"",string,value);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_VoiceMaxSvcCnt(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    static   char  value[ACCESS_BUF];
    static   char  string[ACCESS_BUF];
    static long  long_ret;
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to accessAp not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to accessAp: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
	      long_ret  =*((long *) var_val);
          break;

        case RESERVE2:

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
		  memset(value,0,ACCESS_BUF);
		  memset(string,0,ACCESS_BUF);
		  nQc.ifIndex=name[name_len-1];
	          printf("nQc.ifIndex==%d\n",nQc.ifIndex);
		  if_indextoname(nQc.ifIndex,nQc.ifName);
 		 sprintf(string,"%s%s",nQc.ifName,"_VoiceMaxSvcCnt");
		 sprintf(value,"%d",long_ret);
		 printf("string:%s,value:%s\n",string,value);
	 	 save_global_conf(SEP_EQUAL,SNMP_QOS_CONF,"",string,value);
         break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_VoiceSvcBW(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    static   char  value[ACCESS_BUF];
    static   char  string[ACCESS_BUF];
    static long  long_ret;
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to accessAp not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to accessAp: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
	      long_ret  =*((long *) var_val);
          break;

        case RESERVE2:

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
		  memset(value,0,ACCESS_BUF);
		  memset(string,0,ACCESS_BUF);
		  nQc.ifIndex=name[name_len-1];
	          printf("nQc.ifIndex==%d\n",nQc.ifIndex);
		  if_indextoname(nQc.ifIndex,nQc.ifName);
		 sprintf(string,"%s%s",nQc.ifName,"_VoiceSvcBW");
		 sprintf(value,"%d",long_ret);
		 printf("string:%s,value:%s\n",string,value);
	 	 save_global_conf(SEP_EQUAL,SNMP_QOS_CONF,"",string,value);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_VoiceSvcBWPercent(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    static   char  value[ACCESS_BUF];
    static   char  string[ACCESS_BUF];
    static long  long_ret;
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to accessAp not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to accessAp: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
	      long_ret  =*((long *) var_val);
          break;

        case RESERVE2:

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
		  memset(value,0,ACCESS_BUF);
		  memset(string,0,ACCESS_BUF);
		  nQc.ifIndex=name[name_len-1];
	          printf("nQc.ifIndex==%d\n",nQc.ifIndex);
		  if_indextoname(nQc.ifIndex,nQc.ifName);
		 sprintf(string,"%s%s",nQc.ifName,"_VoiceSvcBWPercent");
		 sprintf(value,"%d",long_ret);
		 printf("string:%s,value:%s\n",string,value);
	 	 save_global_conf(SEP_EQUAL,SNMP_QOS_CONF,"",string,value);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_VoiceIsUseStreamBasedQueue(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    static   char  value[ACCESS_BUF];
    static   char  string[ACCESS_BUF];
    static long  long_ret;
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to accessAp not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to accessAp: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
	      long_ret  =*((long *) var_val);
          break;

        case RESERVE2:

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
		  memset(value,0,ACCESS_BUF);
		  memset(string,0,ACCESS_BUF);
		  nQc.ifIndex=name[name_len-1];
	          printf("nQc.ifIndex==%d\n",nQc.ifIndex);
		  if_indextoname(nQc.ifIndex,nQc.ifName);
		 sprintf(string,"%s%s",nQc.ifName,"_VoiceIsUseStreamBasedQueue");
		 sprintf(value,"%d",long_ret);
		 printf("string:%s,value:%s\n",string,value);
	 	 save_global_conf(SEP_EQUAL,SNMP_QOS_CONF,"",string,value);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_VoiceStreamMaxQueueLen(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    static   char  value[ACCESS_BUF];
    static   char  string[ACCESS_BUF];
    static long  long_ret;
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to accessAp not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to accessAp: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
	      long_ret  =*((long *) var_val);
          break;

        case RESERVE2:

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
		  memset(value,0,ACCESS_BUF);
		  memset(string,0,ACCESS_BUF);
		  nQc.ifIndex=name[name_len-1];
	          printf("nQc.ifIndex==%d\n",nQc.ifIndex);
		  if_indextoname(nQc.ifIndex,nQc.ifName);
 		 sprintf(string,"%s%s",nQc.ifName,"_VoiceStreamMaxQueueLen");
		 sprintf(value,"%d",long_ret);
		 printf("string:%s,value:%s\n",string,value);
	 	 save_global_conf(SEP_EQUAL,SNMP_QOS_CONF,"",string,value);
         break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_VoiceStreamAvgSpeed(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    static   char  value[ACCESS_BUF];
    static   char  string[ACCESS_BUF];
    static long  long_ret;
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to accessAp not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to accessAp: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
	      long_ret  =*((long *) var_val);
          break;

        case RESERVE2:

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
		  memset(value,0,ACCESS_BUF);
		  memset(string,0,ACCESS_BUF);
		  nQc.ifIndex=name[name_len-1];
	          printf("nQc.ifIndex==%d\n",nQc.ifIndex);
		  if_indextoname(nQc.ifIndex,nQc.ifName);
		 sprintf(string,"%s%s",nQc.ifName,"_VoiceStreamAvgSpeed");
		 sprintf(value,"%d",long_ret);
		 printf("string:%s,value:%s\n",string,value);
	 	 save_global_conf(SEP_EQUAL,SNMP_QOS_CONF,"",string,value);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_VoiceStreamMaxBurst(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    static   char  value[ACCESS_BUF];
    static   char  string[ACCESS_BUF];
    static long  long_ret;
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to accessAp not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to accessAp: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
	      long_ret  =*((long *) var_val);
          break;

        case RESERVE2:

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
		  memset(value,0,ACCESS_BUF);
		  memset(string,0,ACCESS_BUF);
		  nQc.ifIndex=name[name_len-1];
	          printf("nQc.ifIndex==%d\n",nQc.ifIndex);
		  if_indextoname(nQc.ifIndex,nQc.ifName);
		 sprintf(string,"%s%s",nQc.ifName,"_VoiceStreamMaxBurst");
		 sprintf(value,"%d",long_ret);
		 printf("string:%s,value:%s\n",string,value);
	 	 save_global_conf(SEP_EQUAL,SNMP_QOS_CONF,"",string,value);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_VoiceIsUseWREDAlg(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    static   char  value[ACCESS_BUF];
    static   char  string[ACCESS_BUF];
    static long  long_ret;
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to accessAp not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to accessAp: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
	      long_ret  =*((long *) var_val);
          break;

        case RESERVE2:

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
		  memset(value,0,ACCESS_BUF);
		  memset(string,0,ACCESS_BUF);
		  nQc.ifIndex=name[name_len-1];
	          printf("nQc.ifIndex==%d\n",nQc.ifIndex);
		  if_indextoname(nQc.ifIndex,nQc.ifName);
		 sprintf(string,"%s%s",nQc.ifName,"_VoiceIsUseWREDAlg");
		 sprintf(value,"%d",long_ret);
		 printf("string:%s,value:%s\n",string,value);
	 	 save_global_conf(SEP_EQUAL,SNMP_QOS_CONF,"",string,value);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_VoiceIsUseTrafficShaping(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    static   char  value[ACCESS_BUF];
    static   char  string[ACCESS_BUF];
    static long  long_ret;
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to accessAp not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to accessAp: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
	      long_ret  =*((long *) var_val);
          break;

        case RESERVE2:

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
		  memset(value,0,ACCESS_BUF);
		  memset(string,0,ACCESS_BUF);
		  nQc.ifIndex=name[name_len-1];
	          printf("nQc.ifIndex==%d\n",nQc.ifIndex);
		  if_indextoname(nQc.ifIndex,nQc.ifName);
		 sprintf(string,"%s%s",nQc.ifName,"_VoiceIsUseTrafficShaping");
		 sprintf(value,"%d",long_ret);
		 printf("string:%s,value:%s\n",string,value);
	 	 save_global_conf(SEP_EQUAL,SNMP_QOS_CONF,"",string,value);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_VideoMaxSvcCnt(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    static   char  value[ACCESS_BUF];
    static   char  string[ACCESS_BUF];
    static long  long_ret;
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to accessAp not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to accessAp: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
	      long_ret  =*((long *) var_val);
          break;

        case RESERVE2:

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
		  memset(value,0,ACCESS_BUF);
		  memset(string,0,ACCESS_BUF);
		  nQc.ifIndex=name[name_len-1];
	          printf("nQc.ifIndex==%d\n",nQc.ifIndex);
		  if_indextoname(nQc.ifIndex,nQc.ifName);
		 sprintf(string,"%s%s",nQc.ifName,"_VideoMaxSvcCnt");
		 sprintf(value,"%d",long_ret);
		 printf("string:%s,value:%s\n",string,value);
	 	 save_global_conf(SEP_EQUAL,SNMP_QOS_CONF,"",string,value);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_VideoeSvcBW(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    static   char  value[ACCESS_BUF];
    static   char  string[ACCESS_BUF];
    static long  long_ret;
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to accessAp not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to accessAp: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
	      long_ret  =*((long *) var_val);
          break;

        case RESERVE2:

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
		  memset(value,0,ACCESS_BUF);
		  memset(string,0,ACCESS_BUF);
		  nQc.ifIndex=name[name_len-1];
	          printf("nQc.ifIndex==%d\n",nQc.ifIndex);
		  if_indextoname(nQc.ifIndex,nQc.ifName);
		 sprintf(string,"%s%s",nQc.ifName,"_VideoeSvcBW");
		 sprintf(value,"%d",long_ret);
		 printf("string:%s,value:%s\n",string,value);
	 	 save_global_conf(SEP_EQUAL,SNMP_QOS_CONF,"",string,value);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_VideoSvcBWPercent(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    static   char  value[ACCESS_BUF];
    static   char  string[ACCESS_BUF];
    static long  long_ret;
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to accessAp not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to accessAp: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
	      long_ret  =*((long *) var_val);
          break;

        case RESERVE2:

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
		  memset(value,0,ACCESS_BUF);
		  memset(string,0,ACCESS_BUF);
		  nQc.ifIndex=name[name_len-1];
	          printf("nQc.ifIndex==%d\n",nQc.ifIndex);
		  if_indextoname(nQc.ifIndex,nQc.ifName);
		 sprintf(string,"%s%s",nQc.ifName,"_VideoSvcBWPercent");
		 sprintf(value,"%d",long_ret);
		 printf("string:%s,value:%s\n",string,value);
	 	 save_global_conf(SEP_EQUAL,SNMP_QOS_CONF,"",string,value);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_VideoIsUseStreamBasedQueue(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    static   char  value[ACCESS_BUF];
    static   char  string[ACCESS_BUF];
    static long  long_ret;
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to accessAp not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to accessAp: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
	      long_ret  =*((long *) var_val);
          break;

        case RESERVE2:

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
		  memset(value,0,ACCESS_BUF);
		  memset(string,0,ACCESS_BUF);
		  nQc.ifIndex=name[name_len-1];
	          printf("nQc.ifIndex==%d\n",nQc.ifIndex);
		  if_indextoname(nQc.ifIndex,nQc.ifName);
		 sprintf(string,"%s%s",nQc.ifName,"_VideoIsUseStreamBasedQueue");
		 sprintf(value,"%d",long_ret);
		 printf("string:%s,value:%s\n",string,value);
	 	 save_global_conf(SEP_EQUAL,SNMP_QOS_CONF,"",string,value);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_VideoStreamMaxQueueLen(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    static   char  value[ACCESS_BUF];
    static   char  string[ACCESS_BUF];
    static long  long_ret;
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to accessAp not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to accessAp: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
	      long_ret  =*((long *) var_val);
          break;

        case RESERVE2:

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
		  memset(value,0,ACCESS_BUF);
		  memset(string,0,ACCESS_BUF);
		  nQc.ifIndex=name[name_len-1];
	          printf("nQc.ifIndex==%d\n",nQc.ifIndex);
		  if_indextoname(nQc.ifIndex,nQc.ifName);
		 sprintf(string,"%s%s",nQc.ifName,"_VideoStreamMaxQueueLen");
		 sprintf(value,"%d",long_ret);
		 printf("string:%s,value:%s\n",string,value);
	 	 save_global_conf(SEP_EQUAL,SNMP_QOS_CONF,"",string,value);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_VideoStreamAvgSpeed(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    static   char  value[ACCESS_BUF];
    static   char  string[ACCESS_BUF];
    static long  long_ret;
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to accessAp not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to accessAp: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
	      long_ret  =*((long *) var_val);
          break;

        case RESERVE2:

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
		  memset(value,0,ACCESS_BUF);
		  memset(string,0,ACCESS_BUF);
		  nQc.ifIndex=name[name_len-1];
	          printf("nQc.ifIndex==%d\n",nQc.ifIndex);
		  if_indextoname(nQc.ifIndex,nQc.ifName);
		 sprintf(string,"%s%s",nQc.ifName,"_VideoStreamAvgSpeed");
		 sprintf(value,"%d",long_ret);
		 printf("string:%s,value:%s\n",string,value);
	 	 save_global_conf(SEP_EQUAL,SNMP_QOS_CONF,"",string,value);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_VideoStreamMaxBurst(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    static   char  value[ACCESS_BUF];
    static   char  string[ACCESS_BUF];
    static long  long_ret;
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to accessAp not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to accessAp: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
	      long_ret  =*((long *) var_val);
          break;

        case RESERVE2:

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
		  memset(value,0,ACCESS_BUF);
		  memset(string,0,ACCESS_BUF);
		  nQc.ifIndex=name[name_len-1];
	          printf("nQc.ifIndex==%d\n",nQc.ifIndex);
		  if_indextoname(nQc.ifIndex,nQc.ifName);
		 sprintf(string,"%s%s",nQc.ifName,"_VideoStreamMaxBurst");
		 sprintf(value,"%d",long_ret);
		 printf("string:%s,value:%s\n",string,value);
	 	 save_global_conf(SEP_EQUAL,SNMP_QOS_CONF,"",string,value);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_VideoIsUseWREDAlg(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    static   char  value[ACCESS_BUF];
    static   char  string[ACCESS_BUF];
    static long  long_ret;
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to accessAp not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to accessAp: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
	      long_ret  =*((long *) var_val);
          break;

        case RESERVE2:

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
		  memset(value,0,ACCESS_BUF);
		  memset(string,0,ACCESS_BUF);
		  nQc.ifIndex=name[name_len-1];
	          printf("nQc.ifIndex==%d\n",nQc.ifIndex);
		  if_indextoname(nQc.ifIndex,nQc.ifName);
		 sprintf(string,"%s%s",nQc.ifName,"_VideoIsUseWREDAlg");
		 sprintf(value,"%d",long_ret);
		 printf("string:%s,value:%s\n",string,value);
	 	 save_global_conf(SEP_EQUAL,SNMP_QOS_CONF,"",string,value);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_VideoIsUseTrafficShaping(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    static   char  value[ACCESS_BUF];
    static   char  string[ACCESS_BUF];
    static long  long_ret;
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to accessAp not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to accessAp: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
	      long_ret  =*((long *) var_val);
          break;

        case RESERVE2:

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
		  memset(value,0,ACCESS_BUF);
		  memset(string,0,ACCESS_BUF);
		  nQc.ifIndex=name[name_len-1];
	          printf("nQc.ifIndex==%d\n",nQc.ifIndex);
		  if_indextoname(nQc.ifIndex,nQc.ifName);
		 sprintf(string,"%s%s",nQc.ifName,"__VideoIsUseTrafficShaping");
		 sprintf(value,"%d",long_ret);
		 printf("string:%s,value:%s\n",string,value);
	 	 save_global_conf(SEP_EQUAL,SNMP_QOS_CONF,"",string,value);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}

static void load_Tables()
{
  int skfd;                               // generic raw socket desc
  struct iwreq wrq;                       // ioctl request structure
  struct ifreq ifr;
  struct timeval et;                      // elapsed time
  struct wireless_info info;              // workarea for wireless ioctl information
  FILE *fp;
  char  bfr[1024], ifName[1024];
  char *s, *t;

  gettimeofday ( &et, ( struct timezone * ) 0 );  // get time-of-day
  if ( et.tv_sec < lastLoad + MINLOADFREQ )       // only reload so often
    return;
  lastLoad = et.tv_sec;

  skfd = open_Socket();                            // open socket
  if ( skfd < 0 ) {
    syslog ( LOG_ERR, "SNMP ieee802dot11.loadTables() - %s\n", "socket open failure" );
    return;
  }

  flush_Lists();

  // find interfaces in /proc/net/dev and find the wireless interfaces
  fp = fopen ( PROC_NET_DEV, "r" );
  if ( fp ) {
    while ( fgets ( bfr, sizeof ( bfr ), fp )) {
      if ( strstr ( bfr, ":" )) {
        s = bfr; t = ifName;
        while ( isspace ( *s ))                     // discard white space
          *s++;
        while ( *s != ':' )                         // get interface name
          *t++ = *s++;
        *t = '\0';

        // verify as a wireless device
        memset (( char * ) &info, 0, sizeof ( struct wireless_info ));
		
        strncpy ( wrq.ifr_name, ifName, IFNAMSIZ );
		
        if ( ioctl ( skfd, SIOCGIWNAME, &wrq ) >= 0 ) {
          init_Structs();
          load_WiExt( skfd, ifName, &info );
          load_80211Structs ( skfd, ifName, &info );
        }
      }
    }
    fclose ( fp );
  }

  close ( skfd );
}




/****************************************************************************
*                                                                           *
*              load80211Structs() - load the 802.11 structures              *
*                                                                           *
****************************************************************************/
static void 
load_80211Structs ( int skfd, char *ifName, struct wireless_info *wi )
{
  int rc, ifIndex = 0;
  struct ifreq ifr;
  char  MACAddress [ MACADDR_LEN + 1 ];

  strcpy ( ifr.ifr_name, ifName );
  rc = ioctl ( skfd, SIOCGIFHWADDR, &ifr );
  if ( rc >= 0 ) {

    sprintf ( MACAddress, "%02X:%02X:%02X:%02X:%02X:%02X\0", 
                 ( UCHAR ) ifr.ifr_hwaddr.sa_data[0], ( UCHAR ) ifr.ifr_hwaddr.sa_data[1], 
                 ( UCHAR ) ifr.ifr_hwaddr.sa_data[2], ( UCHAR ) ifr.ifr_hwaddr.sa_data[3], 
                 ( UCHAR ) ifr.ifr_hwaddr.sa_data[4], ( UCHAR ) ifr.ifr_hwaddr.sa_data[5] );

    nSc.haveStationID = TRUE;
    strcpy  ( nSc.stationID, MACAddress );
    nOp.haveMACAddress = TRUE;
    strcpy  ( nOp.MACAddress, MACAddress );
    nRi.haveManufacturerOUI = TRUE;
    strncpy ( nRi.manufacturerOUI, MACAddress, MAN_OUI_LEN ); 

    ifIndex = if_nametoindex ( ifName );
    if ( !ifIndex ) {
      syslog ( LOG_ERR, "SNMP %s - %s %s\n", 
        "ieee802dot11.load80211Structs()", ifName, "has no ifIndex" );
      return;
    }

    load_WiExtTo80211Structs ( ifIndex, ifName, wi );

 
     if ( has_Changed (( char * ) &nCf, sizeof ( nCf ))) {
      nCf.ifIndex = ifIndex;
      sprintf ( nCf.UID, "%04d\0", nCf.ifIndex );
      strcpy ( nCf.ifName, ifName );
      add_List (( char * ) &cfList, ( char * ) &nCf, sizeof ( nCf ));
	  }

         if ( has_Changed (( char * ) &nQs, sizeof ( nQs ))) {
      nQs.ifIndex = ifIndex;
      sprintf ( nQs.UID, "%04d\0", nQs.ifIndex );
      strcpy ( nQs.ifName, ifName );
      add_List (( char * ) &qsList, ( char * ) &nQs, sizeof ( nQs ));
	  }

		 
     if ( has_Changed (( char * ) &nQc, sizeof ( nQc ))) {
      nQc.ifIndex = ifIndex;
      sprintf ( nQc.UID, "%04d\0", nQc.ifIndex );
      strcpy ( nQc.ifName, ifName );
      add_List (( char * ) &qcList, ( char * ) &nQc, sizeof ( nQc ));
	  }


  }

}



static void init_Structs()
{
  int i;

  memset (( char * ) &nLf, 0, sizeof ( nLf ));
  memset (( char * ) &nCf, 0, sizeof ( nCf ));
  memset (( char * ) &nQs, 0, sizeof ( nQs ));
  memset (( char * ) &nQc, 0, sizeof ( nQc ));

  // Wireless Extensions
  wepCurrentKey = 0;
  haveWepCurrentKey = FALSE;
  for ( i = 0; i < MAX_WEP_KEYS; i++ ) {
    wep[i].len = 0;
    wep[i].key[0] = '\0';
    wep[i].haveKey = FALSE;
  }
}




/****************************************************************************
*                                                                           *
*                Wireless Extensions Specific Functions                     *
*                                                                           *
****************************************************************************/
/****************************************************************************
*                                                                           *
* loadWiExtTo80211Structs() - load wireless extensions to 802.11 structures *
*                                                                           *
****************************************************************************/
static void 
load_WiExtTo80211Structs ( int ifIndex, char *ifName, struct wireless_info *wi )
{

   int i, j = 0;
   char if_num[10]={0};
   char str_mac_n[10]={0};
   
    prop_data properties[255];
    int prop_count=0;
    int prop_numb=0;
    char  string[ACCESS_BUF];
    char  value [ACCESS_BUF];
    char  param[ACCESS_BUF];
    char  buffer[ACCESS_BUF];
    char  strBuf[ACCESS_BUF];
    char  strcmd[ACCESS_STR];
    FILE  *fp;

    strcpy(nQs.ifName,ifName);
    strcpy(nQc.ifName,ifName);

if ( wi->has_range ) 
{
   for ( i = 1; i <=5; i++ )
	  {
		 nLf.ifIndex = ifIndex;
		 strcpy(nLf.ifName,ifName);
		 nLf.apListFilterMacIndex= i ;
		 memset (str_mac_n, 0, sizeof(str_mac_n));
		 sprintf(str_mac_n,"%s%d","mac",i);
		 memset (nLf.apListFilterMacValue, 0, sizeof(nLf.apListFilterMacValue));
		 wireless_sec_get_macfilter(get_vnum_by_vname( nLf.ifName ), str_mac_n, nLf.apListFilterMacValue,30 );
		 if(strcmp(nLf.apListFilterMacValue,"")!=NULL)
		 {nLf.haveApListFilterMacValue = TRUE;
		 sprintf ( nLf.UID, "%04d%04d\0", nLf.ifIndex, nLf.apListFilterMacIndex );
		 strcpy ( nLf.ifName, ifName );
		 add_List (( char * ) &lfList, ( char * ) &nLf, sizeof ( nLf ));}
		 else
		 	nLf.haveApListFilterMacValue = FALSE;
	  }
}

if ( wi->has_range ) 
{
   for ( i = 6; i <=10; i++ )
	  {
		 nLf.ifIndex = ifIndex;
		 strcpy(nLf.ifName,ifName);
		 nLf.apListFilterMacIndex= i ;
		 memset (str_mac_n, 0, sizeof(str_mac_n));
		 sprintf(str_mac_n,"%s%d","mac",i);
		 memset (nLf.apListFilterMacValue, 0, sizeof(nLf.apListFilterMacValue));
		 wireless_sec_get_macfilter(get_vnum_by_vname( nLf.ifName ), str_mac_n, nLf.apListFilterMacValue,30 );
		 if(strcmp(nLf.apListFilterMacValue,"")!=NULL)
		 {nLf.haveApListFilterMacValue = TRUE;
		 sprintf ( nLf.UID, "%04d%04d\0", nLf.ifIndex, nLf.apListFilterMacIndex );
		 strcpy ( nLf.ifName, ifName );
		 add_List (( char * ) &lfList, ( char * ) &nLf, sizeof ( nLf ));}
		 else
		 	nLf.haveApListFilterMacValue = FALSE;
	  }
}

if ( wi->has_range ) 
{
   for ( i = 11; i <=15; i++ )
	  {
		 nLf.ifIndex = ifIndex;
		 strcpy(nLf.ifName,ifName);
		 nLf.apListFilterMacIndex= i ;
		 memset (str_mac_n, 0, sizeof(str_mac_n));
		 sprintf(str_mac_n,"%s%d","mac",i);
		 memset (nLf.apListFilterMacValue, 0, sizeof(nLf.apListFilterMacValue));
		 wireless_sec_get_macfilter(get_vnum_by_vname( nLf.ifName ), str_mac_n, nLf.apListFilterMacValue,30 );
		 if(strcmp(nLf.apListFilterMacValue,"")!=NULL)
		 {nLf.haveApListFilterMacValue = TRUE;
		 sprintf ( nLf.UID, "%04d%04d\0", nLf.ifIndex, nLf.apListFilterMacIndex );
		 strcpy ( nLf.ifName, ifName );
		 add_List (( char * ) &lfList, ( char * ) &nLf, sizeof ( nLf ));}
		 else
		 	nLf.haveApListFilterMacValue = FALSE;
	  }
}



if ( wi->has_range ) 
{
   for ( i = 16; i <=20; i++ )
	  {
		 nLf.ifIndex = ifIndex;
		 strcpy(nLf.ifName,ifName);
		 nLf.apListFilterMacIndex= i ;
		 memset (str_mac_n, 0, sizeof(str_mac_n));
		 sprintf(str_mac_n,"%s%d","mac",i);
		 memset (nLf.apListFilterMacValue, 0, sizeof(nLf.apListFilterMacValue));
		 wireless_sec_get_macfilter(get_vnum_by_vname( nLf.ifName ), str_mac_n, nLf.apListFilterMacValue,30 );
		 if(strcmp(nLf.apListFilterMacValue,"")!=NULL)
		 {nLf.haveApListFilterMacValue = TRUE;
		 sprintf ( nLf.UID, "%04d%04d\0", nLf.ifIndex, nLf.apListFilterMacIndex );
		 strcpy ( nLf.ifName, ifName );
		 add_List (( char * ) &lfList, ( char * ) &nLf, sizeof ( nLf ));}
		 else
		 	nLf.haveApListFilterMacValue = FALSE;
	  }
}

/****************************************************************************
*                          apConfigFilterMacTable                            *
****************************************************************************/
nCf.haveApUseFilterMacValue = TRUE;
memset (nCf.apUseFilterMacValue, 0, sizeof( nCf.apUseFilterMacValue));
wireless_get_macfilter( get_vnum_by_vname( nCf.ifName ),nCf.apUseFilterMacValue, 30);
if(strcmp(nCf.apUseFilterMacValue,"")==NULL)
 nCf.haveApUseFilterMacValue =FALSE;


nCf.haveApModeFilterMacValue = TRUE;
memset (nCf.apModeFilterMacValue, 0, sizeof( nCf.apModeFilterMacValue));
wireless_get_macfiltermode( get_vnum_by_vname(nCf.ifName ),nCf.apModeFilterMacValue, 30);
if(strcmp(nCf.apModeFilterMacValue,"")==NULL)
nCf.haveApModeFilterMacValue =FALSE;


nCf.haveApAddFilterMacValue = TRUE;
memset (nCf.apAddFilterMacValue, 0, sizeof( nCf.apAddFilterMacValue));
strcpy(nCf.apAddFilterMacValue,"add a mac");

nCf.haveApDelFilterMacValue = TRUE;
memset (nCf.apDelFilterMacValue, 0, sizeof( nCf.apDelFilterMacValue));
strcpy(nCf.apDelFilterMacValue,"del a mac");





if ( wi->has_range ) 
{

   nQs.haveQosTrafficClass= TRUE;
	    {
		    memset(string,0, ACCESS_BUF);
		    memset(value, 0, ACCESS_BUF);
		    sprintf(string,"%s%s",nQs.ifName,"_TRAFFIC_CLASS");
		    prop_count=load_prop(SEP_EQUAL,SNMP_QOS_CONF,properties);
		    get_prop(string,value,properties,prop_count);
		    free_prop(properties,prop_count) ;
		    nQs.QosTrafficClass =atoi(value);// 0:ap  1:station
	    }

      nQs.haveQosChooseApStation= TRUE;
	    {
		    memset(string,0, ACCESS_BUF);
		    memset(value, 0, ACCESS_BUF);
		    sprintf(string,"%s%s",nQs.ifName,"_AP_STAT");
		    prop_count=load_prop(SEP_EQUAL,SNMP_QOS_CONF,properties);
		    get_prop(string,value,properties,prop_count);
		    free_prop(properties,prop_count) ;
		    nQs.QosChooseApStation =atoi(value);// 0:ap  1:station
	    }

		
	nQs.haveQosAIFS= TRUE;
	    {
		    memset(string,0, ACCESS_BUF);
		    memset(value, 0, ACCESS_BUF);
		    memset(param,0, ACCESS_BUF);
		    memset(buffer, 0, ACCESS_BUF);
		    memset(strcmd,0, ACCESS_STR);
		    sprintf(string,"%s%s",nQs.ifName,"_TRAFFIC_CLASS");
		    prop_count=load_prop(SEP_EQUAL,SNMP_QOS_CONF,properties);
		    get_prop(string,value,properties,prop_count);
		    free_prop(properties,prop_count) ;
			
		    sprintf(param,"%s%s",nQs.ifName,"_AP_STAT");
		    prop_numb=load_prop(SEP_EQUAL,SNMP_QOS_CONF,properties);
		    get_prop(param,buffer,properties,prop_numb);
		    free_prop(properties,prop_numb) ;
			
		    printf("value:%s,string:%s\n",value,buffer);
		     sprintf(strcmd,"%s %s %s  %s %s  %s","/usr/sbin/iwpriv",nQs.ifName,"get_aifs",value,buffer,"|awk  -F \":\" '{print $NF}'");
		     printf("strcmd:%s\n",strcmd);
            	     fp = popen(strcmd, "r");
		      if(fp){  
		  	      memset( strBuf, 0, ACCESS_BUF);
	  	             fgets(strBuf,sizeof(strBuf),fp);
		             strBuf[strlen(strBuf)-1] = '\0';
			      pclose(fp);
			     nQs.QosAIFS=atoi(strBuf);
	               }
	    }

	
	
	nQs.haveQosCWmin= TRUE;
	    {
		    memset(string,0,ACCESS_BUF);
		    memset(value,0,ACCESS_BUF);
		    memset(param,0,ACCESS_BUF);
		    memset(buffer,0,ACCESS_BUF);
		    memset(strcmd,0, ACCESS_STR);
		    sprintf(string,"%s%s",nQs.ifName,"_TRAFFIC_CLASS");
		    prop_count=load_prop(SEP_EQUAL,SNMP_QOS_CONF,properties);
		    get_prop(string,value,properties,prop_count);
		    free_prop(properties,prop_count) ;
			
		    sprintf(param,"%s%s",nQs.ifName,"_AP_STAT");
		    prop_numb=load_prop(SEP_EQUAL,SNMP_QOS_CONF,properties);
		    get_prop(param,buffer,properties,prop_numb);
		    free_prop(properties,prop_numb) ;

		     printf("value:%s,string:%s\n",value,buffer);
		     sprintf(strcmd,"%s %s %s  %s %s  %s","/usr/sbin/iwpriv",nQs.ifName,"get_cwmin ",value,buffer,"|awk  -F \":\" '{print $NF}'");
		     printf("strcmd:%s\n",strcmd);
            	     fp = popen(strcmd, "r");
		      if(fp){  
		  	      memset( strBuf, 0, ACCESS_BUF );
	  	             fgets(strBuf,sizeof(strBuf),fp);
		             strBuf[strlen(strBuf)-1] = '\0';
			      pclose(fp);
			     nQs.QosCWmin=atoi(strBuf);
	               }
	    }
	
	
	nQs.haveQosCWmax= TRUE;
          {
		    memset(string,0,ACCESS_BUF);
		    memset(value,0,ACCESS_BUF);
		    memset(param,0,ACCESS_BUF);
		    memset(buffer,0,ACCESS_BUF);
		    memset(strcmd,0, ACCESS_STR);
		    sprintf(string,"%s%s",nQs.ifName,"_TRAFFIC_CLASS");
		    prop_count=load_prop(SEP_EQUAL,SNMP_QOS_CONF,properties);
		    get_prop(string,value,properties,prop_count);
		    free_prop(properties,prop_count) ;
			
		    sprintf(param,"%s%s",nQs.ifName,"_AP_STAT");
		    prop_numb=load_prop(SEP_EQUAL,SNMP_QOS_CONF,properties);
		    get_prop(param,buffer,properties,prop_numb);
		    free_prop(properties,prop_numb) ;

		     printf("value:%s,string:%s\n",value,buffer);
		     sprintf(strcmd,"%s %s %s  %s %s  %s","/usr/sbin/iwpriv",nQs.ifName,"get_cwmax ",value,buffer,"|awk  -F \":\" '{print $NF}'");
		     printf("strcmd:%s\n",strcmd);
		     fp = popen(strcmd, "r");
		      if(fp){  
		  	      memset( strBuf, 0, ACCESS_BUF );
	  	             fgets(strBuf,sizeof(strBuf),fp);
		             strBuf[strlen(strBuf)-1] = '\0';
			      pclose(fp);
			     nQs.QosCWmax=atoi(strBuf);
	               }
	    }	
	
	nQs.haveQosTXOPLim= TRUE;
         {
		    memset(string,0,ACCESS_BUF);
		    memset(value,0,ACCESS_BUF);
		    memset(param,0,ACCESS_BUF);
		    memset(buffer,0,ACCESS_BUF);
		    memset(strcmd,0, ACCESS_STR);

		    sprintf(string,"%s%s",nQs.ifName,"_TRAFFIC_CLASS");
		    prop_count=load_prop(SEP_EQUAL,SNMP_QOS_CONF,properties);
		    get_prop(string,value,properties,prop_count);
		    free_prop(properties,prop_count) ;
			
		    sprintf(param,"%s%s",nQs.ifName,"_AP_STAT");
		    prop_numb=load_prop(SEP_EQUAL,SNMP_QOS_CONF,properties);
		    get_prop(param,buffer,properties,prop_numb);
		    free_prop(properties,prop_numb) ;

		     printf("value:%s,string:%s\n",value,buffer);
		     sprintf(strcmd,"%s %s %s  %s %s  %s","/usr/sbin/iwpriv",nQs.ifName,"get_txoplimit ",value,buffer,"|awk  -F \":\" '{print $NF}'");
		     printf("strcmd:%s\n",strcmd);
            	     fp = popen(strcmd, "r");
		      if(fp){  
		  	      memset( strBuf, 0, 128 );
	  	             fgets(strBuf,sizeof(strBuf),fp);
		             strBuf[strlen(strBuf)-1] = '\0';
			      pclose(fp);
			     nQs.QosTXOPLim=atoi(strBuf);
	               }
	    }

}



if ( wi->has_range ) 
{
	 nQc.haveQosEnabled=TRUE;
	 memset(string,0,ACCESS_BUF);
	 sprintf(string,"%s  %s  %s","/usr/sbin/iwpriv",nQc.ifName,"get_wmm|awk -F \":\" '{print $2}'");
	 printf("strcmd:%s\n",strcmd);
	 fp = popen(string, "r");
	  if(fp)
	  	{  
	         memset( strBuf, 0, ACCESS_BUF );
	         fgets(strBuf,sizeof(strBuf),fp);
	         strBuf[strlen(strBuf)-1] = '\0';
	         pclose(fp);
		   nQc.QosEnabled=atoi(strBuf);
        	}
}

if ( wi->has_range ) 
   {
	     nQc.haveQosBW=TRUE;
	     memset(string,0,ACCESS_BUF);
	     memset(value,0,ACCESS_BUF);
	     sprintf(string,"%s%s",nQs.ifName,"_QosBW");
	     prop_count=load_prop(SEP_EQUAL,SNMP_QOS_CONF,properties);
	     get_prop(string,value,properties,prop_count);
	     free_prop(properties,prop_count) ;
	     nQc.QosBW=atoi(value);
	 }

if ( wi->has_range ) 
   {
	    nQc.haveQoSResPercent=TRUE;
	     memset(string,0,ACCESS_BUF);
	     memset(value,0,ACCESS_BUF);
	     sprintf(string,"%s%s",nQs.ifName,"_QoSResPercent");
	     prop_count=load_prop(SEP_EQUAL,SNMP_QOS_CONF,properties);
	     get_prop(string,value,properties,prop_count);
	     free_prop(properties,prop_count) ;
	     nQc.QoSResPercent=atoi(value);
    }


if ( wi->has_range ) 
     {
	     nQc.haveQossharedBW=TRUE;
	     memset(string,0,ACCESS_BUF);
	     memset(value,0,ACCESS_BUF);
	     sprintf(string,"%s%s",nQs.ifName,"_QossharedBW");
	     prop_count=load_prop(SEP_EQUAL,SNMP_QOS_CONF,properties);
	     get_prop(string,value,properties,prop_count);
	     free_prop(properties,prop_count) ;
	     nQc.QossharedBW=atoi(value);
	 }


if ( wi->has_range ) 
     {
	    nQc.haveQossharedBWPercent=TRUE;
	     memset(string,0,ACCESS_BUF);
	     memset(value,0,ACCESS_BUF);
	     sprintf(string,"%s%s",nQs.ifName,"_QossharedBWPercent");
	     prop_count=load_prop(SEP_EQUAL,SNMP_QOS_CONF,properties);
	     get_prop(string,value,properties,prop_count);
	     free_prop(properties,prop_count) ;
	     nQc.QossharedBWPercent=atoi(value);
	 }
	 

if ( wi->has_range ) 
	 {
	    nQc.haveSchedAlgName=TRUE;
	     memset(string,0,ACCESS_BUF);
	     memset(value,0,ACCESS_BUF);
	     sprintf(string,"%s%s",nQs.ifName,"_SchedAlgName");
	     prop_count=load_prop(SEP_EQUAL,SNMP_QOS_CONF,properties);
	     get_prop(string,value,properties,prop_count);
	     free_prop(properties,prop_count) ;
	     strcpy(nQc.SchedAlgName,value);
	 }
	 
	 nQc.haveResPolicyEnabled=TRUE;
	 {
	     memset(string,0,ACCESS_BUF);
	     memset(value,0,ACCESS_BUF);
	     sprintf(string,"%s%s",nQs.ifName,"_ResPolicyEnabled");
	     prop_count=load_prop(SEP_EQUAL,SNMP_QOS_CONF,properties);
	     get_prop(string,value,properties,prop_count);
	     free_prop(properties,prop_count) ;
	     nQc.ResPolicyEnabled=atoi(value);
	 }

	 
	 nQc.haveResPolicyName=TRUE;
	 {
	     memset(string,0,ACCESS_BUF);
	     memset(value,0,ACCESS_BUF);
	     sprintf(string,"%s%s",nQs.ifName,"_ResPolicyName");
	     prop_count=load_prop(SEP_EQUAL,SNMP_QOS_CONF,properties);
	     get_prop(string,value,properties,prop_count);
	     free_prop(properties,prop_count) ;
	     strcpy(nQc.ResPolicyName,value);
	 }
	 
	 
	 nQc.haveBackgroundSvcAvgSpeed=TRUE;
	 {
	     memset(string,0,ACCESS_BUF);
	     memset(value,0,ACCESS_BUF);
	     sprintf(string,"%s%s",nQs.ifName,"_BackgroundSvcAvgSpeed");
	     prop_count=load_prop(SEP_EQUAL,SNMP_QOS_CONF,properties);
	     get_prop(string,value,properties,prop_count);
	     free_prop(properties,prop_count) ;
	     nQc.BackgroundSvcAvgSpeed=atoi(value);
	 }

	 
	 nQc.haveBackgroundSvcMaxBurst=TRUE;
	 {
	     memset(string,0,ACCESS_BUF);
	     memset(value,0,ACCESS_BUF);
	     sprintf(string,"%s%s",nQs.ifName,"_BackgroundSvcMaxBurst");
	     prop_count=load_prop(SEP_EQUAL,SNMP_QOS_CONF,properties);
	     get_prop(string,value,properties,prop_count);
	     free_prop(properties,prop_count) ;
	     nQc.BackgroundSvcMaxBurst=atoi(value);
	}

	 
	 nQc.haveBackgroundSvcPriority=TRUE;
	 {
	     memset(string,0,ACCESS_BUF);
	     memset(value,0,ACCESS_BUF);
	     sprintf(string,"%s%s",nQs.ifName,"_BackgroundSvcPriority");
	     prop_count=load_prop(SEP_EQUAL,SNMP_QOS_CONF,properties);
	     get_prop(string,value,properties,prop_count);
	     free_prop(properties,prop_count) ;
	      nQc.BackgroundSvcPriority=atoi(value);
}

	 
	 nQc.haveBackgroundSvcResPriority=TRUE;
	 {
	     memset(string,0,ACCESS_BUF);
	     memset(value,0,ACCESS_BUF);
	     sprintf(string,"%s%s",nQs.ifName,"_BackgroundSvcResPriority");
	     prop_count=load_prop(SEP_EQUAL,SNMP_QOS_CONF,properties);
	     get_prop(string,value,properties,prop_count);
	     free_prop(properties,prop_count) ;
	      nQc.BackgroundSvcResPriority=atoi(value);
	 }
	 
	 nQc.haveBestEffortSvcAvgSpeed=TRUE;
	 {
	     memset(string,0,ACCESS_BUF);
	     memset(value,0,ACCESS_BUF);
	     sprintf(string,"%s%s",nQs.ifName,"_BestEffortSvcAvgSpeed");
	     prop_count=load_prop(SEP_EQUAL,SNMP_QOS_CONF,properties);
	     get_prop(string,value,properties,prop_count);
	     free_prop(properties,prop_count) ;
	     nQc.BestEffortSvcAvgSpeed=atoi(value);
       }

	 
	 nQc.haveBestEffortSvcMaxBurst=TRUE;
	 {
	     memset(string,0,ACCESS_BUF);
	     memset(value,0,ACCESS_BUF);
	     sprintf(string,"%s%s",nQs.ifName,"_BestEffortSvcMaxBurst");
	     prop_count=load_prop(SEP_EQUAL,SNMP_QOS_CONF,properties);
	     get_prop(string,value,properties,prop_count);
	     free_prop(properties,prop_count) ;
	     nQc.BestEffortSvcMaxBurst=atoi(value);
 }

	 
	 nQc.haveBestEffortSvcPriority=TRUE;
	 {
	     memset(string,0,ACCESS_BUF);
	     memset(value,0,ACCESS_BUF);
	     sprintf(string,"%s%s",nQs.ifName,"_BestEffortSvcPriority");
	     prop_count=load_prop(SEP_EQUAL,SNMP_QOS_CONF,properties);
	     get_prop(string,value,properties,prop_count);
	     free_prop(properties,prop_count) ;
	     nQc.BestEffortSvcPriority=atoi(value);
}

	 
	 nQc.haveBestEffortSvcResPriority=TRUE;
	 {
	     memset(string,0,ACCESS_BUF);
	     memset(value,0,ACCESS_BUF);
	     sprintf(string,"%s%s",nQs.ifName,"_BestEffortSvcResPriority");
	     prop_count=load_prop(SEP_EQUAL,SNMP_QOS_CONF,properties);
	     get_prop(string,value,properties,prop_count);
	     free_prop(properties,prop_count) ;
	    nQc.BestEffortSvcResPriority=atoi(value);
   }


	 nQc.haveVoiceSvcAvgSpeed=TRUE;
	 {
	     memset(string,0,ACCESS_BUF);
	     memset(value,0,ACCESS_BUF);
	     sprintf(string,"%s%s",nQs.ifName,"_VoiceSvcAvgSpeed");
	     prop_count=load_prop(SEP_EQUAL,SNMP_QOS_CONF,properties);
	     get_prop(string,value,properties,prop_count);
	     free_prop(properties,prop_count) ;
	     nQc.VoiceSvcAvgSpeed=atoi(value);
	 }

	 
	 nQc.haveVoiceSvcMaxBurst=TRUE;
	 {
	     memset(string,0,ACCESS_BUF);
	     memset(value,0,ACCESS_BUF);
	     sprintf(string,"%s%s",nQs.ifName,"_VoiceSvcMaxBurst");
	     prop_count=load_prop(SEP_EQUAL,SNMP_QOS_CONF,properties);
	     get_prop(string,value,properties,prop_count);
	     free_prop(properties,prop_count) ;
	     nQc.VoiceSvcMaxBurst=atoi(value);
	 }

	 
	 nQc.haveVoiceSvcPriority=TRUE;
	 {
	     memset(string,0,ACCESS_BUF);
	     memset(value,0,ACCESS_BUF);
	     sprintf(string,"%s%s",nQs.ifName,"_VoiceSvcPriority");
	     prop_count=load_prop(SEP_EQUAL,SNMP_QOS_CONF,properties);
	     get_prop(string,value,properties,prop_count);
	     free_prop(properties,prop_count) ;
	     nQc.VoiceSvcPriority=atoi(value);
	 }

	 
	 nQc.haveVoiceSvcResPriority=TRUE;
	 {
	     memset(string,0,ACCESS_BUF);
	     memset(value,0,ACCESS_BUF);
	     sprintf(string,"%s%s",nQs.ifName,"_VoiceSvcResPriority");
	     prop_count=load_prop(SEP_EQUAL,SNMP_QOS_CONF,properties);
	     get_prop(string,value,properties,prop_count);
	     free_prop(properties,prop_count) ;
	     nQc.VoiceSvcResPriority=atoi(value);
	 }

	 nQc.haveVideoSvcAvgSpeed=TRUE;
	 {
	     memset(string,0,ACCESS_BUF);
	     memset(value,0,ACCESS_BUF);
	     sprintf(string,"%s%s",nQs.ifName,"_VideoSvcAvgSpeed");
	     prop_count=load_prop(SEP_EQUAL,SNMP_QOS_CONF,properties);
	     get_prop(string,value,properties,prop_count);
	     free_prop(properties,prop_count) ;
	     nQc.VideoSvcAvgSpeed=atoi(value);
	 }
	 
	 nQc.haveVideoSvcMaxBurst=TRUE;
	 {
	     memset(string,0,ACCESS_BUF);
	     memset(value,0,ACCESS_BUF);
	     sprintf(string,"%s%s",nQs.ifName,"_VideoSvcMaxBurst");
	     prop_count=load_prop(SEP_EQUAL,SNMP_QOS_CONF,properties);
	     get_prop(string,value,properties,prop_count);
	     free_prop(properties,prop_count) ;
	     nQc.VideoSvcMaxBurst=atoi(value);
	 }

	 
	 nQc.haveVideoSvcPriority=TRUE;
	 {
	     memset(string,0,ACCESS_BUF);
	     memset(value,0,ACCESS_BUF);
	     sprintf(string,"%s%s",nQs.ifName,"_VideoSvcPriority");
	     prop_count=load_prop(SEP_EQUAL,SNMP_QOS_CONF,properties);
	     get_prop(string,value,properties,prop_count);
	     free_prop(properties,prop_count) ;
	     nQc.VideoSvcPriority=atoi(value);
	 }

	 
	 nQc.haveVideoSvcResPriority=TRUE;
	 {
	     memset(string,0,ACCESS_BUF);
	     memset(value,0,ACCESS_BUF);
	     sprintf(string,"%s%s",nQs.ifName,"_VideoSvcResPriority");
	     prop_count=load_prop(SEP_EQUAL,SNMP_QOS_CONF,properties);
	     get_prop(string,value,properties,prop_count);
	     free_prop(properties,prop_count) ;
	     nQc.VideoSvcResPriority=atoi(value);
	 }

	 
	 nQc.haveBgMaxSvcCnt=TRUE;
	 {
	     memset(string,0,ACCESS_BUF);
	     memset(value,0,ACCESS_BUF);
	     sprintf(string,"%s%s",nQs.ifName,"_BgMaxSvcCnt");
	     prop_count=load_prop(SEP_EQUAL,SNMP_QOS_CONF,properties);
	     get_prop(string,value,properties,prop_count);
	     free_prop(properties,prop_count) ;
	     nQc.BgMaxSvcCnt=atoi(value);
	 }
	 
	 nQc.haveBgSvcBW=TRUE;
	 {
	     memset(string,0,ACCESS_BUF);
	     memset(value,0,ACCESS_BUF);
	     sprintf(string,"%s%s",nQs.ifName,"_BgSvcBW");
	     prop_count=load_prop(SEP_EQUAL,SNMP_QOS_CONF,properties);
	     get_prop(string,value,properties,prop_count);
	     free_prop(properties,prop_count) ;
	     nQc.BgSvcBW=atoi(value);
	 }

	 
	 nQc.haveBgSvcBWPercent=TRUE;
	 {
	     memset(string,0,ACCESS_BUF);
	     memset(value,0,ACCESS_BUF);
	     sprintf(string,"%s%s",nQs.ifName,"_BgSvcBWPercent");
	     prop_count=load_prop(SEP_EQUAL,SNMP_QOS_CONF,properties);
	     get_prop(string,value,properties,prop_count);
	     free_prop(properties,prop_count) ;
	     nQc.BgSvcBWPercent=atoi(value);
	 }

	 
	 nQc.haveBgIsUseWREDAlg=TRUE;
	 {
	     memset(string,0,ACCESS_BUF);
	     memset(value,0,ACCESS_BUF);
	     sprintf(string,"%s%s",nQs.ifName,"_BgIsUseWREDAlg");
	     prop_count=load_prop(SEP_EQUAL,SNMP_QOS_CONF,properties);
	     get_prop(string,value,properties,prop_count);
	     free_prop(properties,prop_count) ;
	     nQc.BgIsUseWREDAlg=atoi(value);
	 }

	 
	 nQc.haveBgIsUseTrafficShaping=TRUE;
	 {
	     memset(string,0,ACCESS_BUF);
	     memset(value,0,ACCESS_BUF);
	     sprintf(string,"%s%s",nQs.ifName,"_BgIsUseTrafficShaping");
	     prop_count=load_prop(SEP_EQUAL,SNMP_QOS_CONF,properties);
	     get_prop(string,value,properties,prop_count);
	     free_prop(properties,prop_count) ;
	     nQc.BgIsUseTrafficShaping=atoi(value);
	 }

	 
	 nQc.haveBeMaxSvcCnt=TRUE;
	 {
	     memset(string,0,ACCESS_BUF);
	     memset(value,0,ACCESS_BUF);
	     sprintf(string,"%s%s",nQs.ifName,"_BeMaxSvcCnt");
	     prop_count=load_prop(SEP_EQUAL,SNMP_QOS_CONF,properties);
	     get_prop(string,value,properties,prop_count);
	     free_prop(properties,prop_count) ;
	     nQc.BeMaxSvcCnt=atoi(value);
	 }

	 
	 nQc.haveBeSvcBW=TRUE;
	 {
	     memset(string,0,ACCESS_BUF);
	     memset(value,0,ACCESS_BUF);
	     sprintf(string,"%s%s",nQs.ifName,"_BeSvcBW");
	     prop_count=load_prop(SEP_EQUAL,SNMP_QOS_CONF,properties);
	     get_prop(string,value,properties,prop_count);
	     free_prop(properties,prop_count) ;
	     nQc.BeSvcBW=atoi(value);
	 }

	 
	 nQc.haveBeSvcBWPercent=TRUE;
	 {
	     memset(string,0,ACCESS_BUF);
	     memset(value,0,ACCESS_BUF);
	     sprintf(string,"%s%s",nQs.ifName,"_BeSvcBWPercent");
	     prop_count=load_prop(SEP_EQUAL,SNMP_QOS_CONF,properties);
	     get_prop(string,value,properties,prop_count);
	     free_prop(properties,prop_count) ;
	     nQc.BeSvcBWPercent=atoi(value);
	 }

	 
	 nQc.haveBeIsUseWREDAlg=TRUE;
	 {
	     memset(string,0,ACCESS_BUF);
	     memset(value,0,ACCESS_BUF);
	     sprintf(string,"%s%s",nQs.ifName,"_BeIsUseWREDAlg");
	     prop_count=load_prop(SEP_EQUAL,SNMP_QOS_CONF,properties);
	     get_prop(string,value,properties,prop_count);
	     free_prop(properties,prop_count) ;
	     nQc.BeIsUseWREDAlg=atoi(value);
	 }

	 
	 nQc.haveBeIsUseTrafficShaping=TRUE;
	 {
	     memset(string,0,ACCESS_BUF);
	     memset(value,0,ACCESS_BUF);
	     sprintf(string,"%s%s",nQs.ifName,"_BeIsUseTrafficShaping");
	     prop_count=load_prop(SEP_EQUAL,SNMP_QOS_CONF,properties);
	     get_prop(string,value,properties,prop_count);
	     free_prop(properties,prop_count) ;
	     nQc.BeIsUseTrafficShaping=atoi(value);
	 }

	 nQc.haveVoiceMaxSvcCnt=TRUE;
	 {
	     memset(string,0,ACCESS_BUF);
	     memset(value,0,ACCESS_BUF);
	     sprintf(string,"%s%s",nQs.ifName,"_VoiceMaxSvcCnt");
	     prop_count=load_prop(SEP_EQUAL,SNMP_QOS_CONF,properties);
	     get_prop(string,value,properties,prop_count);
	     free_prop(properties,prop_count) ;
	     nQc.VoiceMaxSvcCnt=atoi(value);
	 }

	 
	 nQc.haveVoiceSvcBW=TRUE;
	 {
	     memset(string,0,ACCESS_BUF);
	     memset(value,0,ACCESS_BUF);
	     sprintf(string,"%s%s",nQs.ifName,"_VoiceSvcBW");
	     prop_count=load_prop(SEP_EQUAL,SNMP_QOS_CONF,properties);
	     get_prop(string,value,properties,prop_count);
	     free_prop(properties,prop_count) ;
	     nQc.VoiceSvcBW=atoi(value);
	 }

	 
	 nQc.haveVoiceSvcBWPercent=TRUE;
	 {
	     memset(string,0,ACCESS_BUF);
	     memset(value,0,ACCESS_BUF);
	     sprintf(string,"%s%s",nQs.ifName,"_VoiceSvcBWPercent");
	     prop_count=load_prop(SEP_EQUAL,SNMP_QOS_CONF,properties);
	     get_prop(string,value,properties,prop_count);
	     free_prop(properties,prop_count) ;
	     nQc.BestEffortSvcPriority=atoi(value);
	 }

	 
	 nQc.haveVoiceIsUseStreamBasedQueue=TRUE;
	 {
	     memset(string,0,ACCESS_BUF);
	     memset(value,0,ACCESS_BUF);
	     sprintf(string,"%s%s",nQs.ifName,"_VoiceIsUseStreamBasedQueue");
	     prop_count=load_prop(SEP_EQUAL,SNMP_QOS_CONF,properties);
	     get_prop(string,value,properties,prop_count);
	     free_prop(properties,prop_count) ;
	     nQc.VoiceIsUseStreamBasedQueue=atoi(value);
	 }

	 
	 nQc.haveVoiceStreamMaxQueueLen=TRUE;
	 {
	     memset(string,0,ACCESS_BUF);
	     memset(value,0,ACCESS_BUF);
	     sprintf(string,"%s%s",nQs.ifName,"_VoiceStreamMaxQueueLen");
	     prop_count=load_prop(SEP_EQUAL,SNMP_QOS_CONF,properties);
	     get_prop(string,value,properties,prop_count);
	     free_prop(properties,prop_count) ;
	     nQc.VoiceStreamMaxQueueLen=atoi(value);
	 }

	 
	 nQc.haveVoiceStreamAvgSpeed=TRUE;
	 {
	     memset(string,0,ACCESS_BUF);
	     memset(value,0,ACCESS_BUF);
	     sprintf(string,"%s%s",nQs.ifName,"_VoiceStreamAvgSpeed");
	     prop_count=load_prop(SEP_EQUAL,SNMP_QOS_CONF,properties);
	     get_prop(string,value,properties,prop_count);
	     free_prop(properties,prop_count) ;
	     nQc.VoiceStreamAvgSpeed=atoi(value);
	 }

	 
	 nQc.haveVoiceStreamMaxBurst=TRUE;
	 {
	     memset(string,0,ACCESS_BUF);
	     memset(value,0,ACCESS_BUF);
	     sprintf(string,"%s%s",nQs.ifName,"_VoiceStreamMaxBurst");
	     prop_count=load_prop(SEP_EQUAL,SNMP_QOS_CONF,properties);
	     get_prop(string,value,properties,prop_count);
	     free_prop(properties,prop_count) ;
	     nQc.VoiceStreamMaxBurst=atoi(value);
	 }

	 
	 nQc.haveVoiceIsUseWREDAlg=TRUE;
	 {
	     memset(string,0,ACCESS_BUF);
	     memset(value,0,ACCESS_BUF);
	     sprintf(string,"%s%s",nQs.ifName,"_VoiceIsUseWREDAlg");
	     prop_count=load_prop(SEP_EQUAL,SNMP_QOS_CONF,properties);
	     get_prop(string,value,properties,prop_count);
	     free_prop(properties,prop_count) ;
	     nQc.VoiceIsUseWREDAlg=atoi(value);
	 }

	 
	 nQc.haveVoiceIsUseTrafficShaping=TRUE;
	 {
	     memset(string,0,ACCESS_BUF);
	     memset(value,0,ACCESS_BUF);
	     sprintf(string,"%s%s",nQs.ifName,"_VoiceIsUseTrafficShaping");
	     prop_count=load_prop(SEP_EQUAL,SNMP_QOS_CONF,properties);
	     get_prop(string,value,properties,prop_count);
	     free_prop(properties,prop_count) ;
	     nQc.VoiceIsUseTrafficShaping=atoi(value);
	 }

	 
	 nQc.haveVideoMaxSvcCnt=TRUE;
	 {
	     memset(string,0,ACCESS_BUF);
	     memset(value,0,ACCESS_BUF);
	     sprintf(string,"%s%s",nQs.ifName,"_VideoMaxSvcCnt");
	     prop_count=load_prop(SEP_EQUAL,SNMP_QOS_CONF,properties);
	     get_prop(string,value,properties,prop_count);
	     free_prop(properties,prop_count) ;
	     nQc.VoiceMaxSvcCnt=atoi(value);
	 }

	 
	 nQc.haveVideoeSvcBW=TRUE;
	 {
	     memset(string,0,ACCESS_BUF);
	     memset(value,0,ACCESS_BUF);
	     sprintf(string,"%s%s",nQs.ifName,"_VideoeSvcBW");
	     prop_count=load_prop(SEP_EQUAL,SNMP_QOS_CONF,properties);
	     get_prop(string,value,properties,prop_count);
	     free_prop(properties,prop_count) ;
	     nQc.VoiceSvcBW=atoi(value);
	 }

	 
	 nQc.haveVideoSvcBWPercent=TRUE;
	 {
	     memset(string,0,ACCESS_BUF);
	     memset(value,0,ACCESS_BUF);
	     sprintf(string,"%s%s",nQs.ifName,"_VideoSvcBWPercent");
	     prop_count=load_prop(SEP_EQUAL,SNMP_QOS_CONF,properties);
	     get_prop(string,value,properties,prop_count);
	     free_prop(properties,prop_count) ;
	     nQc.VoiceSvcBWPercent=atoi(value);
	 }

	 
	 nQc.haveVideoIsUseStreamBasedQueue=TRUE;
	 {
	     memset(string,0,ACCESS_BUF);
	     memset(value,0,ACCESS_BUF);
	     sprintf(string,"%s%s",nQs.ifName,"_VideoIsUseStreamBasedQueue");
	     prop_count=load_prop(SEP_EQUAL,SNMP_QOS_CONF,properties);
	     get_prop(string,value,properties,prop_count);
	     free_prop(properties,prop_count) ;
	     nQc.VoiceIsUseStreamBasedQueue=atoi(value);
	 }

	 
	 nQc.haveVideoStreamMaxQueueLen=TRUE;
	 {
	     memset(string,0,ACCESS_BUF);
	     memset(value,0,ACCESS_BUF);
	     sprintf(string,"%s%s",nQs.ifName,"_VideoStreamMaxQueueLen");
	     prop_count=load_prop(SEP_EQUAL,SNMP_QOS_CONF,properties);
	     get_prop(string,value,properties,prop_count);
	     free_prop(properties,prop_count) ;
	     nQc.VoiceStreamMaxQueueLen=atoi(value);
	 }

	 
	 nQc.haveVideoStreamAvgSpeed=TRUE;
	 {
	     memset(string,0,ACCESS_BUF);
	     memset(value,0,ACCESS_BUF);
	     sprintf(string,"%s%s",nQs.ifName,"_VideoStreamAvgSpeed");
	     prop_count=load_prop(SEP_EQUAL,SNMP_QOS_CONF,properties);
	     get_prop(string,value,properties,prop_count);
	     free_prop(properties,prop_count) ;
	     nQc.VoiceStreamAvgSpeed=atoi(value);
	 }

	 
	 nQc.haveVideoStreamMaxBurst=TRUE;
	 {
	     memset(string,0,ACCESS_BUF);
	     memset(value,0,ACCESS_BUF);
	     sprintf(string,"%s%s",nQs.ifName,"_VideoStreamMaxBurst");
	     prop_count=load_prop(SEP_EQUAL,SNMP_QOS_CONF,properties);
	     get_prop(string,value,properties,prop_count);
	     free_prop(properties,prop_count) ;
	     nQc.VoiceStreamMaxBurst=atoi(value);
	 }

	 
	 nQc.haveVideoIsUseWREDAlg=TRUE;
	 {
	     memset(string,0,ACCESS_BUF);
	     memset(value,0,ACCESS_BUF);
	     sprintf(string,"%s%s",nQs.ifName,"_VideoIsUseWREDAlg");
	     prop_count=load_prop(SEP_EQUAL,SNMP_QOS_CONF,properties);
	     get_prop(string,value,properties,prop_count);
	     free_prop(properties,prop_count) ;
	     nQc.VideoIsUseWREDAlg=atoi(value);
	 }

	 
	 nQc.haveVideoIsUseTrafficShaping=TRUE;
	 {
	     memset(string,0,ACCESS_BUF);
	     memset(value,0,ACCESS_BUF);
	     sprintf(string,"%s%s",nQs.ifName,"_VideoIsUseTrafficShaping");
	     prop_count=load_prop(SEP_EQUAL,SNMP_QOS_CONF,properties);
	     get_prop(string,value,properties,prop_count);
	     free_prop(properties,prop_count) ;
	     nQc.VideoIsUseTrafficShaping=atoi(value);
	 }

}






/****************************************************************************
*                                                                           *
*      loadWiExt() - load wireless extensions structures;                   *
*                    use ioctl calls and read /proc/net/wireless            *
*                                                                           *
****************************************************************************/
static void  load_WiExt ( int skfd, char *ifname, struct wireless_info *wi )
{
  struct iwreq wrq;                       // ioctl request structure
  FILE *fp;
  char  bfr[1024];
  char  buffer[sizeof ( iwrange ) * 2]; /* Large enough */
  char *s, *t;
  int i, j;

  strncpy ( wrq.ifr_name, ifname, IFNAMSIZ );

  /* Get wireless name */
  if ( ioctl ( skfd, SIOCGIWNAME, &wrq ) >= 0 ) {
    strncpy ( wi->name, wrq.u.name, IFNAMSIZ );
    wi->name[IFNAMSIZ] = '\0';
  }

  /* Get ranges */    // NOTE: some version checking in iwlib.c
  memset ( buffer, 0, sizeof ( buffer ));
  wrq.u.data.pointer = ( caddr_t ) &buffer;
  wrq.u.data.length = sizeof ( buffer );
  wrq.u.data.flags = 0;
  if ( ioctl ( skfd, SIOCGIWRANGE, &wrq ) >= 0 ) {
    memcpy (( char * ) &wi->range, buffer, sizeof ( iwrange ));
    wi->has_range = 1;
  }

  /* Get network ID */
  if ( ioctl ( skfd, SIOCGIWNWID, &wrq ) >= 0 ) {
    memcpy ( &wi->nwid, &wrq.u.nwid, sizeof ( iwparam ));
    wi->has_nwid = 1;
  }


  /* Get sensitivity */
  if ( ioctl ( skfd, SIOCGIWSENS, &wrq ) >= 0 ) {
    wi->has_sens = 1;
    memcpy ( &wi->sens, &wrq.u.sens, sizeof ( iwparam ));
  }

  /* Get encryption information */
  wrq.u.data.pointer = ( caddr_t ) &wi->key;
  wrq.u.data.length = IW_ENCODING_TOKEN_MAX;
  wrq.u.data.flags = 0;
  if ( ioctl ( skfd, SIOCGIWENCODE, &wrq ) >= 0 ) {
    wi->has_key = 1;
    wi->key_size = wrq.u.data.length;
    wi->key_flags = wrq.u.data.flags;
    wepCurrentKey = wrq.u.data.flags & IW_ENCODE_INDEX;
  }

  for ( i = 0; i < wi->range.max_encoding_tokens; i++ ) {
    wrq.u.data.pointer = ( caddr_t ) &wi->key;
    wrq.u.data.length = IW_ENCODING_TOKEN_MAX;
    wrq.u.data.flags = i;
    if ( ioctl ( skfd, SIOCGIWENCODE, &wrq ) >= 0 ) {
      if ( ( wrq.u.data.length != 0 ) &&
          !( wrq.u.data.flags & IW_ENCODE_DISABLED )) {
        wep[i].len = wrq.u.data.length;
        wep[i].haveKey = TRUE;
        t = wep[i].key;
        for ( j = 0; j < wrq.u.data.length; j++ ) {
          if (( j & 0x1 ) == 0 && j != 0 )
        	  strcpy ( t++, "-");
          sprintf ( t, "%.2X", wi->key[j] );
          t += 2;
        }
        t = '\0';
      }
    }
  }

  /* Get ESSID */
  wrq.u.essid.pointer = ( caddr_t ) &wi->essid;
  wrq.u.essid.length = IW_ESSID_MAX_SIZE + 1;
  wrq.u.essid.flags = 0;
  if ( ioctl ( skfd, SIOCGIWESSID, &wrq ) >= 0 ) {
    wi->has_essid = 1;
    wi->essid_on = wrq.u.data.flags;
  }

  /* Get AP address */
  if ( ioctl ( skfd, SIOCGIWAP, &wrq ) >= 0 ) {
    wi->has_ap_addr = 1;
    memcpy ( &wi->ap_addr, &wrq.u.ap_addr, sizeof ( sockaddr ));
  }

  /* Get NickName */
  wrq.u.essid.pointer = ( caddr_t ) &wi->nickname;
  wrq.u.essid.length = IW_ESSID_MAX_SIZE + 1;
  wrq.u.essid.flags = 0;
  if ( ioctl ( skfd, SIOCGIWNICKN, &wrq ) >= 0 ) {
    if ( wrq.u.data.length > 1 )
      wi->has_nickname = 1;
  }

  /* Get bit rate */
  if ( ioctl ( skfd, SIOCGIWRATE, &wrq ) >= 0 ) {
    wi->has_bitrate = 1;
    memcpy ( &wi->bitrate, &wrq.u.bitrate, sizeof ( iwparam ));
  }

  /* Get RTS threshold */
  if ( ioctl ( skfd, SIOCGIWRTS, &wrq ) >= 0 ) {
    wi->has_rts = 1;
    memcpy ( &wi->rts, &wrq.u.rts, sizeof ( iwparam ));
  }

  /* Get fragmentation threshold */
  if ( ioctl ( skfd, SIOCGIWFRAG, &wrq ) >= 0 ) {
      wi->has_frag = 1;
      memcpy ( &wi->frag, &wrq.u.frag, sizeof ( iwparam ));
    }

  /* Get operation mode */
  if ( ioctl ( skfd, SIOCGIWMODE, &wrq ) >= 0 ) {
      wi->mode = wrq.u.mode;
      if ( wi->mode < IW_NUM_OPER_MODE && wi->mode >= 0 )
        wi->has_mode = 1;
  }

  /* Get Power Management settings */                 // #if WIRELESS_EXT > 9
  wrq.u.power.flags = 0;
  if ( ioctl ( skfd, SIOCGIWPOWER, &wrq ) >= 0 ) {
    wi->has_power = 1;
    memcpy ( &wi->power, &wrq.u.power, sizeof ( iwparam ));
  }

  /* Get retry limit/lifetime */                      // #if WIRELESS_EXT > 10
  if ( ioctl ( skfd, SIOCGIWRETRY, &wrq ) >= 0 ) {    
    wi->has_retry = 1;
    memcpy ( &wi->retry, &wrq.u.retry, sizeof ( iwparam ));
  }

  /* Get stats */                                     // #if WIRELESS_EXT > 11
  wrq.u.data.pointer = ( caddr_t ) &wi->stats;
  wrq.u.data.length = 0;
  wrq.u.data.flags = 1;   /* Clear updated flag */
  if ( ioctl ( skfd, SIOCGIWSTATS, &wrq ) < 0 )
    wi->has_stats = 1;

  if ( !wi->has_stats ) {                        // no ioctl support, go to file
    fp = fopen ( PROC_NET_WIRELESS, "r" );
    if ( fp ) {
      while ( fgets ( bfr, sizeof ( bfr ), fp )) {
        bfr [ sizeof ( bfr ) - 1 ] = '\0';        // no buffer overruns here!
        strtok (( char * ) &bfr, "\n" );          // '\n' => '\0'
        if ( strstr ( bfr, ifname ) && strstr ( bfr, ":" )) {
          wi->has_stats = 1;
          s = bfr;
          s = strchr ( s, ':' ); s++;             /* Skip ethX:   */
          s = strtok ( s, " " );                  /* ' ' => '\0'  */
          sscanf ( s, "%X", &wi->stats.status ); // status 

          s = strtok ( NULL, " " );               // link quality
          if ( strchr ( s, '.' ) != NULL )
            wi->stats.qual.updated |= 1;
          sscanf ( s, "%d", &wi->stats.qual.qual );

          s = strtok ( NULL, " " );               // signal level
          if ( strchr ( s,'.' ) != NULL )
            wi->stats.qual.updated |= 2;
          sscanf ( s, "%d", &wi->stats.qual.level );

          s = strtok ( NULL, " " );               // noise level
          if ( strchr ( s, '.' ) != NULL )
            wi->stats.qual.updated += 4;
          sscanf ( s, "%d", &wi->stats.qual.noise );

          s = strtok ( NULL, " " ); sscanf ( s, "%d", &wi->stats.discard.nwid     );
          s = strtok ( NULL, " " ); sscanf ( s, "%d", &wi->stats.discard.code     );
          s = strtok ( NULL, " " ); sscanf ( s, "%d", &wi->stats.discard.fragment );
          s = strtok ( NULL, " " ); sscanf ( s, "%d", &wi->stats.discard.retries  );
          s = strtok ( NULL, " " ); sscanf ( s, "%d", &wi->stats.discard.misc     );
          s = strtok ( NULL, " " ); sscanf ( s, "%d", &wi->stats.miss.beacon      );
        }
      }
      fclose ( fp );
    }
  }

// printf ( "%s bfr: %s\n", "loadTables()", bfr );
}


/****************************************************************************
*                                                                           *
*                addList() - add an entry to a linked list                  *
*                                                                           *
****************************************************************************/
static void 
add_List ( char *l, char *data, int len  )
{
  char uid[256];
  LIST_HEAD ( , avNode ) *list;       

  // NOTE: this assumes the UID is at the begining of the 
  //       data structure and that UIDs are strings
  
  list = ( LIST_HEAD ( , avNode ) * ) l;            // NOTE: don't know how to get 
  strcpy ( uid, data );                             //  rid of compiler warning on
 // printf("nRr.uid:%s  nRr.data:%s\n",uid,data);                                                
                                                //  LISTHEAD typecast
  // create a new node and the data that goes in it
  newNode = malloc ( sizeof ( struct avNode ));
  newNode->data = malloc ( len );
  memcpy ( newNode->data, data, len );
  //printf("newNode->data:%s\n",newNode->data);  
  // this deals with an empty list
  if ( LIST_EMPTY ( list )) {
    LIST_INSERT_HEAD ( list, newNode, nodes );
    return;
  }

  // this deals with UIDs that match
  for ( np = LIST_FIRST ( list ); np != NULL; np = LIST_NEXT ( np, nodes )) {
    if ( strncmp ( uid, np->data, strlen ( uid )) == 0 ) {                      // found matching UID
      LIST_INSERT_AFTER ( np, newNode, nodes );
      if ( np->data )
        free ( np->data );
      LIST_REMOVE ( np, nodes );
      free ( np );
      return;
    }
  }

  // this deals with inserting a new UID in the list
  for ( np = LIST_FIRST ( list ); np != NULL; np = LIST_NEXT ( np, nodes )) {
    lastNode = np;
    if ( strncmp ( np->data, uid, strlen ( uid )) > 0 ) {                       // old ID > new ID AND
      LIST_INSERT_BEFORE ( np, newNode, nodes );
      return;
    }
  }

  // this deals with a UID that needs to go on the end of the list
  LIST_INSERT_AFTER ( lastNode, newNode, nodes );

  return;
}


static void init_Lists()
{
 

 LIST_INIT ( &lfList ); 
 LIST_INIT ( &cfList );
 LIST_INIT ( &qsList ); 
 LIST_INIT ( &qcList );

  
}



/****************************************************************************
*                                                                           *
*                 flushLists() - flush all linked lists                     *
*                                                                           *
****************************************************************************/
static void  flush_Lists()
{
  
 flush_List (( char * ) &lfList );
 flush_List (( char * ) &cfList );
 flush_List (( char * ) &qsList );
 flush_List (( char * ) &qcList );
 }




/****************************************************************************
*                                                                           *
*                   flushList() - flush a linked list                       *
*                                                                           *
****************************************************************************/
static void flush_List ( char *l )
{
  LIST_HEAD ( , avNode ) *list;
  
  list = ( LIST_HEAD ( , avNode ) * ) l;    // NOTE: don't know how to get 
  while ( !LIST_EMPTY ( list )) {           //  rid of compiler warning on
    np = LIST_FIRST ( list );               //  LISTHEAD typecast
    if ( np->data )
      free ( np->data );
    LIST_REMOVE ( np, nodes );
    free ( np );
  }
}




/****************************************************************************
*                                                                           *
*                            Utility Functions                              *
*                                                                           *
****************************************************************************/
/****************************************************************************
*                                                                           *
*        The following two routines were taken directly from iwlib.c        *
*                                                                           *
****************************************************************************/
 /*
 * Open a socket.
 * Depending on the protocol present, open the right socket. The socket
 * will allow us to talk to the driver.
 */
static int open_Socket ( void )
{
  static const int families[] = {
    AF_INET, AF_IPX, AF_AX25, AF_APPLETALK
  };
  unsigned int  i;
  int   sock;

  /*
   * Now pick any (exisiting) useful socket family for generic queries
   * Note : don't open all the socket, only returns when one matches,
   * all protocols might not be valid.
   * Workaround by Jim Kaba <jkaba@sarnoff.com>
   * Note : in 99% of the case, we will just open the inet_sock.
   * The remaining 1% case are not fully correct...
   */

  /* Try all families we support */
  for(i = 0; i < sizeof(families)/sizeof(int); ++i) {
      /* Try to open the socket, if success returns it */
      sock = socket(families[i], SOCK_DGRAM, 0);
      if(sock >= 0)
  return sock;
  }

  return -1;
}




/****************************************************************************
*                                                                           *
*                 htob - converts hex string to binary                      *
*                                                                           *
****************************************************************************/
static char *h_to_b ( char *s )
{
    char nibl, *byt;
    static char bin[20];

    byt = bin;

    while ((nibl = *s++) && nibl != ' ') {    /* While not end of string. */
      nibl -= ( nibl > '9') ?  ('A' - 10): '0';
      *byt = nibl << 4;                              /* place high nibble */
      if((nibl = *s++) && nibl != ' ') {
        nibl -= ( nibl > '9') ?  ('A' - 10): '0';
        *byt |= nibl;                                /*  place low nibble */
      }
      else break;
      ++byt;
    }
    *++byt = '\0';
    return ( bin );
}







/****************************************************************************
*                                                                           *
*           hasChanged() - see if area has been changed from NULLs          *
*                                                                           *
****************************************************************************/
static int has_Changed ( char *loc, int len )
{
  char *wrk;
  int changed = TRUE;

  wrk = malloc ( len );
  memset ( wrk, 0, len );
  if ( memcmp ( loc, wrk, len ) == 0 )
    changed = FALSE;
  free ( wrk );

  return ( changed );
}


