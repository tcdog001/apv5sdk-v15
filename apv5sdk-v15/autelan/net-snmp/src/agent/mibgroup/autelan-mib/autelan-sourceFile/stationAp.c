/**********************************************************************************
* Copyright (c) 2008-2011  Beijing Autelan Technology Co. Ltd.
* All rights reserved.
*
* filename: stationAp.c
* description:  implementation for AP configaration information and station statistics
* 
*
* 
************************************************************************************/

/*
 * Note: this file originally auto-generated by mib2c using
 *        : mib2c.old-api.conf 14476 2006-04-18 17:36:51Z hardaker $
 */

#include <net-snmp/net-snmp-config.h>
#include <net-snmp/net-snmp-includes.h>
#include <net-snmp/agent/net-snmp-agent-includes.h>
#include "stationAp.h"
#include <ap_interface.h>
#include "wapi/wapicgifunc.h"
#include "wapi/iwlib.h"
//#include "../../autelan-mib/ieee802dot11.h"  hyh for test

//#define DISPLAYWIEXT                        // display wireless ext info
//#define TABLE_SIZE   1
//#define MINLOADFREQ 15    // min reload frequency in seconds
#define MINLOADFREQ  30  // min reload frequency in seconds      // for testing
#define PROC_NET_DEV      "/proc/net/dev"
#define PROC_NET_WIRELESS "/proc/net/wireless"

#define POWSAVE  0x0010
#define WMM    	 0x0002
#define  WLANCONF  "/usr/sbin/wlanconfig"
static unsigned char string_ap[SNMP_STR_LEN];

static void AP_loadTables();
static void AP_loadWiExt ( int, char *, struct wireless_info * );
static void AP_load80211Structs ( int, char *, struct wireless_info * );
static void AP_initStructs();

// Wireless Extensions Specific Functions
static void AP_loadWiExtTo80211Structs ( int, char *, struct wireless_info * );
static void AP_displayWiExt ( struct wireless_info );

// Linked List Functions
static void AP_addList ( char *, char *, int );
static void AP_initLists();                    // initialize all the linked lists
static void AP_flushLists();                   // flush all the linked lists
static void AP_flushList ( char * );           // flush a single linked list

// Utility Functions
static int   AP_openSocket ( void );
static int   AP_mWatt2dbm ( int );
static int  AP_dbm2mwatt(int);

static char *AP_htob ( char * );
static char *AP_HtoB ( char * );

static int   AP_hasChanged ( char *, int );
static int    GetMinutesFromString(char *timeString);


static unsigned long lastLoad = 0;          // ET in secs at last table load

static struct avNode *lastNode, *newNode, *np;



static double my_pow(double m,double n)
{
 	int pow = 0;
	double flag = 0;
	int i = 0;
	double res = 1.0;
	if ( n < 0.0)
	{
		pow = -(int)n;
		flag = 0.1;
	}
	else
	{
		pow = (int)n;
		flag = 10.0;
	}
	if( pow == 0)
	{
		return 1;
	}
	for(;i<pow;i++)
	{
		res *= flag;
	}
	return res;
}



//oid stationAp_variables_oid[] = { 1,3,6,1,4,1,31656,2,3,1 };
oid *stationAp_variables_oid;
/* 
 * variable4 stationAp_variables:
 *   this variable defines function callbacks and type return information 
 *   for the stationAp mib section 
 */

struct variable4 stationAp_variables[] = {
/*  magic number        , variable type , ro/rw , callback fn  , L, oidsuffix */

#define SSIDENABLED		1
{SSIDENABLED,  ASN_INTEGER,  RWRITE,  var_apConfigTable, 4,  { 1,1, 1, 1 }},
#define SSIDHIDDEN		2
{SSIDHIDDEN,  ASN_INTEGER,  RWRITE,  var_apConfigTable, 4,  { 1,1, 1, 2 }},
#define STAISOLATE		3
{STAISOLATE,  ASN_INTEGER,  RWRITE,  var_apConfigTable, 4,  { 1,1, 1, 3 }},
#define EAPAUTHENSUPPORT		4
{EAPAUTHENSUPPORT,  ASN_INTEGER,  RWRITE,  var_apConfigTable, 4,  { 1,1, 1, 4 }},
#define APMAXSIMULTUSERS		5
{APMAXSIMULTUSERS,  ASN_INTEGER,  RWRITE,  var_apConfigTable, 4,  { 1,1, 1, 5 }},
#define APBGMODE		6
{APBGMODE,  ASN_INTEGER,  RWRITE,  var_apConfigTable, 4,  { 1,1, 1, 6 }},
#define APCONNECTUSERS		7
{APCONNECTUSERS,  ASN_INTEGER,  RONLY,   var_apConfigTable, 4,  { 1,1, 1, 7 }},
#define USRREQJOINCOUNT		8
{USRREQJOINCOUNT,  ASN_INTEGER,  RONLY,   var_apConfigTable, 4,  { 1,1, 1, 8 }},
#define APRESPUSERCOUNT		9
{APRESPUSERCOUNT,  ASN_INTEGER,  RONLY,   var_apConfigTable, 4,  { 1,1, 1, 9 }},
#define USRJOINSUCCOUNT		10
{USRJOINSUCCOUNT,  ASN_INTEGER,  RONLY,   var_apConfigTable, 4,  { 1,1, 1, 10 }},
#define APUSRTOTALTIME		11
{APUSRTOTALTIME,  ASN_INTEGER,  RONLY,   var_apConfigTable, 4,  { 1,1, 1, 11 }},
#define AP80211STATS		12
{AP80211STATS,  ASN_OCTET_STR,  RONLY,   var_apConfigTable, 4,  { 1,1, 1, 12 }},
#define APUTILRESOURCE		13
{APUTILRESOURCE,  ASN_OCTET_STR,  RONLY,   var_apConfigTable, 4,  { 1,1, 1, 13 }},
#define VAPFLAG		14
{VAPFLAG,  ASN_OCTET_STR,  RWRITE,  var_apConfigTable, 4,  { 1,1, 1, 14 }},
#define VAPTRAFFIC		15
{VAPTRAFFIC,  ASN_OCTET_STR,  RWRITE,  var_apConfigTable, 4,  { 1,1, 1, 15 }},
#define EVERYNODEFLAG		16
{EVERYNODEFLAG,  ASN_OCTET_STR,  RWRITE,  var_apConfigTable, 4,  { 1,1, 1, 16 }},
#define EVERYNODETRAFFIC		17
{EVERYNODETRAFFIC,  ASN_OCTET_STR,  RWRITE,  var_apConfigTable, 4,  { 1,1, 1, 17 }},
#define SPECIFICNODEFLAG		18
{SPECIFICNODEFLAG,  ASN_OCTET_STR,  RWRITE,  var_apConfigTable, 4,  { 1,1, 1, 18 }},
#define SPECIFICNODETRAFFIC		19
{SPECIFICNODETRAFFIC,  ASN_OCTET_STR,  RWRITE,  var_apConfigTable, 4,  { 1,1, 1, 19 }},
#define SNRBSSIDTXSIGNALPKTS		20
{SNRBSSIDTXSIGNALPKTS,  ASN_INTEGER,  RONLY,   var_apConfigTable, 4,  { 1,1, 1, 20 }},
#define SNRBSSIDRXSIGNALPKTS		21
{SNRBSSIDRXSIGNALPKTS,  ASN_INTEGER,  RONLY,   var_apConfigTable, 4,  { 1,1, 1, 21 }},
#define SNRBSSIDSIGNALPKTS		22
{SNRBSSIDSIGNALPKTS,  ASN_INTEGER,  RONLY,   var_apConfigTable, 4,  { 1,1, 1, 22 }},
#define RADIOIFINDEX		23
{RADIOIFINDEX,  ASN_INTEGER,  RONLY,   var_apConfigTable, 4,  { 1,1, 1, 23 }},
#define SSIDINDEX		24
{SSIDINDEX,  ASN_INTEGER,  RWRITE,  var_apConfigTable, 4,  { 1,1, 1, 24 }},
#define BSSID		25
{BSSID,  ASN_OCTET_STR,  RONLY,   var_apConfigTable, 4,  { 1,1, 1, 25 }},
#define APFLOODDETECTSWITCH		26
{APFLOODDETECTSWITCH,  ASN_INTEGER,  RWRITE,  var_apConfigTable, 4,  { 1,1, 1, 26 }},
#define APSPOOFDETECTSWITCH		27
{APSPOOFDETECTSWITCH,  ASN_INTEGER,  RWRITE,  var_apConfigTable, 4,  { 1,1, 1, 27 }},
#define APWKIVDECTECTSWITCH		28
{APWKIVDECTECTSWITCH,  ASN_INTEGER,  RWRITE,  var_apConfigTable, 4,  { 1,1, 1, 28 }},
#define APCLEARATTACKHISTORY		29
{APCLEARATTACKHISTORY,  ASN_INTEGER,  RWRITE,  var_apConfigTable, 4,  { 1,1, 1, 29 }},
#define APCLEARILLEGALHISTORY		30
{APCLEARILLEGALHISTORY,  ASN_INTEGER,  RWRITE,  var_apConfigTable, 4,  { 1,1, 1, 30 }},
#define APCLEARATTACKSTATISTICS		31
{APCLEARATTACKSTATISTICS,  ASN_INTEGER,  RWRITE,  var_apConfigTable, 4,  { 1,1, 1, 31 }},
#define APSECURITYTYPE		32
{APSECURITYTYPE,  ASN_INTEGER,  RWRITE,  var_apSecurityConfigTable, 4,  { 1,2, 1, 1 }},
#define APWPAAUTHMODE		33
{APWPAAUTHMODE,  ASN_INTEGER,  RWRITE,  var_apSecurityConfigTable, 4,  { 1,2, 1, 2 }},
#define APWPACIPHER		34
{APWPACIPHER,  ASN_INTEGER,  RWRITE,  var_apSecurityConfigTable, 4,  { 1,2, 1, 3 }},
#define APWPAKEYVALUE		35
{APWPAKEYVALUE,  ASN_OCTET_STR,  RWRITE,  var_apSecurityConfigTable, 4,  { 1,2, 1, 4 }},
#define APWEPAUTHMODE		36
{APWEPAUTHMODE,  ASN_INTEGER,  RWRITE,  var_apSecurityConfigTable, 4,  { 1,2, 1, 5 }},
#define APWEPKEYTYPE		37
{APWEPKEYTYPE,  ASN_INTEGER,  RWRITE,  var_apSecurityConfigTable, 4,  { 1,2, 1, 6 }},
#define APWEPBITLEVEL		38
{APWEPBITLEVEL,  ASN_INTEGER,  RWRITE,  var_apSecurityConfigTable, 4,  { 1,2, 1, 7 }},
#define APWEPKEYNUM		39
{APWEPKEYNUM,  ASN_INTEGER,  RWRITE,  var_apSecurityConfigTable, 4,  { 1,2, 1, 8 }},
#define APWEPKEYVALUE		40
{APWEPKEYVALUE,  ASN_OCTET_STR,  RWRITE,  var_apSecurityConfigTable, 4,  { 1,2, 1, 9 }},
#define APSTATMACADDRINDEX		41
{APSTATMACADDRINDEX,  ASN_INTEGER,  RONLY,   var_apStatMacAddrTable, 4,  { 1,3, 1, 1 }},
#define APSTATMACADDRVALUE		42
{APSTATMACADDRVALUE,  ASN_OCTET_STR,  RONLY,   var_apStatMacAddrTable, 4,  { 1,3, 1, 2 }},
#define APSTATRXPOWERINDEX		43
{APSTATRXPOWERINDEX,  ASN_INTEGER,  RONLY,   var_apStatRxPowerTable, 4,  { 1,4, 1, 1 }},
#define APSTATRXPOWERVALUE		44
{APSTATRXPOWERVALUE,  ASN_INTEGER,  RONLY,   var_apStatRxPowerTable, 4,  { 1,4, 1, 2 }},
#define APSTATUPTIMEINDEX		45
{APSTATUPTIMEINDEX,  ASN_INTEGER,  RONLY,   var_apStatUpTimeTable, 4,  { 1,5, 1, 1 }},
#define APSTATUPTIMEVALUE		46
{APSTATUPTIMEVALUE,  ASN_TIMETICKS,  RONLY,   var_apStatUpTimeTable, 4,  { 1,5, 1, 2 }},
#define APSTATTXSPEEDINDEX		47
{APSTATTXSPEEDINDEX,  ASN_INTEGER,  RONLY,   var_apStatTxSpeedTable, 4,  { 1,6, 1, 1 }},
#define APSTATTXSPEEDVALUE		48
{APSTATTXSPEEDVALUE,  ASN_INTEGER,  RONLY,   var_apStatTxSpeedTable, 4,  { 1,6, 1, 2 }},
#define APSTATRXSPEEDINDEX		49
{APSTATRXSPEEDINDEX,  ASN_INTEGER,  RONLY,   var_apStatRxSpeedTable, 4,  { 1,7, 1, 1 }},
#define APSTATRXSPEEDVALUE		50
{APSTATRXSPEEDVALUE,  ASN_INTEGER,  RONLY,   var_apStatRxSpeedTable, 4,  { 1,7, 1, 2 }},
#define APSTATIONSPEEDINDEX		51
{APSTATIONSPEEDINDEX,  ASN_INTEGER,  RONLY,   var_apStationSpeedTable, 4,  { 1,8, 1, 1 }},
#define APSTATIONSPEEDVALUE		52
{APSTATIONSPEEDVALUE,  ASN_INTEGER,  RONLY,   var_apStationSpeedTable, 4,  { 1,8, 1, 2 }},
#define APSTATTXTRAFFICINDEX		53
{APSTATTXTRAFFICINDEX,  ASN_INTEGER,  RONLY,   var_apStatTxTrafficTable, 4,  { 1,9, 1, 1 }},
#define APSTATTXTRAFFICVALUE		54
{APSTATTXTRAFFICVALUE,  ASN_INTEGER,  RONLY,   var_apStatTxTrafficTable, 4,  { 1,9, 1, 2 }},
#define APSTATRXTRAFFICINDEX		55
{APSTATRXTRAFFICINDEX,  ASN_INTEGER,  RONLY,   var_apStatRxTrafficTable, 4,  { 1,10, 1, 1 }},
#define APSTATRXTRAFFICVALUE		56
{APSTATRXTRAFFICVALUE,  ASN_INTEGER,  RONLY,   var_apStatRxTrafficTable, 4,  { 1,10, 1, 2 }},
#define APSTATIONTRAFFICINDEX		57
{APSTATIONTRAFFICINDEX,  ASN_INTEGER,  RONLY,   var_apStationTrafficTable, 4,  { 1,11, 1, 1 }},
#define APSTATIONTRAFFICVALUE		58
{APSTATIONTRAFFICVALUE,  ASN_INTEGER,  RONLY,   var_apStationTrafficTable, 4,  { 1,11, 1, 2 }},
#define APSTATRXERRPKSINDEX		59
{APSTATRXERRPKSINDEX,  ASN_INTEGER,  RONLY,   var_apStatRxErrPksTable, 4,  { 1,12, 1, 1 }},
#define APSTATRXERRPKSVALUE		60
{APSTATRXERRPKSVALUE,  ASN_INTEGER,  RONLY,   var_apStatRxErrPksTable, 4,  { 1,12, 1, 2 }},
#define APSTATRXSUCPKSINDEX		61
{APSTATRXSUCPKSINDEX,  ASN_INTEGER,  RONLY,   var_apStatRxSucPksTable, 4,  { 1,13, 1, 1 }},
#define APSTATRXSUCPKSVALUE		62
{APSTATRXSUCPKSVALUE,  ASN_INTEGER,  RONLY,   var_apStatRxSucPksTable, 4,  { 1,13, 1, 2 }},
#define APTXSIGNALPKTSINDEX		63
{APTXSIGNALPKTSINDEX,  ASN_INTEGER,  RONLY,   var_apTxSignalPktsTable, 4,  { 1,14, 1, 1 }},
#define APTXSIGNALPKTSVALUE		64
{APTXSIGNALPKTSVALUE,  ASN_INTEGER,  RONLY,   var_apTxSignalPktsTable, 4,  { 1,14, 1, 2 }},
#define APRXSIGNALPKTSINDEX		65
{APRXSIGNALPKTSINDEX,  ASN_INTEGER,  RONLY,   var_apRxSignalPktsTable, 4,  { 1,15, 1, 1 }},
#define APRXSIGNALPKTSVALUE		66
{APRXSIGNALPKTSVALUE,  ASN_INTEGER,  RONLY,   var_apRxSignalPktsTable, 4,  { 1,15, 1, 2 }},
#define APSIGNALPKTSINDEX		67
{APSIGNALPKTSINDEX,  ASN_INTEGER,  RONLY,   var_apSignalPktsTable, 4,  { 1,16, 1, 1 }},
#define APSIGNALPKTSVALUE		68
{APSIGNALPKTSVALUE,  ASN_INTEGER,  RONLY,   var_apSignalPktsTable, 4,  { 1,16, 1, 2 }},
#define STAWMMATTRINDEX		69
{STAWMMATTRINDEX,  ASN_INTEGER,  RONLY,   var_staWMMAttrTable, 4,  { 1,17, 1, 1 }},
#define STAWMMATTRVALUE		70
{STAWMMATTRVALUE,  ASN_INTEGER,  RONLY,   var_staWMMAttrTable, 4,  { 1,17, 1, 2 }},
#define STAIPADDRESSINDEX		71
{STAIPADDRESSINDEX,  ASN_INTEGER,  RONLY,   var_staIPAddressTable, 4,  { 1,18, 1, 1 }},
#define STAIPADDRESSVALUE		72
{STAIPADDRESSVALUE,  ASN_IPADDRESS,  RONLY,   var_staIPAddressTable, 4,  { 1,18, 1, 2 }},
#define STAPOWERSAVEMODEINDEX		73
{STAPOWERSAVEMODEINDEX,  ASN_INTEGER,  RONLY,   var_staPowerSaveModeTable, 4,  { 1,19, 1, 1 }},
#define STAPOWERSAVEMODEVALUE		74
{STAPOWERSAVEMODEVALUE,  ASN_INTEGER,  RONLY,   var_staPowerSaveModeTable, 4,  { 1,19, 1, 2 }},
#define STAUPLINKMAXRATEINDEX		75
{STAUPLINKMAXRATEINDEX,  ASN_INTEGER,  RONLY,   var_staUplinkMaxRateTable, 4,  { 1,20, 1, 1 }},
#define STAUPLINKMAXRATEVALUE		76
{STAUPLINKMAXRATEVALUE,  ASN_INTEGER,  RWRITE,  var_staUplinkMaxRateTable, 4,  { 1,20, 1, 2 }},
#define STADWLINKMAXRATEINDEX		77
{STADWLINKMAXRATEINDEX,  ASN_INTEGER,  RONLY,   var_staDwlinkMaxRateTable, 4,  { 1,21, 1, 1 }},
#define STADWLINKMAXRATEVALUE		78
{STADWLINKMAXRATEVALUE,  ASN_INTEGER,  RWRITE,  var_staDwlinkMaxRateTable, 4,  { 1,21, 1, 2 }},
#define APSTATIONINFOINDEX		79
{APSTATIONINFOINDEX,  ASN_INTEGER,  RONLY,   var_apStationInfoTable, 4,  { 1,22, 1, 1 }},
#define STARADIOMODE		80
{STARADIOMODE,  ASN_INTEGER,  RONLY,   var_apStationInfoTable, 4,  { 1,22, 1, 2 }},
#define STARADIOCHANNEL		81
{STARADIOCHANNEL,  ASN_INTEGER,  RONLY,   var_apStationInfoTable, 4,  { 1,22, 1, 3 }},
#define STAVLANID		82
{STAVLANID,  ASN_INTEGER,  RONLY,   var_apStationInfoTable, 4,  { 1,22, 1, 4 }},
#define STASSIDNAME		83
{STASSIDNAME,  ASN_OCTET_STR,  RONLY,   var_apStationInfoTable, 4,  { 1,22, 1, 5 }},
#define STAAUTHENMODE		84
{STAAUTHENMODE,  ASN_INTEGER,  RONLY,   var_apStationInfoTable, 4,  { 1,22, 1, 6 }},
#define STASECURITYCIPHERS		85
{STASECURITYCIPHERS,  ASN_INTEGER,  RONLY,   var_apStationInfoTable, 4,  { 1,22, 1, 7 }},
#define CHANAUTOSELECTENABLE		86
{CHANAUTOSELECTENABLE,  ASN_INTEGER,  RWRITE,  var_apRadioChannelTable, 4,  { 1,23, 1, 1 }},
#define RADIOCHANNELCONFIG		87
{RADIOCHANNELCONFIG,  ASN_INTEGER,  RWRITE,  var_apRadioChannelTable, 4,  { 1,23, 1, 2 }},
#define RADIOCHANNELUSING		88
{RADIOCHANNELUSING,  ASN_INTEGER,  RONLY,   var_apRadioChannelTable, 4,  { 1,23, 1, 3 }},
#define TRANSMITSPEEDCONFIG		89
{TRANSMITSPEEDCONFIG,  ASN_OCTET_STR,  RWRITE,  var_apRadioChannelTable, 4,  { 1,23, 1, 4 }},
#define MAXTXPWRLVL		90
{MAXTXPWRLVL,  ASN_INTEGER,  RONLY,   var_apRadioChannelTable, 4,  { 1,23, 1, 5 }},
#define PWRATTRANGE		91
{PWRATTRANGE,  ASN_INTEGER,  RONLY,   var_apRadioChannelTable, 4,  { 1,23, 1, 6 }},
#define ANTENNAGAIN		92
{ANTENNAGAIN,  ASN_INTEGER,  RONLY,   var_apRadioChannelTable, 4,  { 1,23, 1, 7 }},
#define POWERMGMTENABLE		93
{POWERMGMTENABLE,  ASN_INTEGER,  RWRITE,   var_apRadioChannelTable, 4,  { 1,23, 1, 8 }},
#define MAXSTATIONNUMPERMITTED		94
{MAXSTATIONNUMPERMITTED,  ASN_INTEGER,  RWRITE,  var_apRadioChannelTable, 4,  { 1,23, 1, 9 }},
};


/** Initializes the stationAp module */
void
init_stationAp(void)
{

  //  'cat  /jffs/.OEM/.vendor_oid'
  FILE *fp;
  char oid_str[64]={0};
  char oid_tmp[64]={0};
  int  oid_len=0;
  int  count = 0;
  char *p = NULL;
  char *ptr=NULL;
  
  fp=fopen( "/jffs/.OEM/.vendor_oid","r");
  if(fp)
  {
	  memset(oid_str,0,64);
	  fgets(oid_str,sizeof(oid_str),fp);
	  oid_str[strlen(oid_str)-1] = '\0';
	  fclose(fp);
  }
  else
   {
	  memset(oid_str,0,64);
	  strcpy(oid_str, "1.3.6.1.4.1.31656"); 
   }
  
  memset(oid_tmp,0,64);
  strcpy(oid_tmp,oid_str);
	   
  ptr = strtok(oid_tmp, "."); 
  while(NULL != ptr)
  {
	  oid_len++;
	  ptr = strtok(NULL,".");
   }
  
   oid_len = oid_len + 3;  
   stationAp_variables_oid = (oid *)malloc(sizeof(oid)*(oid_len));
   p = strtok(oid_str, ".");
    while( NULL != p)
    {
         stationAp_variables_oid[count++] = (oid)atoi(p);
         p = strtok(NULL,".");
    }
    stationAp_variables_oid[count ++] = 2;
    stationAp_variables_oid[count ++] = 3;
    stationAp_variables_oid[count ++] = 1;
   

	
    DEBUGMSGTL(("stationAp", "Initializing\n"));

    /* register ourselves with the agent to handle our mib tree */
    REGISTER_MIB_NEW("stationAp", stationAp_variables, variable4,
               stationAp_variables_oid, count); 
	

    /* place any other initialization junk you need here */
}

void shutdown_stationAp ( void )
{
  AP_flushLists();
}


/*
 * var_stationAp():
 *   This function is called every time the agent gets a request for
 *   a scalar variable that might be found within your mib section
 *   registered above.  It is up to you to do the right thing and
 *   return the correct value.
 *     You should also correct the value of "var_len" if necessary.
 *
 *   Please see the documentation for more information about writing
 *   module extensions, and check out the examples in the examples
 *   and mibII directories.
 */
unsigned char *
var_stationAp(struct variable *vp, 
                oid     *name, 
                size_t  *length, 
                int     exact, 
                size_t  *var_len, 
                WriteMethod **write_method)
{
    /* variables we may use later */
    static long long_ret;
    static u_long ulong_ret;
    static unsigned char string[STR_BUF];
    static oid objid[MAX_OID_LEN];
    static struct counter64 c64;

    if (header_generic(vp,name,length,exact,var_len,write_method)
                                  == MATCH_FAILED )
    return NULL;

    /* 
   * this is where we do the value assignments for the mib results.
   */
    switch(vp->magic) {
    default:
      ERROR_MSG("");
    }
    return NULL;
}


unsigned char *
var_apConfigTable(struct variable *vp,
    	    oid     *name,
    	    size_t  *length,
    	    int     exact,
    	    size_t  *var_len,
    	    WriteMethod **write_method)
{
    int found = FALSE;
    oid rName [ MAX_OID_LEN ];
	
    static long long_ret;
    static u_long ulong_ret;
    static unsigned char string[STR_BUF];
    static oid objid[MAX_OID_LEN];
    static struct counter64 c64;
    static  char  MACWork[17];
  AP_loadTables();
  memcpy (( char * ) rName, ( char * ) vp->name, ( int ) vp->namelen * sizeof ( oid ));
  for ( np = LIST_FIRST ( &acList ); np != NULL; np = LIST_NEXT ( np, nodes )) {
    ac = ( struct acTbl_data * ) np->data;
    rName[vp->namelen] = ac->ifIndex;
    if ((  exact && ( snmp_oid_compare ( rName, vp->namelen + 1, name, *length ) == 0 )) || 
        ( !exact && ( snmp_oid_compare ( rName, vp->namelen + 1, name, *length ) >  0 ))) {

   switch ( vp->magic ) {
        case SSIDENABLED:
          if ( ac->haveSSIDEnabled     ) found = TRUE; break;
   	case SSIDHIDDEN:
          if ( ac->haveSSIDHidden     ) found = TRUE; break;
	case STAISOLATE:
          if ( ac->haveStaIsolate     ) found = TRUE; break;
       case EAPAUTHENSUPPORT:
          if ( ac->haveEAPAuthenSupport          ) found = TRUE; break;
	case APMAXSIMULTUSERS:	 
            if (ac->haveApMaxSimultUsers     ) found = TRUE; break;
	case APBGMODE:
          if ( ac->haveApBGmode                  ) found = TRUE; break;
	case APCONNECTUSERS:
          if ( ac->haveApConnectUsers          ) found = TRUE; break;
	case USRREQJOINCOUNT:
          if ( ac->haveUsrReqJoinCount                  ) found = TRUE; break;
	case APRESPUSERCOUNT:
          if ( ac->haveApRespUserCount                  ) found = TRUE; break;
	case USRJOINSUCCOUNT:
          if ( ac->haveUsrJoinSucCount                  ) found = TRUE; break;
	case APUSRTOTALTIME:
          if ( ac->haveApUsrTotalTime                  ) found = TRUE; break;
	case  AP80211STATS:
          if ( ac->haveap80211stats                  ) found = TRUE; break;		
	case  APUTILRESOURCE:
          if ( ac->haveapUtilResource                  ) found = TRUE; break;
	case VAPFLAG:
          if ( ac->haveVapFlag                  ) found = TRUE; break;
	case VAPTRAFFIC:
          if ( ac->haveVapTraffic                  ) found = TRUE; break;
	case EVERYNODEFLAG:
          if ( ac->haveEveryNodeFlag                  ) found = TRUE; break;
	case EVERYNODETRAFFIC:
          if ( ac->haveEveryNodeTraffic                  ) found = TRUE; break;
	case SPECIFICNODEFLAG:
          if ( ac->haveSpecificNodeFlag                  ) found = TRUE; break;
	case SPECIFICNODETRAFFIC:
          if ( ac->haveSpecificNodeTraffic                  ) found = TRUE; break;
	case  SNRBSSIDTXSIGNALPKTS:
          if ( ac->haveSnrBSSIDTxSignalPkts                  ) found = TRUE; break;
	case  SNRBSSIDRXSIGNALPKTS:
          if ( ac->haveSnrBSSIDRxSignalPkts                  ) found = TRUE; break;
	 case  SNRBSSIDSIGNALPKTS:
          if ( ac->haveSnrBSSIDSignalPkts                  ) found = TRUE; break;
   	 case RADIOIFINDEX:
          if ( ac->haveRadioIfIndex                  ) found = TRUE; break;
    	case SSIDINDEX:
          if ( ac->haveSSIDindex                  ) found = TRUE; break;
   	 case BSSID:
          if ( ac->haveBSSID                  ) found = TRUE; break;
		  
	case  APFLOODDETECTSWITCH:
          if ( ac->haveapFloodDetect                  ) found = TRUE; break;
		
	case  APSPOOFDETECTSWITCH:
          if ( ac->haveapSpoofDetect                  ) found = TRUE; break;

	case  APWKIVDECTECTSWITCH:
          if ( ac->haveapWKIVDectect                  ) found = TRUE; break;

	case  APCLEARATTACKHISTORY:
          if ( ac->haveapClearAttackHistory                  ) found = TRUE; break;

	case  APCLEARILLEGALHISTORY:
          if ( ac->haveapClearIllegalHistory                  ) found = TRUE; break;

	case  APCLEARATTACKSTATISTICS:
          if ( ac->haveapClearAttackStatistics                  ) found = TRUE; break;
		  
      }
    }
    if ( found )
      break;
  }

  if ( !found ) 
    return NULL;

  memcpy (( char * ) name, ( char * ) rName, ( vp->namelen + 1 ) * sizeof ( oid ));
  *length = vp->namelen + 1;
  *var_len = sizeof ( long );
  *write_method = NULL;

    /* 
   * this is where we do the value assignments for the mib results.
   */
    switch(vp->magic) {
        case SSIDENABLED:
              *write_method = write_SSIDEnabled;
	    return ( UCHAR * ) &ac->SSIDEnabled;
			  
        case SSIDHIDDEN:
          *write_method = write_SSIDHidden;
	    return ( UCHAR * ) &ac->SSIDHidden;

	case STAISOLATE:
		*write_method = write_StaIsolate;
	    return ( UCHAR * ) &ac->StaIsolate;

	case EAPAUTHENSUPPORT:
           *write_method = write_EAPAuthenSupport;
	    return ( UCHAR * ) &ac->EAPAuthenSupport;

	case APMAXSIMULTUSERS:
		   *write_method = write_apMaxSimultUsers;
	       return ( UCHAR * )&ac->apMaxSimultUsers ;

	case APBGMODE:
           *write_method = write_apBGmode;
	    return (UCHAR * )&ac->apBGmode;

	case APCONNECTUSERS:
	    return ( UCHAR * ) &ac->apConnectUsers;

	case USRREQJOINCOUNT:
	    return (UCHAR * ) &ac->UsrReqJoinCount;

	case APRESPUSERCOUNT:
	    return (UCHAR * ) &ac->apRespUserCount;

	case USRJOINSUCCOUNT:
	    return (UCHAR * )&ac->UsrJoinSucCount;
		
	  case APUSRTOTALTIME:
	return (UCHAR * )&ac->apUsrTotalTime;
	case  AP80211STATS:
	 *var_len = strlen ( ac->ap80211stats );
	    return (UCHAR * )ac->ap80211stats;
		
	case  APUTILRESOURCE:
	 *var_len = strlen ( ac->apUtilResource );
	    return (UCHAR * )ac->apUtilResource;

	   case VAPFLAG:
        *write_method = write_vapFlag;
		*var_len = strlen ( ac->vapFlag );
	    return (UCHAR * )ac->vapFlag;

   
	   case VAPTRAFFIC:
	   *write_method = write_vapTraffic;
	   *var_len = strlen ( ac->vapTraffic );
	    return (UCHAR * )ac->vapTraffic;


	    case EVERYNODEFLAG:
        *write_method = write_everyNodeFlag;
		*var_len = strlen ( ac->everyNodeFlag );
	    return (UCHAR * )ac->everyNodeFlag;


	    case EVERYNODETRAFFIC:
        *write_method = write_everyNodeTraffic;
		*var_len = strlen ( ac->everyNodeTraffic );
	    return (UCHAR * )ac->everyNodeTraffic;


	    case SPECIFICNODEFLAG:
        *write_method = write_specificNodeFlag;
		*var_len = strlen ( ac->specificNodeFlag );
	    return (UCHAR * )ac->specificNodeFlag;


	    case SPECIFICNODETRAFFIC:
        *write_method = write_specificNodeTraffic;
		*var_len = strlen ( ac->specificNodeTraffic );
	    return (UCHAR * )ac->specificNodeTraffic;

	   case  SNRBSSIDTXSIGNALPKTS:
	    return (UCHAR * )&ac->SnrBSSIDTxSignalPkts;
		
	   case  SNRBSSIDRXSIGNALPKTS:
	    return (UCHAR * )&ac->SnrBSSIDRxSignalPkts;
		
	   case  SNRBSSIDSIGNALPKTS:
	    return (UCHAR * )&ac->SnrBSSIDSignalPkts;

   	 case RADIOIFINDEX:
	    return (UCHAR * )&ac->RadioIfIndex;
    	case SSIDINDEX:
   	   *write_method = write_SSIDindex;
	    return (UCHAR * )&ac->SSIDindex;
	case  BSSID:
	      MACWork[ 0] = ac->BSSIDmac[ 0];
	      MACWork[ 1] = ac->BSSIDmac[ 1];
	      MACWork[ 2] = ac->BSSIDmac[ 3];
	      MACWork[ 3] = ac->BSSIDmac[ 4];
	      MACWork[ 4] = ac->BSSIDmac[ 6];
	      MACWork[ 5] = ac->BSSIDmac[ 7];
	      MACWork[ 6] = ac->BSSIDmac[ 9];
	      MACWork[ 7] = ac->BSSIDmac[10];
	      MACWork[ 8] = ac->BSSIDmac[12];
	      MACWork[ 9] = ac->BSSIDmac[13];
	      MACWork[10] = ac->BSSIDmac[15];
	      MACWork[11] = ac->BSSIDmac[16];
	      MACWork[12] = '\0';
	      *var_len = 6;
             return ( UCHAR * ) AP_HtoB ( MACWork );
			 
	case  APFLOODDETECTSWITCH:
        *write_method = write_apFloodDetectSwitch;
	    return (UCHAR * )&ac->apFloodDetect;

	case  APSPOOFDETECTSWITCH:
        *write_method = write_apSpoofDetectSwitch;
	    return (UCHAR * )&ac->apSpoofDetect;

	case  APWKIVDECTECTSWITCH:
        *write_method = write_apWKIVDectectSwitch;
	    return (UCHAR * )&ac->apWKIVDectect;

	case  APCLEARATTACKHISTORY:
        *write_method = write_apClearAttackHistory;
	    return (UCHAR * )&ac->apClearAttackHistory;

	case  APCLEARILLEGALHISTORY:
        *write_method = write_apClearIllegalHistory;
	    return (UCHAR * )&ac->apClearIllegalHistory;

	case  APCLEARATTACKSTATISTICS:
         *write_method = write_apClearAttackStatistics;
	    return (UCHAR * )&ac->apClearAttackStatistics;

	default:
      ERROR_MSG("");
    }
    return NULL;
}




unsigned char *
var_apSecurityConfigTable(struct variable *vp,
    	    oid     *name,
    	    size_t  *length,
    	    int     exact,
    	    size_t  *var_len,
    	    WriteMethod **write_method)



{
  int found = FALSE;
  oid rName [ MAX_OID_LEN ];                            // OID to be returned
  static long long_ret;
  static u_long ulong_ret;
  static unsigned char string[STR_BUF];
  static oid objid[MAX_OID_LEN];
  static struct counter64 c64;
  AP_loadTables();
  memcpy (( char * ) rName, ( char * ) vp->name, ( int ) vp->namelen * sizeof ( oid ));
  for ( np = LIST_FIRST ( &seList ); np != NULL; np = LIST_NEXT ( np, nodes )) {
    se = ( struct seTbl_data * ) np->data;
    rName[vp->namelen] = se->ifIndex;
    if ((  exact && ( snmp_oid_compare ( rName, vp->namelen + 1, name, *length ) == 0 )) ||
        ( !exact && ( snmp_oid_compare ( rName, vp->namelen + 1, name, *length ) >  0 ))) {
      switch ( vp->magic ) {
	  	
        case APSECURITYTYPE:
          if (se->haveApSecurityType     ) found = TRUE; break;
    case APWPAAUTHMODE:
          	if (se->haveApwpaAuthMode     ) found = TRUE; break;
	 case APWPACIPHER:
          	if (se->haveApwpaCipher        ) found = TRUE; break;
	case APWPAKEYVALUE:
          	if (se->haveApwpaKeyValue     ) found = TRUE; break;
	case APWEPAUTHMODE:
          	if ( se->haveApwepAuthMode   ) found = TRUE; break;
	case APWEPKEYTYPE:
          	if ( se->haveApwepKeyType     ) found = TRUE; break;
        case APWEPBITLEVEL:
          	if ( se->haveApwepBitLevel      ) found = TRUE; break;
	case APWEPKEYNUM:
         	 if ( se->haveApwepKeyNum    ) found = TRUE; break;
        case APWEPKEYVALUE:
         	 if ( se->haveApwepKeyValue   ) found = TRUE; break;
      }      
    }
    if ( found )
      break;
  }

  if ( !found ) 
    return NULL;

   memcpy (( char * ) name, ( char * ) rName, ( vp->namelen + 1 ) * sizeof ( oid ));
  *length = vp->namelen + 1;
  *var_len = sizeof ( long );
  *write_method = NULL;

  switch ( vp->magic ) {

    case APSECURITYTYPE:
	  *write_method = write_apSecurityType;
      return ( UCHAR * )&se->apSecurityType ;

  case APWPAAUTHMODE:
        *write_method = write_apwpaAuthMode;
      return ( UCHAR * )&se->apwpaAuthMode ;
	  
  case APWPACIPHER:
        *write_method = write_apwpaCipher;
        return ( UCHAR * ) &se->apwpaCipher;

   case APWPAKEYVALUE:
        *write_method = write_apwpaKeyValue;
	  *var_len = strlen ( se->apwpaKeyValue );
         return ( UCHAR * ) se->apwpaKeyValue;

	case APWEPAUTHMODE:
	 *write_method = write_apwepAuthMode;
         return ( UCHAR * )&se->apwepAuthMode ;    

	case APWEPKEYTYPE:
	 *write_method = write_apwepKeyType;
          return ( UCHAR * )&se->apwepKeyType;

	case APWEPBITLEVEL:
	 *write_method = write_apwepBitLevel;
         return ( UCHAR * )&se->apwepBitLevel;

	case APWEPKEYNUM:
	  *write_method = write_apwepKeyNum;
         return ( UCHAR * )&se->apwepKeyNum;

	case APWEPKEYVALUE:
	  *write_method = write_apwepKeyValue;
	  *var_len = strlen (  se->apwepKeyValue );
         return ( UCHAR * ) se->apwepKeyValue;
        
 default:
      ERROR_MSG ( "" );
  }

  return NULL;
}


unsigned char *
var_apStatMacAddrTable(struct variable *vp,
    	    oid     *name,
    	    size_t  *length,
    	    int     exact,
    	    size_t  *var_len,
    	    WriteMethod **write_method)
{
  int found = FALSE;
  oid rName [ MAX_OID_LEN ];                            // OID to be returned
  static long long_ret;
  static u_long ulong_ret;
  static char MACWork[17];
  static unsigned char string[STR_BUF];
  static oid objid[MAX_OID_LEN];
  static struct counter64 c64;
  AP_loadTables();
  memcpy (( char * ) rName, ( char * ) vp->name, ( int ) vp->namelen * sizeof ( oid ));
  for (np = LIST_FIRST ( &adList ); np != NULL; np = LIST_NEXT (np, nodes )) {
    ad = ( struct Ad_Tbl_data * ) np->data;
    rName[vp->namelen + 0] = ad->ifIndex;
    rName[vp->namelen + 1] = ad->apStatMacAddrIndex;
    if ((  exact && ( snmp_oid_compare ( rName, vp->namelen + 2, name, *length ) == 0 )) ||
        ( !exact && ( snmp_oid_compare ( rName, vp->namelen + 2, name, *length ) >  0 ))) {
      switch ( vp->magic ) {
          case APSTATMACADDRVALUE:
          if ( ad->haveApStatMacAddrValue  ) found = TRUE; break;
      }
    }
    if ( found )
      break;
  }

  if ( !found ) 
    return NULL;

  memcpy (( char * ) name, ( char * ) rName, ( vp->namelen + 2 ) * sizeof ( oid ));
  *length = vp->namelen + 2;
  *var_len = sizeof ( long );
  *write_method = NULL;

  switch ( vp->magic ) {

      case APSTATMACADDRVALUE :
      MACWork[ 0] = ad->apStatMacAddrValue[ 0];
      MACWork[ 1] = ad->apStatMacAddrValue[ 1];
      MACWork[ 2] = ad->apStatMacAddrValue[ 3];
      MACWork[ 3] = ad->apStatMacAddrValue[ 4];
      MACWork[ 4] = ad->apStatMacAddrValue[ 6];
      MACWork[ 5] = ad->apStatMacAddrValue[ 7];
      MACWork[ 6] = ad->apStatMacAddrValue[ 9];
      MACWork[ 7] = ad->apStatMacAddrValue[10];
      MACWork[ 8] = ad->apStatMacAddrValue[12];
      MACWork[ 9] = ad->apStatMacAddrValue[13];
      MACWork[10] = ad->apStatMacAddrValue[15];
      MACWork[11] = ad->apStatMacAddrValue[16];
      MACWork[12] = '\0';
      *var_len = 6;
      return ( UCHAR * ) AP_htob ( MACWork );

    default:
      ERROR_MSG ( "" );
  }

  return NULL;
}





unsigned char *
var_apStatRxPowerTable(struct variable *vp,
    	    oid     *name,
    	    size_t  *length,
    	    int     exact,
    	    size_t  *var_len,
    	    WriteMethod **write_method)
{
  int found = FALSE;
  oid rName [ MAX_OID_LEN ];                            // OID to be returned
  static long long_ret;
  static u_long ulong_ret;
  static unsigned char string[STR_BUF];
  static oid objid[MAX_OID_LEN];
  static struct counter64 c64;
  AP_loadTables();
  memcpy (( char * ) rName, ( char * ) vp->name, ( int ) vp->namelen * sizeof ( oid ));
  for (np = LIST_FIRST ( &rpList ); np != NULL; np = LIST_NEXT (np, nodes )) {
    rp = ( struct Rp_Tbl_data * ) np->data;
    rName[vp->namelen + 0] = rp->ifIndex;
    rName[vp->namelen + 1] = rp->apStatRxPowerIndex;
    if ((  exact && ( snmp_oid_compare ( rName, vp->namelen + 2, name, *length ) == 0 )) ||
        ( !exact && ( snmp_oid_compare ( rName, vp->namelen + 2, name, *length ) >  0 ))) {
      switch ( vp->magic ) {
          case APSTATRXPOWERVALUE:
          if ( rp->haveApStatRxPowerValue  ) found = TRUE; break;
      }
    }
    if ( found )
      break;
  }

  if ( !found ) 
    return NULL;

  memcpy (( char * ) name, ( char * ) rName, ( vp->namelen + 2 ) * sizeof ( oid ));
  *length = vp->namelen + 2;
  *var_len = sizeof ( long );
  *write_method = NULL;

  switch ( vp->magic ) {

      case APSTATRXPOWERVALUE :
	   return ( UCHAR * )&rp->apStatRxPowerValue;
        
    default:
      ERROR_MSG ( "" );
  }

  return NULL;
}






unsigned char *
var_apStatUpTimeTable(struct variable *vp,
    	    oid     *name,
    	    size_t  *length,
    	    int     exact,
    	    size_t  *var_len,
    	    WriteMethod **write_method)
{
  int found = FALSE;
  oid rName [ MAX_OID_LEN ];                            // OID to be returned
  static long long_ret;
  static u_long ulong_ret;
  static unsigned char string[STR_BUF];
  static oid objid[MAX_OID_LEN];
  static struct counter64 c64;
  AP_loadTables();
  memcpy (( char * ) rName, ( char * ) vp->name, ( int ) vp->namelen * sizeof ( oid ));
  for (np = LIST_FIRST ( &utList ); np != NULL; np = LIST_NEXT (np, nodes )) {
    ut = ( struct Ut_Tbl_data * ) np->data;
    rName[vp->namelen + 0] = ut->ifIndex;
    rName[vp->namelen + 1] = ut->apStatUpTimeIndex;
    if ((  exact && ( snmp_oid_compare ( rName, vp->namelen + 2, name, *length ) == 0 )) ||
        ( !exact && ( snmp_oid_compare ( rName, vp->namelen + 2, name, *length ) >  0 ))) {
      switch ( vp->magic ) {
          case APSTATUPTIMEVALUE:
          if ( ut->haveApStatUpTimeValue  ) found = TRUE; break;
      }
    }
    if ( found )
      break;
  }

  if ( !found ) 
    return NULL;

  memcpy (( char * ) name, ( char * ) rName, ( vp->namelen + 2 ) * sizeof ( oid ));
  *length = vp->namelen + 2;
  *var_len = sizeof ( long );
  *write_method = NULL;

  switch ( vp->magic ) {

      case APSTATUPTIMEVALUE :
	   return ( UCHAR * )&ut->apStatUpTimeValue;
        
    default:
      ERROR_MSG ( "" );
  }

  return NULL;
}





unsigned char *
var_apStatTxSpeedTable(struct variable *vp,
    	    oid     *name,
    	    size_t  *length,
    	    int     exact,
    	    size_t  *var_len,
    	    WriteMethod **write_method)
{
  int found = FALSE;
  oid rName [ MAX_OID_LEN ];                            // OID to be returned
  static long long_ret;
  static u_long ulong_ret;
  static unsigned char string[STR_BUF];
  static oid objid[MAX_OID_LEN];
  static struct counter64 c64;
  AP_loadTables();
  memcpy (( char * ) rName, ( char * ) vp->name, ( int ) vp->namelen * sizeof ( oid ));
  for (np = LIST_FIRST ( &arList ); np != NULL; np = LIST_NEXT (np, nodes )) {
    ar = ( struct Ar_Tbl_data * ) np->data;
    rName[vp->namelen + 0] = ar->ifIndex;
    rName[vp->namelen + 1] = ar->apStatTxSpeedIndex;
    if ((  exact && ( snmp_oid_compare ( rName, vp->namelen + 2, name, *length ) == 0 )) ||
        ( !exact && ( snmp_oid_compare ( rName, vp->namelen + 2, name, *length ) >  0 ))) {
      switch ( vp->magic ) {
          case APSTATTXSPEEDVALUE:
          if ( ar->haveApStatTxSpeedValue  ) found = TRUE; break;
      }
    }
    if ( found )
      break;
  }

  if ( !found ) 
    return NULL;

  memcpy (( char * ) name, ( char * ) rName, ( vp->namelen + 2 ) * sizeof ( oid ));
  *length = vp->namelen + 2;
  *var_len = sizeof ( long );
  *write_method = NULL;

  switch ( vp->magic ) {

      case APSTATTXSPEEDVALUE :
	   return ( UCHAR * )&ar->apStatTxSpeedValue;
        
    default:
      ERROR_MSG ( "" );
  }

  return NULL;
}



unsigned char *
var_apStatRxSpeedTable(struct variable *vp,
    	    oid     *name,
    	    size_t  *length,
    	    int     exact,
    	    size_t  *var_len,
    	    WriteMethod **write_method)
{
  int found = FALSE;
  oid rName [ MAX_OID_LEN ];                            // OID to be returned
  static long long_ret;
  static u_long ulong_ret;
  static unsigned char string[STR_BUF];
  static oid objid[MAX_OID_LEN];
  static struct counter64 c64;
  AP_loadTables();
  memcpy (( char * ) rName, ( char * ) vp->name, ( int ) vp->namelen * sizeof ( oid ));
  for (np = LIST_FIRST ( &crList ); np != NULL; np = LIST_NEXT (np, nodes )) {
    cr = ( struct Cr_Tbl_data * ) np->data;
    rName[vp->namelen + 0] = cr->ifIndex;
    rName[vp->namelen + 1] = cr->apStatRxSpeedIndex;
    if ((  exact && ( snmp_oid_compare ( rName, vp->namelen + 2, name, *length ) == 0 )) ||
        ( !exact && ( snmp_oid_compare ( rName, vp->namelen + 2, name, *length ) >  0 ))) {
      switch ( vp->magic ) {
          case APSTATRXSPEEDVALUE:
          if ( cr->haveApStatRxSpeedValue  ) found = TRUE; break;
      }
    }
    if ( found )
      break;
  }

  if ( !found ) 
    return NULL;

  memcpy (( char * ) name, ( char * ) rName, ( vp->namelen + 2 ) * sizeof ( oid ));
  *length = vp->namelen + 2;
  *var_len = sizeof ( long );
  *write_method = NULL;

  switch ( vp->magic ) {

      case APSTATRXSPEEDVALUE :
	   return ( UCHAR * )&cr->apStatRxSpeedValue;
        
    default:
      ERROR_MSG ( "" );
  }

  return NULL;
}





unsigned char *
var_apStationSpeedTable(struct variable *vp,
    	    oid     *name,
    	    size_t  *length,
    	    int     exact,
    	    size_t  *var_len,
    	    WriteMethod **write_method)
{
  int found = FALSE;
  oid rName [ MAX_OID_LEN ];                            // OID to be returned
  static long long_ret;
  static u_long ulong_ret;
  static unsigned char string[STR_BUF];
  static oid objid[MAX_OID_LEN];
  static struct counter64 c64;
  AP_loadTables();
  memcpy (( char * ) rName, ( char * ) vp->name, ( int ) vp->namelen * sizeof ( oid ));
  for (np = LIST_FIRST ( &sdList ); np != NULL; np = LIST_NEXT (np, nodes )) {
    sd = ( struct Sd_Tbl_data * ) np->data;
    rName[vp->namelen + 0] = sd->ifIndex;
    rName[vp->namelen + 1] = sd->apStationSpeedIndex;
    if ((  exact && ( snmp_oid_compare ( rName, vp->namelen + 2, name, *length ) == 0 )) ||
        ( !exact && ( snmp_oid_compare ( rName, vp->namelen + 2, name, *length ) >  0 ))) {
      switch ( vp->magic ) {
          case APSTATIONSPEEDVALUE:
          if ( sd->haveApStationSpeedValue  ) found = TRUE; break;
      }
    }
    if ( found )
      break;
  }

  if ( !found ) 
    return NULL;

  memcpy (( char * ) name, ( char * ) rName, ( vp->namelen + 2 ) * sizeof ( oid ));
  *length = vp->namelen + 2;
  *var_len = sizeof ( long );
  *write_method = NULL;

  switch ( vp->magic ) {

      case APSTATIONSPEEDVALUE :
	   return ( UCHAR * )&sd->apStationSpeedValue;
        
    default:
      ERROR_MSG ( "" );
  }

  return NULL;
}





unsigned char *
var_apStatTxTrafficTable(struct variable *vp,
    	    oid     *name,
    	    size_t  *length,
    	    int     exact,
    	    size_t  *var_len,
    	    WriteMethod **write_method)
{
  int found = FALSE;
  oid rName [ MAX_OID_LEN ];                            // OID to be returned
  static long long_ret;
  static u_long ulong_ret;
  static unsigned char string[STR_BUF];
  static oid objid[MAX_OID_LEN];
  static struct counter64 c64;
  AP_loadTables();
  memcpy (( char * ) rName, ( char * ) vp->name, ( int ) vp->namelen * sizeof ( oid ));
  for (np = LIST_FIRST ( &txList ); np != NULL; np = LIST_NEXT (np, nodes )) {
    tx = ( struct Tx_Tbl_data * ) np->data;
    rName[vp->namelen + 0] = tx->ifIndex;
    rName[vp->namelen + 1] = tx->apStatTxTrafficIndex;
    if ((  exact && ( snmp_oid_compare ( rName, vp->namelen + 2, name, *length ) == 0 )) ||
        ( !exact && ( snmp_oid_compare ( rName, vp->namelen + 2, name, *length ) >  0 ))) {
      switch ( vp->magic ) {
          case APSTATTXTRAFFICVALUE:
          if ( tx->haveApStatTxTrafficValue  ) found = TRUE; break;
      }
    }
    if ( found )
      break;
  }

  if ( !found ) 
    return NULL;

  memcpy (( char * ) name, ( char * ) rName, ( vp->namelen + 2 ) * sizeof ( oid ));
  *length = vp->namelen + 2;
  *var_len = sizeof ( long );
  *write_method = NULL;

  switch ( vp->magic ) {

      case APSTATTXTRAFFICVALUE :
	   return ( UCHAR * )&tx->apStatTxTrafficValue;
        
    default:
      ERROR_MSG ( "" );
  }

  return NULL;
}




unsigned char *
var_apStatRxTrafficTable(struct variable *vp,
    	    oid     *name,
    	    size_t  *length,
    	    int     exact,
    	    size_t  *var_len,
    	    WriteMethod **write_method)
{
  int found = FALSE;
  oid rName [ MAX_OID_LEN ];                            // OID to be returned
  static long long_ret;
  static u_long ulong_ret;
  static unsigned char string[STR_BUF];
  static oid objid[MAX_OID_LEN];
  static struct counter64 c64;
 AP_loadTables();
  memcpy (( char * ) rName, ( char * ) vp->name, ( int ) vp->namelen * sizeof ( oid ));
  for (np = LIST_FIRST ( &rxList ); np != NULL; np = LIST_NEXT (np, nodes )) {
    rx = ( struct Rx_Tbl_data * ) np->data;
    rName[vp->namelen + 0] = rx->ifIndex;
    rName[vp->namelen + 1] = rx->apStatRxTrafficIndex;
    if ((  exact && ( snmp_oid_compare ( rName, vp->namelen + 2, name, *length ) == 0 )) ||
        ( !exact && ( snmp_oid_compare ( rName, vp->namelen + 2, name, *length ) >  0 ))) {
      switch ( vp->magic ) {
          case APSTATRXTRAFFICVALUE:
          if ( rx->haveApStatRxTrafficValue  ) found = TRUE; break;
      }
    }
    if ( found )
      break;
  }

  if ( !found ) 
    return NULL;

  memcpy (( char * ) name, ( char * ) rName, ( vp->namelen + 2 ) * sizeof ( oid ));
  *length = vp->namelen + 2;
  *var_len = sizeof ( long );
  *write_method = NULL;

  switch ( vp->magic ) {

      case APSTATRXTRAFFICVALUE :
	   return ( UCHAR * )&rx->apStatRxTrafficValue;
        
    default:
      ERROR_MSG ( "" );
  }

  return NULL;
}




unsigned char *
var_apStationTrafficTable(struct variable *vp,
    	    oid     *name,
    	    size_t  *length,
    	    int     exact,
    	    size_t  *var_len,
    	    WriteMethod **write_method)
{
  int found = FALSE;
  oid rName [ MAX_OID_LEN ];                            // OID to be returned
  static long long_ret;
  static u_long ulong_ret;
  static unsigned char string[STR_BUF];
  static oid objid[MAX_OID_LEN];
  static struct counter64 c64;
 AP_loadTables();
  memcpy (( char * ) rName, ( char * ) vp->name, ( int ) vp->namelen * sizeof ( oid ));
  for (np = LIST_FIRST ( &trList ); np != NULL; np = LIST_NEXT (np, nodes )) {
    tr = ( struct TR_Tbl_data * ) np->data;
    rName[vp->namelen + 0] = tr->ifIndex;
    rName[vp->namelen + 1] =tr->apStationTrafficIndex;
    if ((  exact && ( snmp_oid_compare ( rName, vp->namelen + 2, name, *length ) == 0 )) ||
        ( !exact && ( snmp_oid_compare ( rName, vp->namelen + 2, name, *length ) >  0 ))) {
      switch ( vp->magic ) {
          case APSTATIONTRAFFICVALUE:
          if ( tr->haveApStationTafficValue  ) found = TRUE; break;
      }
    }
    if ( found )
      break;
  }

  if ( !found ) 
    return NULL;

  memcpy (( char * ) name, ( char * ) rName, ( vp->namelen + 2 ) * sizeof ( oid ));
  *length = vp->namelen + 2;
  *var_len = sizeof ( long );
  *write_method = NULL;

  switch ( vp->magic ) {

      case APSTATIONTRAFFICVALUE :
	   return ( UCHAR * )& tr->apStationTrafficValue;
        
    default:
      ERROR_MSG ( "" );
  }

  return NULL;
}



 unsigned char *
 var_apStatRxErrPksTable(struct variable *vp,
    	    oid     *name,
    	    size_t  *length,
    	    int     exact,
    	    size_t  *var_len,
    	    WriteMethod **write_method)
{
  int found = FALSE;
  oid rName [ MAX_OID_LEN ];                            // OID to be returned
  static long long_ret;
  static u_long ulong_ret;
  static unsigned char string[STR_BUF];
  static oid objid[MAX_OID_LEN];
  static struct counter64 c64;
  AP_loadTables();
  memcpy (( char * ) rName, ( char * ) vp->name, ( int ) vp->namelen * sizeof ( oid ));
  for (np = LIST_FIRST ( &erList ); np != NULL; np = LIST_NEXT (np, nodes )) {
    er = ( struct Er_Tbl_data * ) np->data;
    rName[vp->namelen + 0] = er->ifIndex;
    rName[vp->namelen + 1] = er->apStatRxErrPksIndex;
    if ((  exact && ( snmp_oid_compare ( rName, vp->namelen + 2, name, *length ) == 0 )) ||
        ( !exact && ( snmp_oid_compare ( rName, vp->namelen + 2, name, *length ) >  0 ))) {
      switch ( vp->magic ) {
          case  APSTATRXERRPKSVALUE:
          if ( er->haveApStatRxErrPksValue  ) found = TRUE; break;
      }
    }
    if ( found )
      break;
  }

  if ( !found ) 
    return NULL;

  memcpy (( char * ) name, ( char * ) rName, ( vp->namelen + 2 ) * sizeof ( oid ));
  *length = vp->namelen + 2;
  *var_len = sizeof ( long );
  *write_method = NULL;

  switch ( vp->magic ) {

      case  APSTATRXERRPKSVALUE :
	   return ( UCHAR * )&er->apStatRxErrPksValue;
        
    default:
      ERROR_MSG ( "" );
  }

  return NULL;
}

 
 unsigned char *
 var_apStatRxSucPksTable(struct variable *vp,
    	    oid     *name,
    	    size_t  *length,
    	    int     exact,
    	    size_t  *var_len,
    	    WriteMethod **write_method)
{
  int found = FALSE;
  oid rName [ MAX_OID_LEN ];                            // OID to be returned
  static long long_ret;
  static u_long ulong_ret;
  static unsigned char string[STR_BUF];
  static oid objid[MAX_OID_LEN];
  static struct counter64 c64;
  AP_loadTables();
  memcpy (( char * ) rName, ( char * ) vp->name, ( int ) vp->namelen * sizeof ( oid ));
  for (np = LIST_FIRST ( &rkList ); np != NULL; np = LIST_NEXT (np, nodes )) {
    rk = ( struct Rk_Tbl_data * ) np->data;
    rName[vp->namelen + 0] = rk->ifIndex;
    rName[vp->namelen + 1] = rk->apStatRxSucPksIndex;
    if ((  exact && ( snmp_oid_compare ( rName, vp->namelen + 2, name, *length ) == 0 )) ||
        ( !exact && ( snmp_oid_compare ( rName, vp->namelen + 2, name, *length ) >  0 ))) {
      switch ( vp->magic ) {
          case APSTATRXSUCPKSVALUE:
          if ( rk->haveApStatRxSucPksValue  ) found = TRUE; break;
      }
    }
    if ( found )
      break;
  }

  if ( !found ) 
    return NULL;

  memcpy (( char * ) name, ( char * ) rName, ( vp->namelen + 2 ) * sizeof ( oid ));
  *length = vp->namelen + 2;
  *var_len = sizeof ( long );
  *write_method = NULL;

  switch ( vp->magic ) {

      case APSTATRXSUCPKSVALUE :
	   return ( UCHAR * )&rk->apStatRxSucPksValue;
        
    default:
      ERROR_MSG ( "" );
  }

  return NULL;
}

 
 unsigned char *
 var_apTxSignalPktsTable(struct variable *vp,
    	    oid     *name,
    	    size_t  *length,
    	    int     exact,
    	    size_t  *var_len,
    	    WriteMethod **write_method)
{
  int found = FALSE;
  oid rName [ MAX_OID_LEN ];                            // OID to be returned
  static long long_ret;
  static u_long ulong_ret;
  static unsigned char string[STR_BUF];
  static oid objid[MAX_OID_LEN];
  static struct counter64 c64;
  AP_loadTables();
  memcpy (( char * ) rName, ( char * ) vp->name, ( int ) vp->namelen * sizeof ( oid ));
  for (np = LIST_FIRST ( &sgList ); np != NULL; np = LIST_NEXT (np, nodes )) {
    sg = ( struct Sg_Tbl_data * ) np->data;
    rName[vp->namelen + 0] = sg->ifIndex;
    rName[vp->namelen + 1] = sg->apTxSignalPktsIndex;
    if ((  exact && ( snmp_oid_compare ( rName, vp->namelen + 2, name, *length ) == 0 )) ||
        ( !exact && ( snmp_oid_compare ( rName, vp->namelen + 2, name, *length ) >  0 ))) {
      switch ( vp->magic ) {
          case APTXSIGNALPKTSVALUE:
          if ( sg->haveapTxSignalPkts  ) found = TRUE; break;
      }
    }
    if ( found )
      break;
  }

  if ( !found ) 
    return NULL;

  memcpy (( char * ) name, ( char * ) rName, ( vp->namelen + 2 ) * sizeof ( oid ));
  *length = vp->namelen + 2;
  *var_len = sizeof ( long );
  *write_method = NULL;

  switch ( vp->magic ) {

      case APTXSIGNALPKTSVALUE :
	   return ( UCHAR * )&sg->apTxSignalPkts;
        
    default:
      ERROR_MSG ( "" );
  }

  return NULL;
}




 
 unsigned char *
 var_apRxSignalPktsTable(struct variable *vp,
    	    oid     *name,
    	    size_t  *length,
    	    int     exact,
    	    size_t  *var_len,
    	    WriteMethod **write_method)
{
  int found = FALSE;
  oid rName [ MAX_OID_LEN ];                            // OID to be returned
  static long long_ret;
  static u_long ulong_ret;
  static unsigned char string[STR_BUF];
  static oid objid[MAX_OID_LEN];
  static struct counter64 c64;
  AP_loadTables();
  memcpy (( char * ) rName, ( char * ) vp->name, ( int ) vp->namelen * sizeof ( oid ));
  for (np = LIST_FIRST ( &spList ); np != NULL; np = LIST_NEXT (np, nodes )) {
    sp = ( struct Sp_Tbl_data * ) np->data;
    rName[vp->namelen + 0] = sp->ifIndex;
    rName[vp->namelen + 1] = sp->apRxSignalPktsIndex;
    if ((  exact && ( snmp_oid_compare ( rName, vp->namelen + 2, name, *length ) == 0 )) ||
        ( !exact && ( snmp_oid_compare ( rName, vp->namelen + 2, name, *length ) >  0 ))) {
      switch ( vp->magic ) {
          case APRXSIGNALPKTSVALUE:
          if ( sp->haveapRxSignalPkts  ) found = TRUE; break;
      }
    }
    if ( found )
      break;
  }

  if ( !found ) 
    return NULL;

  memcpy (( char * ) name, ( char * ) rName, ( vp->namelen + 2 ) * sizeof ( oid ));
  *length = vp->namelen + 2;
  *var_len = sizeof ( long );
  *write_method = NULL;

  switch ( vp->magic ) {

      case APRXSIGNALPKTSVALUE :
	   return ( UCHAR * )&sp->apRxSignalPkts;
        
    default:
      ERROR_MSG ( "" );
  }

  return NULL;
}

 
 unsigned char *
 var_apSignalPktsTable(struct variable *vp,
    	    oid     *name,
    	    size_t  *length,
    	    int     exact,
    	    size_t  *var_len,
    	    WriteMethod **write_method)
{
  int found = FALSE;
  oid rName [ MAX_OID_LEN ];                            // OID to be returned
  static long long_ret;
  static u_long ulong_ret;
  static unsigned char string[STR_BUF];
  static oid objid[MAX_OID_LEN];
  static struct counter64 c64;
  AP_loadTables();
  memcpy (( char * ) rName, ( char * ) vp->name, ( int ) vp->namelen * sizeof ( oid ));
  for (np = LIST_FIRST ( &siList ); np != NULL; np = LIST_NEXT (np, nodes )) {
    si = ( struct Si_Tbl_data * ) np->data;
    rName[vp->namelen + 0] = si->ifIndex;
    rName[vp->namelen + 1] = si->apSignalPktsIndex;
    if ((  exact && ( snmp_oid_compare ( rName, vp->namelen + 2, name, *length ) == 0 )) ||
        ( !exact && ( snmp_oid_compare ( rName, vp->namelen + 2, name, *length ) >  0 ))) {
      switch ( vp->magic ) {
          case APSIGNALPKTSVALUE:
          if ( si->haveapSignalPkts  ) found = TRUE; break;
      }
    }
    if ( found )
      break;
  }

  if ( !found ) 
    return NULL;

  memcpy (( char * ) name, ( char * ) rName, ( vp->namelen + 2 ) * sizeof ( oid ));
  *length = vp->namelen + 2;
  *var_len = sizeof ( long );
  *write_method = NULL;

  switch ( vp->magic ) {

      case APSIGNALPKTSVALUE :
	   return ( UCHAR * )&si->apSignalPkts;
        
    default:
      ERROR_MSG ( "" );
  }

  return NULL;
}




 
 unsigned char *
 var_staWMMAttrTable(struct variable *vp,
    	    oid     *name,
    	    size_t  *length,
    	    int     exact,
    	    size_t  *var_len,
    	    WriteMethod **write_method)
{
  int found = FALSE;
  oid rName [ MAX_OID_LEN ];                            // OID to be returned
  static long long_ret;
  static u_long ulong_ret;
  static unsigned char string[STR_BUF];
  static oid objid[MAX_OID_LEN];
  static struct counter64 c64;
   static int retu_addr=0;
  AP_loadTables();
  memcpy (( char * ) rName, ( char * ) vp->name, ( int ) vp->namelen * sizeof ( oid ));
  for (np = LIST_FIRST ( &wmList ); np != NULL; np = LIST_NEXT (np, nodes )) {
    wm = ( struct Wm_Tbl_data * ) np->data;
    rName[vp->namelen + 0] = wm->ifIndex;
    rName[vp->namelen + 1] = wm->StaWMMAttrIndex;
    if ((  exact && ( snmp_oid_compare ( rName, vp->namelen + 2, name, *length ) == 0 )) ||
        ( !exact && ( snmp_oid_compare ( rName, vp->namelen + 2, name, *length ) >  0 ))) {
      switch ( vp->magic ) {
   	case STAWMMATTRVALUE:
          if ( wm->haveStaWMMAttr     ) found = TRUE; break;
      }
    }
    if ( found )
      break;
  }

  if ( !found ) 
    return NULL;

  memcpy (( char * ) name, ( char * ) rName, ( vp->namelen + 2 ) * sizeof ( oid ));
  *length = vp->namelen + 2;
  *var_len = sizeof ( long );
  *write_method = NULL;

  switch ( vp->magic ) {

   	case STAWMMATTRVALUE:
	 return ( UCHAR * )&wm->StaWMMAttr;
        
    default:
      ERROR_MSG ( "" );
  }

  return NULL;
}


 
 unsigned char *
 var_staIPAddressTable(struct variable *vp,
    	    oid     *name,
    	    size_t  *length,
    	    int     exact,
    	    size_t  *var_len,
    	    WriteMethod **write_method)
{
  int found = FALSE;
  oid rName [ MAX_OID_LEN ];                            // OID to be returned
  static long long_ret;
  static u_long ulong_ret;
  static unsigned char string[STR_BUF];
  static oid objid[MAX_OID_LEN];
  static struct counter64 c64;
   static int retu_addr=0;
  AP_loadTables();
  memcpy (( char * ) rName, ( char * ) vp->name, ( int ) vp->namelen * sizeof ( oid ));
  for (np = LIST_FIRST ( &ipList ); np != NULL; np = LIST_NEXT (np, nodes )) {
    ip = ( struct Ip_Tbl_data * ) np->data;
    rName[vp->namelen + 0] = ip->ifIndex;
    rName[vp->namelen + 1] = ip->StaIPAddressIndex;
    if ((  exact && ( snmp_oid_compare ( rName, vp->namelen + 2, name, *length ) == 0 )) ||
        ( !exact && ( snmp_oid_compare ( rName, vp->namelen + 2, name, *length ) >  0 ))) {
      switch ( vp->magic ) {
   	case STAIPADDRESSVALUE:
          if ( ip->haveStaIPAddress     ) found = TRUE; break;
      }
    }
    if ( found )
      break;
  }

  if ( !found ) 
    return NULL;

  memcpy (( char * ) name, ( char * ) rName, ( vp->namelen + 2 ) * sizeof ( oid ));
  *length = vp->namelen + 2;
  *var_len = sizeof ( long );
  *write_method = NULL;

  switch ( vp->magic ) {

   	case STAIPADDRESSVALUE:
	   retu_addr=inet_addr(ip->StaIPAddress);
	  *var_len = 4;      
	   return ( UCHAR * )&retu_addr;
        
    default:
      ERROR_MSG ( "" );
  }

  return NULL;
}




 
 unsigned char *
 var_staUplinkMaxRateTable(struct variable *vp,
    	    oid     *name,
    	    size_t  *length,
    	    int     exact,
    	    size_t  *var_len,
    	    WriteMethod **write_method)
{
  int found = FALSE;
  oid rName [ MAX_OID_LEN ];                            // OID to be returned
  static long long_ret;
  static u_long ulong_ret;
  static unsigned char string[STR_BUF];
  static oid objid[MAX_OID_LEN];
  static struct counter64 c64;
   static int retu_addr=0;
  AP_loadTables();
  memcpy (( char * ) rName, ( char * ) vp->name, ( int ) vp->namelen * sizeof ( oid ));
  for (np = LIST_FIRST ( &suList ); np != NULL; np = LIST_NEXT (np, nodes )) {
    su = ( struct Su_Tbl_data * ) np->data;
    rName[vp->namelen + 0] = su->ifIndex;
    rName[vp->namelen + 1] = su->StaUplinkMaxRateIndex;
    if ((  exact && ( snmp_oid_compare ( rName, vp->namelen + 2, name, *length ) == 0 )) ||
        ( !exact && ( snmp_oid_compare ( rName, vp->namelen + 2, name, *length ) >  0 ))) {
      switch ( vp->magic ) {
   	case STAUPLINKMAXRATEVALUE:
          if ( su->haveStaUplinkMaxRate     ) found = TRUE; break;
      }
    }
    if ( found )
      break;
  }

  if ( !found ) 
    return NULL;

  memcpy (( char * ) name, ( char * ) rName, ( vp->namelen + 2 ) * sizeof ( oid ));
  *length = vp->namelen + 2;
  *var_len = sizeof ( long );
  *write_method = NULL;

  switch ( vp->magic ) {

   	case STAUPLINKMAXRATEVALUE:
	   return ( UCHAR * )&su->StaUplinkMaxRate;
        
    default:
      ERROR_MSG ( "" );
  }

  return NULL;
}



 
 unsigned char *
 var_staDwlinkMaxRateTable(struct variable *vp,
    	    oid     *name,
    	    size_t  *length,
    	    int     exact,
    	    size_t  *var_len,
    	    WriteMethod **write_method)
{
  int found = FALSE;
  oid rName [ MAX_OID_LEN ];                            // OID to be returned
  static long long_ret;
  static u_long ulong_ret;
  static unsigned char string[STR_BUF];
  static oid objid[MAX_OID_LEN];
  static struct counter64 c64;
   static int retu_addr=0;
  AP_loadTables();
  memcpy (( char * ) rName, ( char * ) vp->name, ( int ) vp->namelen * sizeof ( oid ));
  for (np = LIST_FIRST ( &skList ); np != NULL; np = LIST_NEXT (np, nodes )) {
    sk = ( struct Sk_Tbl_data * ) np->data;
    rName[vp->namelen + 0] = sk->ifIndex;
    rName[vp->namelen + 1] = sk->StaDwlinkMaxRateIndex;
    if ((  exact && ( snmp_oid_compare ( rName, vp->namelen + 2, name, *length ) == 0 )) ||
        ( !exact && ( snmp_oid_compare ( rName, vp->namelen + 2, name, *length ) >  0 ))) {
      switch ( vp->magic ) {
   	case STADWLINKMAXRATEVALUE:
          if ( sk->haveStaDwlinkMaxRate     ) found = TRUE; break;
      }
    }
    if ( found )
      break;
  }

  if ( !found ) 
    return NULL;

  memcpy (( char * ) name, ( char * ) rName, ( vp->namelen + 2 ) * sizeof ( oid ));
  *length = vp->namelen + 2;
  *var_len = sizeof ( long );
  *write_method = NULL;

  switch ( vp->magic ) {

   	case STADWLINKMAXRATEVALUE:
	   return ( UCHAR * )&sk->StaDwlinkMaxRate;
        
    default:
      ERROR_MSG ( "" );
  }

  return NULL;
}



 
 unsigned char *
 var_staPowerSaveModeTable(struct variable *vp,
    	    oid     *name,
    	    size_t  *length,
    	    int     exact,
    	    size_t  *var_len,
    	    WriteMethod **write_method)
{
  int found = FALSE;
  oid rName [ MAX_OID_LEN ];                            // OID to be returned
  static long long_ret;
  static u_long ulong_ret;
  static unsigned char string[STR_BUF];
  static oid objid[MAX_OID_LEN];
  static struct counter64 c64;
   static int retu_addr=0;
  AP_loadTables();
  memcpy (( char * ) rName, ( char * ) vp->name, ( int ) vp->namelen * sizeof ( oid ));
  for (np = LIST_FIRST ( &psList ); np != NULL; np = LIST_NEXT (np, nodes )) {
    ps = ( struct Ps_Tbl_data * ) np->data;
    rName[vp->namelen + 0] = ps->ifIndex;
    rName[vp->namelen + 1] = ps->StaPowerSaveModeIndex;
    if ((  exact && ( snmp_oid_compare ( rName, vp->namelen + 2, name, *length ) == 0 )) ||
        ( !exact && ( snmp_oid_compare ( rName, vp->namelen + 2, name, *length ) >  0 ))) {
      switch ( vp->magic ) {
   	case STAPOWERSAVEMODEVALUE:
          if ( ps->haveStaPowerSaveMode     ) found = TRUE; break;
      }
    }
    if ( found )
      break;
  }

  if ( !found ) 
    return NULL;

  memcpy (( char * ) name, ( char * ) rName, ( vp->namelen + 2 ) * sizeof ( oid ));
  *length = vp->namelen + 2;
  *var_len = sizeof ( long );
  *write_method = NULL;

  switch ( vp->magic ) {

   	case STAPOWERSAVEMODEVALUE:
	   return ( UCHAR * )&ps->StaPowerSaveMode;
        
    default:
      ERROR_MSG ( "" );
  }

  return NULL;
}



unsigned char *
var_apRadioChannelTable(struct variable *vp,
    	    oid     *name,
    	    size_t  *length,
    	    int     exact,
    	    size_t  *var_len,
    	    WriteMethod **write_method)
{
    int found = FALSE;
    oid rName [ MAX_OID_LEN ];
	
    static long long_ret;
    static u_long ulong_ret;
    static unsigned char string[STR_BUF];
    static oid objid[MAX_OID_LEN];
    static struct counter64 c64;
  AP_loadTables();
  memcpy (( char * ) rName, ( char * ) vp->name, ( int ) vp->namelen * sizeof ( oid ));
  for ( np = LIST_FIRST ( &rcList ); np != NULL; np = LIST_NEXT ( np, nodes )) {
    rc = ( struct Rc_Tbl_data * ) np->data;
    rName[vp->namelen] = rc->ifIndex;
    if ((  exact && ( snmp_oid_compare ( rName, vp->namelen + 1, name, *length ) == 0 )) || 
        ( !exact && ( snmp_oid_compare ( rName, vp->namelen + 1, name, *length ) >  0 ))) {

   switch ( vp->magic ) {
        case CHANAUTOSELECTENABLE:
          if ( rc->haveChanAutoSelectEnable     ) found = TRUE; break;
   	case RADIOCHANNELCONFIG:
          if ( rc->haveRadioChannelConfig     ) found = TRUE; break;
	case RADIOCHANNELUSING:
          if ( rc->haveRadioChannelUsing     ) found = TRUE; break;
       case TRANSMITSPEEDCONFIG:
          if ( rc->haveTransmitSpeedConfig          ) found = TRUE; break;
    case MAXTXPWRLVL:
          if (rc->haveMaxTxPwrLvl     ) found = TRUE; break;
	case PWRATTRANGE:	 
          if (rc->havePwrAttRange     ) found = TRUE; break;
	case ANTENNAGAIN:
          if ( rc->haveAntennaGain                  ) found = TRUE; break;
	case POWERMGMTENABLE:
          if ( rc->havePowerMgmtEnable          ) found = TRUE; break;
       case MAXSTATIONNUMPERMITTED:
          if ( rc->haveMaxStationNumPermitted ) found = TRUE; break;
      }
    }
    if ( found )
      break;
  }

  if ( !found ) 
    return NULL;

  memcpy (( char * ) name, ( char * ) rName, ( vp->namelen + 1 ) * sizeof ( oid ));
  *length = vp->namelen + 1;
  *var_len = sizeof ( long );
  *write_method = NULL;

    /* 
   * this is where we do the value assignments for the mib results.
   */
    switch(vp->magic) {

        case CHANAUTOSELECTENABLE:
        *write_method = write_ChanAutoSelectEnable;
         return ( UCHAR * )& rc->ChanAutoSelectEnable ;
		 
   	case RADIOCHANNELCONFIG:
        *write_method = write_RadioChannelConfig;
         return ( UCHAR * )& rc->RadioChannelConfig ;
		 
	case RADIOCHANNELUSING:
         return ( UCHAR * )& rc->RadioChannelUsing ;
		 
       case TRANSMITSPEEDCONFIG:
        *write_method = write_TransmitSpeedConfig;
	 *var_len = strlen ( rc->TransmitSpeedConfig  );		
         return ( UCHAR * )rc->TransmitSpeedConfig ;
		 
       case MAXTXPWRLVL:
         return ( UCHAR * )&rc->MaxTxPwrLvl ;
		 
 	case PWRATTRANGE:
         return ( UCHAR * )& rc->PwrAttRange ;
		 
	case ANTENNAGAIN:
         return ( UCHAR * )&rc->AntennaGain ;
		 
	case POWERMGMTENABLE:
		*write_method = write_PowerMgmtEnable;
         return ( UCHAR * )&rc->PowerMgmtEnable ;
		 
      case MAXSTATIONNUMPERMITTED:
        *write_method = write_MaxStationNumPermitted;
         return ( UCHAR * )&rc->MaxStationNumPermitted ;
	default:
      ERROR_MSG("");
    }
    return NULL;
}



unsigned char *
var_apStationInfoTable(struct variable *vp,
    	    oid     *name,
    	    size_t  *length,
    	    int     exact,
    	    size_t  *var_len,
    	    WriteMethod **write_method)
{
    int found = FALSE;
    oid rName [ MAX_OID_LEN ];
	
    static long long_ret;
    static u_long ulong_ret;
    static unsigned char string[STR_BUF];
    static oid objid[MAX_OID_LEN];
    static struct counter64 c64;
  AP_loadTables();
  memcpy (( char * ) rName, ( char * ) vp->name, ( int ) vp->namelen * sizeof ( oid ));
  for ( np = LIST_FIRST ( &snList ); np != NULL; np = LIST_NEXT ( np, nodes )) {
    sn = ( struct Sn_Tbl_data * ) np->data;
    rName[vp->namelen] = sn->ifIndex;
    if ((  exact && ( snmp_oid_compare ( rName, vp->namelen + 1, name, *length ) == 0 )) || 
        ( !exact && ( snmp_oid_compare ( rName, vp->namelen + 1, name, *length ) >  0 ))) {

   switch ( vp->magic ) {
	case STARADIOMODE:
          if ( sn->haveStaRadioMode     ) found = TRUE; break;
       case STARADIOCHANNEL:
          if ( sn->haveStaRadioChannel          ) found = TRUE; break;
	case STAVLANID:
          if ( sn->haveStaVlanId                  ) found = TRUE; break;
       case STASSIDNAME:
          if ( sn->haveStaSSIDName                  ) found = TRUE; break;
	case STAAUTHENMODE:
          if ( sn->haveStaAuthenMode          ) found = TRUE; break;
	case STASECURITYCIPHERS:
          if ( sn->haveStaSecurityCiphers          ) found = TRUE; break;
      }
    }
    if ( found )
      break;
  }

  if ( !found ) 
    return NULL;

  memcpy (( char * ) name, ( char * ) rName, ( vp->namelen + 1 ) * sizeof ( oid ));
  *length = vp->namelen + 1;
  *var_len = sizeof ( long );
  *write_method = NULL;

    /* 
   * this is where we do the value assignments for the mib results.
   */
    switch(vp->magic) {
		 		 
	case STARADIOMODE:
         return ( UCHAR * )&sn->StaRadioMode ;
		 
       case STARADIOCHANNEL:
         return ( UCHAR * )&sn->StaRadioChannel ;
		 
	case STAVLANID:
         return ( UCHAR * )&sn->StaVlanId ;
		 
       case STASSIDNAME:
	 *var_len = strlen (sn->StaSSIDName);		
         return ( UCHAR * )sn->StaSSIDName ;
		 
	case STAAUTHENMODE:
         return ( UCHAR * )&sn->StaAuthenMode ;
		 
	case STASECURITYCIPHERS:
         return ( UCHAR * )&sn->StaSecurityCiphers ;
		  
	default:
      ERROR_MSG("");
    }
    return NULL;
}



int
write_SSIDEnabled(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
     char string[SNMP_STR_LEN];
     static long  long_ret;
     int size;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to stationAp not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to stationAp: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
	      long_ret  =*((long *) var_val);
	 if((long_ret!=0)&&(long_ret!=1)){
              fprintf(stderr,"write to stationAp: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
		memset( string, 0, SNMP_STR_LEN);
		memset(nAc.ifName,0,IFNAME_LEN + 1);
		nAc.ifIndex=name[name_len-1];
               printf("nAc.ifIndex==%d\n",nAc.ifIndex);
		if_indextoname(nAc.ifIndex,nAc.ifName);
		if(long_ret==1)
		{strcpy(string,"yes");}
		else 
		{strcpy(string,"no");}
		wireless_config_enable(get_vnum_by_vname( nAc.ifName),string);
        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}



int
write_SSIDHidden(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
     char string[SNMP_STR_LEN];
     static long  long_ret;
     int size;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to stationAp not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to stationAp: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
	      long_ret  =*((long *) var_val);
	 if((long_ret!=0)&&(long_ret!=1)){
              fprintf(stderr,"write to stationAp: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
		memset( string, 0, SNMP_STR_LEN);
		memset(nAc.ifName,0,IFNAME_LEN + 1);
		nAc.ifIndex=name[name_len-1];
               printf("nAc.ifIndex==%d\n",nAc.ifIndex);
		if_indextoname(nAc.ifIndex,nAc.ifName);
		sprintf(string,"%s  %s  %s  %d","/usr/sbin/iwpriv",nAc.ifName,"hide_ssid",long_ret);
		printf("string:%s\n",string);
	       system(string);

      /*   if(long_ret==1)
		{strcpy(string,"yes");}
		else 
		{strcpy(string,"no");}
             wireless_config_hidessid( get_vnum_by_vname( nAc.ifName ),string);
      */
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}




int
write_StaIsolate(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
     char string[SNMP_STR_LEN];
     static long  long_ret;
     int size;
 switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to stationAp not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to stationAp: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
	      long_ret  =*(long *) var_val;
	 if((long_ret!=0)&&(long_ret!=1)){
              fprintf(stderr,"write to stationAp: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
		  
          break;

        case RESERVE2:
         // size  = var_val_len; 
	  // value = * (long *) var_val;

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
		memset( string, 0, SNMP_STR_LEN);
		memset(nAc.ifName,0,IFNAME_LEN + 1);
		nAc.ifIndex=name[name_len-1];
               printf("nAc.ifIndex==%d\n",nAc.ifIndex);
		if_indextoname(nAc.ifIndex,nAc.ifName);
	        sprintf( string, "%s %s %s %ld", "/usr/sbin/iwpriv",nAc.ifName, "ap_bridge",1-long_ret );
			printf("string:%s\n",string);
               system(string);
			break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_EAPAuthenSupport(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
     char string[SNMP_STR_LEN];
     char value[SNMP_STR_LEN];
     static long  long_ret;
     int size;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to stationAp not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to stationAp: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
	      long_ret  =*((long *) var_val);
	    if((long_ret!=0)&&(long_ret!=1)){
              fprintf(stderr,"write to stationAp: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
	 	}
          break;

        case RESERVE2:
         // size  = var_val_len;
        //  value = * (long *) var_val;

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
		memset(string,0,SNMP_STR_LEN);
		memset(value,0,SNMP_STR_LEN);
		memset(nAc.ifName,0,IFNAME_LEN + 1);
		nAc.ifIndex=name[name_len-1];
               printf("nAc.ifIndex==%d\n",nAc.ifIndex);
		if_indextoname(nAc.ifIndex,nAc.ifName);
		sprintf(string,"%s%s",nAc.ifName,"_EAP");
		sprintf(value,"%d",long_ret);
	       save_global_conf(SEP_EQUAL,SNMP_AGENT_CONF,"",string,value);


          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}




int
write_apMaxSimultUsers(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    char value[SNMP_STR_LEN];
    static long  long_ret;
    int size;
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to stationAp not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to stationAp: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
	long_ret = *((long *) var_val);
       if ((long_ret < 0)||(long_ret > 128)) 
	   	{
            fprintf(stderr, "write to stationAp:bad value\n");
            return SNMP_ERR_WRONGVALUE;
        }

          break;

        case RESERVE2:
          //size  = var_val_len;
          //value = * (char *) var_val;

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
		memset(value,0,SNMP_STR_LEN);
		memset(nAc.ifName,0,IFNAME_LEN + 1);
		for(size=0;size<name_len;size++)
		{
		printf("name[%d]%d\n",size,name[size]);
		}
		nAc.ifIndex=name[name_len-1];
               printf("nAc.ifIndex==%d\n",nAc.ifIndex);
		if_indextoname(nAc.ifIndex,nAc.ifName);
		sprintf(value,"%d",long_ret);
              wireless_config_maxsimultusers(get_vnum_by_vname(nAc.ifName), value);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}
int
write_apBGmode(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    char value[SNMP_STR_LEN];
    int size;
    static long  long_ret;
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to stationAp not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(value)) {
              fprintf(stderr,"write to stationAp: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
	  long_ret = *((long *) var_val);
         if ((long_ret !=1)&&(long_ret !=2)&&(long_ret!=4) \
  	  &&(long_ret!=6)&&(long_ret!=8)&&(long_ret!=16)){
            fprintf(stderr, "write to stationAp:bad value\n");
            return SNMP_ERR_WRONGVALUE;
        }
          break;

        case RESERVE2:
         // size  = var_val_len;
         // value = * (char *) var_val;

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
		 memset(value,0,SNMP_STR_LEN);
		for(size=0;size<name_len;size++)
		{
		printf("name[%d]%d\n",size,name[size]);
		}
		memset(nAc.ifName,0,IFNAME_LEN + 1);
		nAc.ifIndex=name[name_len-1];
               printf("nAc.ifIndex==%d\n",nAc.ifIndex);
		if_indextoname(nAc.ifIndex,nAc.ifName);
	      if(long_ret==2)
		{strcpy(value,"11b");}
	      else  if(long_ret==6)
	       {strcpy(value,"11g");}
		wireless_config_channel( get_vnum_by_vname(nAc.ifName), "0" );
	        wireless_config_mode( get_vnum_by_vname(nAc.ifName), value );
            
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}



int
write_vapFlag(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
     static unsigned  char value[SNMP_STR_LEN ];
     static unsigned char string[STR_BUF];
	int size=0;
	int i=0;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to stationAp not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(value)) {
              fprintf(stderr,"write to stationAp: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
         // size  = var_val_len;
         // value = * (char *) var_val;

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
		for(size=0;size<name_len;size++)
		{
		printf("name[%d]%d\n",size,name[size]);
		}
		memset(nAc.ifName,0,IFNAME_LEN + 1);
		nAc.ifIndex=name[name_len-1];
               printf("nAc.ifIndex==%d\n",nAc.ifIndex);
		if_indextoname(nAc.ifIndex,nAc.ifName);
	       memset(value,0,SNMP_STR_LEN);
	       memset(string,0,STR_BUF);
		memcpy(value,var_val,var_val_len);
		value[var_val_len]='\0';
		sprintf(string,"%s  %s  %s  %s","/usr/sbin/autelan   traffic_limit ",nAc.ifName,"set_vap_flag",value);
		system(string);
            
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_vapTraffic(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
      static unsigned  char value[SNMP_STR_LEN ];
     static unsigned char string[STR_BUF];
      int size;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to stationAp not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(value)) {
              fprintf(stderr,"write to stationAp: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
         // size  = var_val_len;
         // value = * (char *) var_val;

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
		for(size=0;size<name_len;size++)
		{
		printf("name[%d]%d\n",size,name[size]);
		}
		memset(nAc.ifName,0,IFNAME_LEN + 1);
		nAc.ifIndex=name[name_len-1];
               printf("nAc.ifIndex==%d\n",nAc.ifIndex);
		if_indextoname(nAc.ifIndex,nAc.ifName);

               memset(value,0,SNMP_STR_LEN);
               memset(string,0,STR_BUF);
		memcpy(value,var_val,var_val_len);
		value[var_val_len]='\0';
		sprintf(string,"%s  %s  %s  %s","/usr/sbin/autelan   traffic_limit ",nAc.ifName,"set_vap",value);
		system(string);
		
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_everyNodeFlag(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
     static unsigned  char value[STR_BUF ];
     static unsigned  char string[STR_BUF];
     int size;
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to stationAp not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(value)) {
              fprintf(stderr,"write to stationAp: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
         // size  = var_val_len;
         // value = * (char *) var_val;

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
		for(size=0;size<name_len;size++)
		{
		printf("name[%d]%d\n",size,name[size]);
		}
		memset(nAc.ifName,0,IFNAME_LEN + 1);
		nAc.ifIndex=name[name_len-1];
               printf("nAc.ifIndex==%d\n",nAc.ifIndex);
		if_indextoname(nAc.ifIndex,nAc.ifName);
              memset(string,0,STR_BUF);
               memset(value,0,STR_BUF);
		memcpy(value,var_val,var_val_len);
		value[var_val_len]='\0';
		sprintf(string,"%s  %s  %s  %s","/usr/sbin/autelan   traffic_limit ",nAc.ifName,"set_every_node_flag",value);
		system(string);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_everyNodeTraffic(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    static unsigned  char value[STR_BUF ];
    static unsigned char  string[STR_BUF];
    int  size;
	
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to stationAp not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(value)) {
              fprintf(stderr,"write to stationAp: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
         // size  = var_val_len;
         // value = * (char *) var_val;

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
		for(size=0;size<name_len;size++)
		{
		printf("name[%d]%d\n",size,name[size]);
		}
		memset(nAc.ifName,0,IFNAME_LEN + 1);
		nAc.ifIndex=name[name_len-1];
               printf("nAc.ifIndex==%d\n",nAc.ifIndex);
		if_indextoname(nAc.ifIndex,nAc.ifName);
              memset(value,0,STR_BUF);
              memset(string,0,STR_BUF);
 		memcpy(value,var_val,var_val_len);
		value[var_val_len]='\0';
		printf("string:%s\n",string);
		sprintf(string,"%s  %s  %s  %s","/usr/sbin/autelan   traffic_limit ", nAc.ifName,"set_every_node",value);
		printf("string:%s\n",string);
		system(string);

		
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}



int
write_specificNodeFlag(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
     static unsigned  char value[STR_BUF];
     static unsigned char  string[STR_BUF];
    int  size;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to stationAp not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(value)) {
              fprintf(stderr,"write to stationAp: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
         // size  = var_val_len;
         // value = * (char *) var_val;

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
		for(size=0;size<name_len;size++)
		{
		printf("name[%d]%d\n",size,name[size]);
		}
		memset(nAc.ifName,0,IFNAME_LEN + 1);
		nAc.ifIndex=name[name_len-1];
               printf("nAc.ifIndex==%d\n",nAc.ifIndex);
		if_indextoname(nAc.ifIndex,nAc.ifName);
              memset(value,0,STR_BUF);
              memset(string,0,STR_BUF);
		memcpy(value,var_val,var_val_len);
		value[var_val_len]='\0';
		sprintf(string,"%s  %s  %s  %s","/usr/sbin/autelan   traffic_limit ",nAc.ifName,"set_specific_node_flag",value);
		system(string);

          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}



int
write_specificNodeTraffic(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
     static unsigned  char value[SNMP_STR_LEN ];
     static unsigned char string[STR_BUF];
    int size;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to stationAp not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(value)) {
              fprintf(stderr,"write to stationAp: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
       //   size  = var_val_len;
        //  value = * (char *) var_val;

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
            
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_SSIDindex(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    char  value[SNMP_STR_LEN];
    char  string[SNMP_STR_LEN];
    long long_ret;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to stationAp not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to stationAp: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
	   long_ret=* ((long *) var_val);
          break;

        case RESERVE2:

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
		memset(value,0,SNMP_STR_LEN);
		memset(string,0,SNMP_STR_LEN);
		memset(nAc.ifName,0,IFNAME_LEN + 1);
		nAc.ifIndex=name[name_len-1];
               printf("nAc.ifIndex==%d\n",nAc.ifIndex);
		if_indextoname(nAc.ifIndex,nAc.ifName);
		sprintf(string,"%s%s",nAc.ifName,"_SSIDINDEX");
		sprintf(value,"%d",long_ret );
	       save_global_conf(SEP_EQUAL,SNMP_AGENT_CONF,"",string,value);

	break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_apFloodDetectSwitch(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
     char string[SNMP_STR_LEN];
     static long  long_ret;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to stationAp not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to stationAp: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
	      long_ret  =*((long *) var_val);
	 if((long_ret!=0)&&(long_ret!=1)){
              fprintf(stderr,"write to stationAp: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
	       memset(string,0,SNMP_STR_LEN);
		memset(nAc.ifName,0,IFNAME_LEN + 1);
		nAc.ifIndex=name[name_len-1];
              printf("nAc.ifIndex==%d\n",nAc.ifIndex);
		if_indextoname(nAc.ifIndex,nAc.ifName);
		sprintf(string,"%s  %s  %s  %d","/usr/sbin/iwpriv",nAc.ifName,"flood_detect",long_ret);
		system(string);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_apSpoofDetectSwitch(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
     char string[SNMP_STR_LEN];
     static long  long_ret;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to stationAp not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to stationAp: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
	      long_ret  =*((long *) var_val);
	 if((long_ret!=0)&&(long_ret!=1)){
              fprintf(stderr,"write to stationAp: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
	       memset(string,0,SNMP_STR_LEN);
		memset(nAc.ifName,0,IFNAME_LEN + 1);
		nAc.ifIndex=name[name_len-1];
              printf("nAc.ifIndex==%d\n",nAc.ifIndex);
		if_indextoname(nAc.ifIndex,nAc.ifName);
		sprintf(string,"%s  %s  %s  %d","/usr/sbin/iwpriv",nAc.ifName,"spoof_detect",long_ret);
		system(string);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_apWKIVDectectSwitch(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
     char string[SNMP_STR_LEN];
     static long  long_ret;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to stationAp not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to stationAp: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
	      long_ret  =*((long *) var_val);
	 if((long_ret!=0)&&(long_ret!=1)){
              fprintf(stderr,"write to stationAp: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
	       memset(string,0,SNMP_STR_LEN);
		memset(nAc.ifName,0,IFNAME_LEN + 1);
		nAc.ifIndex=name[name_len-1];
              printf("nAc.ifIndex==%d\n",nAc.ifIndex);
		if_indextoname(nAc.ifIndex,nAc.ifName);
		sprintf(string,"%s  %s  %s  %d","/usr/sbin/iwpriv",nAc.ifName,"wk_iv_detect",long_ret);
		system(string);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_apClearAttackHistory(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
     char string[SNMP_STR_LEN];
     static long  long_ret;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to stationAp not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to stationAp: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
	      long_ret  =*((long *) var_val);
	 if(long_ret!=1){
              fprintf(stderr,"write to stationAp: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
	       memset(string,0,SNMP_STR_LEN);
		memset(nAc.ifName,0,IFNAME_LEN + 1);
		nAc.ifIndex=name[name_len-1];
              printf("nAc.ifIndex==%d\n",nAc.ifIndex);
		if_indextoname(nAc.ifIndex,nAc.ifName);
		sprintf(string,"%s  %s  %s  %d","/usr/sbin/iwpriv",nAc.ifName,"clr_atk_his",long_ret);
		system(string);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_apClearIllegalHistory(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
     char string[SNMP_STR_LEN];
     static long  long_ret;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to stationAp not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to stationAp: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
	      long_ret  =*((long *) var_val);
	 if(long_ret!=1){
              fprintf(stderr,"write to stationAp: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
	       memset(string,0,SNMP_STR_LEN);
		memset(nAc.ifName,0,IFNAME_LEN + 1);
		nAc.ifIndex=name[name_len-1];
              printf("nAc.ifIndex==%d\n",nAc.ifIndex);
		if_indextoname(nAc.ifIndex,nAc.ifName);
		sprintf(string,"%s  %s  %s  %d","/usr/sbin/iwpriv",nAc.ifName,"clr_illdev_his",long_ret);
		system(string);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_apClearAttackStatistics(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
     char string[SNMP_STR_LEN];
     static long  long_ret;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to stationAp not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to stationAp: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
	      long_ret  =*((long *) var_val);
	 if(long_ret!=1){
              fprintf(stderr,"write to stationAp: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
	       memset(string,0,SNMP_STR_LEN);
		memset(nAc.ifName,0,IFNAME_LEN + 1);
		nAc.ifIndex=name[name_len-1];
              printf("nAc.ifIndex==%d\n",nAc.ifIndex);
		if_indextoname(nAc.ifIndex,nAc.ifName);
		sprintf(string,"%s  %s  %s  %d","/usr/sbin/iwpriv",nAc.ifName,"clr_atk_stat",long_ret);
		system(string);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_apSecurityType(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    static long  long_ret;
    static char string[128];
    int size;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to stationAp not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long_ret)) {
              fprintf(stderr,"write to stationAp: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }

	  long_ret = *((long *) var_val);
	      if ((long_ret < 1)||(long_ret > 9)) {
            fprintf(stderr, "write to dot11DTIMPeriod:bad value\n");
            return SNMP_ERR_WRONGVALUE;
        }
          break;

        case RESERVE2:
         // size  = var_val_len;
          //value = * (char *) var_val;

          break;

        case FREE:
          break;

        case ACTION:
		memset(nSe.ifName,0,IFNAME_LEN + 1);
		nSe.ifIndex=name[name_len-1];
               printf("nSe.ifIndex==%d\n",nSe.ifIndex);
	        if_indextoname(nSe.ifIndex,nSe.ifName);
		if(long_ret==1)
			{
				memset(string,0,128);
				strcpy(string,"none");
			}
		else if (long_ret>=2&&long_ret<=4)
			{
				memset(string,0,128);
				strcpy(string,"wep");
			 }
		else if(long_ret>=5&&long_ret<=8)
			{
				memset(string,0,128);
				strcpy(string,"wpa");
			 }
		printf("security type:string:%s\n",string);
		wireless_sec_set_type( get_vnum_by_vname(nSe.ifName ),string );
            
          break;

        case UNDO:
          break;

        case COMMIT:
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_apwpaAuthMode(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long  long_ret;
    char string[SNMP_STR_LEN];

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to stationAp not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to stationAp: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          long_ret = * (long *) var_val;
	  if((long_ret!=1)&&(long_ret!=2))
          {
              fprintf(stderr,"write to stationAp: bad value\n");
              return SNMP_ERR_WRONGVALUE;
          }

          break;

        case RESERVE2:
          //size  = var_val_len;
          //value = * (long *) var_val;

          break;

        case FREE:
          break;

        case ACTION:
		memset(nSe.ifName,0,IFNAME_LEN + 1);
		memset(string,0,SNMP_STR_LEN);
		nSe.ifIndex=name[name_len-1];
               printf("nSe.ifIndex==%d\n",nSe.ifIndex);
	        if_indextoname(nSe.ifIndex,nSe.ifName);
		if(long_ret==1)
		{strcpy(string,"psk");}
		else
		{strcpy(string,"802.1x");}
              wireless_sec_set_mode(get_vnum_by_vname( nSe.ifName ), string,1);          
                           
          break;

        case UNDO:
          break;

        case COMMIT:
          break;
    }
    return SNMP_ERR_NOERROR;
}





int
write_apwpaCipher(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long  long_ret;
    char value[SNMP_STR_LEN];

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to stationAp not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to stationAp: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
	   long_ret = *((long *) var_val);
	   if ((long_ret!=1)&&(long_ret!=2))
	   	{
	   	  fprintf(stderr,"write to stationAp: bad  value\n");
                return SNMP_ERR_WRONGVALUE;
	   	}
          break;

        case RESERVE2:

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
		memset(nSe.ifName,0,IFNAME_LEN + 1);
		memset(value,0,SNMP_STR_LEN);
		nSe.ifIndex=name[name_len-1];
               printf("nSe.ifIndex==%d\n",nSe.ifIndex);
	        if_indextoname(nSe.ifIndex,nSe.ifName);
		if(long_ret==1)
		{strcpy(value,"TKIP");}
		else
		{strcpy(value,"AES");}
		printf("value:%s\n",value);
		wireless_sec_set_wpaencrypt(get_vnum_by_vname( nSe.ifName ),value,1);
		

          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_apwpaKeyValue(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    char  value[SNMP_STR_LEN];
    long  long_ret;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to stationAp not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len >128*sizeof(char)) {
              fprintf(stderr,"write to stationAp: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
		memset(nSe.ifName,0,IFNAME_LEN + 1);
		memset(value,0,SNMP_STR_LEN);
		nSe.ifIndex=name[name_len-1];
               printf("nSe.ifIndex==%d\n",nSe.ifIndex);
	        if_indextoname(nSe.ifIndex,nSe.ifName);
          	memcpy(value,var_val,var_val_len);
		value[var_val_len]='\0';
		wireless_sec_set_wpakey(get_vnum_by_vname( nSe.ifName ),value,1);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}



int
write_apwepAuthMode(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    char  value[SNMP_STR_LEN];
    long  long_ret;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to stationAp not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to stationAp: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
	   long_ret = *((long *) var_val);
	   if ((long_ret!=1)&&(long_ret!=2)&&(long_ret!=3))
	   	{
	   	  fprintf(stderr,"write to stationAp: bad  value\n");
                return SNMP_ERR_WRONGVALUE;
	   	}
          break;

        case RESERVE2:

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
		memset(nSe.ifName,0,IFNAME_LEN + 1);
		memset(value,0,SNMP_STR_LEN);
		nSe.ifIndex=name[name_len-1];
               printf("nSc.ifIndex==%d\n",nSe.ifIndex);
	        if_indextoname(nSe.ifIndex,nSe.ifName);
		sprintf(value,"%d",long_ret);
		wireless_sec_set_authmode(get_vnum_by_vname( nSe.ifName ),value);
		
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_apwepKeyType(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    char  value[SNMP_STR_LEN];
    long long_ret;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to stationAp not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to stationAp: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
	   long_ret = *((long *) var_val);
	   if ((long_ret!=1)&&(long_ret!=2))
	   	{
	   	  fprintf(stderr,"write to stationAp: bad  value\n");
                return SNMP_ERR_WRONGVALUE;
	   	}
		  
          break;

        case RESERVE2:

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
		memset(nSe.ifName,0,IFNAME_LEN + 1);
		memset(value,0,SNMP_STR_LEN);
		nSe.ifIndex=name[name_len-1];
               printf("nSc.ifIndex==%d\n",nSe.ifIndex);
	        if_indextoname(nSe.ifIndex,nSe.ifName);
		if(long_ret==1)
		{strcpy(value,"assic");}
		else
		{strcpy(value,"hex");}
		wireless_sec_set_wepkeytype(get_vnum_by_vname( nSe.ifName ),value);
	break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_apwepBitLevel(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
  static  char string[SNMP_STR_LEN];
  static long long_ret;
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to stationAp not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len >sizeof(long_ret)) {
              fprintf(stderr,"write to stationAp: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
	    long_ret = *((long *) var_val);
	      if ((long_ret !=64)&&(long_ret !=128)&&(long_ret!=152))
	      	{
	      	 fprintf(stderr,"write to stationAp: bad  value\n");
                return SNMP_ERR_WRONGVALUE;
	      	}
          break;

        case RESERVE2:

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
		memset(nSe.ifName,0,IFNAME_LEN + 1);
	        memset(string,0,SNMP_STR_LEN);
		nSe.ifIndex=name[name_len-1];
               printf("nSe.ifIndex==%d\n",nSe.ifIndex);
		if_indextoname(nSe.ifIndex, nSe.ifName);
		sprintf(string,"%d",long_ret);
	       wireless_sec_set_wepkey_level(get_vnum_by_vname( nSe.ifName ) ,string);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}




int
write_apwepKeyNum(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
  static unsigned char string[SNMP_STR_LEN];
  static long long_ret;
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to stationAp not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len >sizeof(long_ret)) {
              fprintf(stderr,"write to stationAp: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
	   long_ret = *((long *) var_val);
	   if ((long_ret<1)||(long_ret>4))
	   	{
	   	  fprintf(stderr,"write to stationAp: bad  value\n");
                return SNMP_ERR_WRONGVALUE;
	   	}
          break;

        case RESERVE2:

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
		memset(nSe.ifName,0,IFNAME_LEN + 1);
		nSe.ifIndex=name[name_len-1];
               printf("nSe.ifIndex==%d\n",nSe.ifIndex);
		if_indextoname(nSe.ifIndex,nSe.ifName);
		memset(string,0,SNMP_STR_LEN);
		sprintf(string,"%d",long_ret);
              wireless_sec_set_wepkey_seq(get_vnum_by_vname( nSe.ifName ) ,string);


          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_apwepKeyValue(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
  static unsigned char string[SNMP_STR_LEN];
  static unsigned char  key_seq[32];
  static unsigned char  key_type[32];

	switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to stationAp not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if ((var_val_len!=5) 
		&&(var_val_len!=13) 
		&&(var_val_len!=16 ))
		{
              fprintf(stderr,"write to stationAp: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
              }
          break;

        case RESERVE2:

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
		memset(nSe.ifName,0,IFNAME_LEN + 1);
		nSe.ifIndex=name[name_len-1];
               printf("nSe.ifIndex==%d\n",nSe.ifIndex);
		if_indextoname(nSe.ifIndex,nSe.ifName);
		memset(key_seq,0,32);
		memset(key_type,0,32);
	       memset(string,0,SNMP_STR_LEN);
          	memcpy(string,var_val,var_val_len);
		string[var_val_len]='\0';
		wireless_sec_get_wepkey_seq(get_vnum_by_vname( nSe.ifName ) ,key_seq,32);
		wireless_sec_get_wepkeytype(get_vnum_by_vname( nSe.ifName ) , key_type,32);
	       printf("nSe.ifName:%s\n",nSe.ifName);
		printf("key_seq:%s\n",key_seq);
		printf("key_type:%s\n",key_type);
		printf("string:%s\n",string);
               wireless_sec_set_wepkey(get_vnum_by_vname( nSe.ifName ) ,key_seq,key_type,string,1);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_staUplinkMaxRateValue(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    int size;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to stationAp not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to stationAp: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          size  = var_val_len;
          value = * (long *) var_val;

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}

int
write_staDwlinkMaxRateValue(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    long value;
    int size;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to stationAp not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to stationAp: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          size  = var_val_len;
          value = * (long *) var_val;

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
             /*
              * The variable has been stored in 'value' for you to use,
              * and you have just been asked to do something with it.
              * Note that anything done here must be reversable in the UNDO case
              */
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}



int
write_ChanAutoSelectEnable(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    char  value[SNMP_STR_LEN];
    int size;
    static long  long_ret;
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to stationAp not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to stationAp: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
	   long_ret = *((long *) var_val);
         if ((long_ret < 0)||(long_ret > 20)){
            fprintf(stderr, "write to stationAp:bad value\n");
            return SNMP_ERR_WRONGVALUE;
        }
		  
          break;

        case RESERVE2:

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
		memset(nRc.ifName,0,IFNAME_LEN + 1);
		nRc.ifIndex=name[name_len-1];
               printf("nRc.ifIndex==%d\n",nRc.ifIndex);
		if_indextoname(nRc.ifIndex,nRc.ifName);
		memset(value,0,SNMP_STR_LEN);
              sprintf(value,"%s  %s   %s   %d","/usr/sbin/iwconfig",nRc.ifName,"channel",long_ret);
	       printf("value:%s\n",value);		
	       system(value);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_RadioChannelConfig(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
    static long  long_ret;
    char  value[SNMP_STR_LEN];
    char  string[SNMP_STR_LEN];
    int size;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to stationAp not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to stationAp: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
	   long_ret = *((long *) var_val);
         if ((long_ret < 0)||(long_ret > 11)) 
	   {
            fprintf(stderr, "write to stationAp:bad value\n");
            return SNMP_ERR_WRONGVALUE;
        }
		  
          break;

        case RESERVE2:
          //size  = var_val_len;
          //value = * (long *) var_val;

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
		memset(nRc.ifName,0,IFNAME_LEN + 1);
		nRc.ifIndex=name[name_len-1];
               printf("nRc.ifIndex==%d\n",nRc.ifIndex);
		if_indextoname(nRc.ifIndex,nRc.ifName);
		memset(value,0,SNMP_STR_LEN);
		memset(string,0,SNMP_STR_LEN);
		sprintf(string,"%s   %s   %s""/sbin/ifconfig",nRc.ifName,"down");
		system(string);
              sprintf(value,"%s  %s   %s    %d","/usr/sbin/iwconfig",nRc.ifName,"channel",long_ret);
	       system(value);
		memset(string,0,SNMP_STR_LEN);
		sprintf(string,"%s   %s   %s""/sbin/ifconfig",nRc.ifName,"up");
		system(string);

          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


int
write_TransmitSpeedConfig(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
       char value[SNMP_STR_LEN];
       char string[SNMP_STR_LEN];
	int size;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_OCTET_STR) {
              fprintf(stderr, "write to  stationAp not ASN_OCTET_STR\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > 128*sizeof(char)) {
              fprintf(stderr,"write to stationAp: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
          break;

        case RESERVE2:
          //size  = var_val_len;
          //value = * (char *) var_val;

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
		memset(value,0,SNMP_STR_LEN);
		memset(string,0,SNMP_STR_LEN);
		memset(nRc.ifName,0,IFNAME_LEN + 1);
		nRc.ifIndex=name[name_len-1];
               printf("nRc.ifIndex==%d\n",nRc.ifIndex);
		if_indextoname(nRc.ifIndex,nRc.ifName);
		sprintf(string,"%s%s",nRc.ifName,"_SPEED");
	       memcpy(value,var_val,var_val_len);
		value[var_val_len]='\0';
	       save_global_conf(SEP_EQUAL,SNMP_AGENT_CONF,"",string,value);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}

int
	write_PowerMgmtEnable(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
//	char  value[SNMP_STR_LEN];
 //   int size;
    char cmd[128];
    static long  long_ret;
    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to stationAp not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to stationAp: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }
	   long_ret = *((long *) var_val);
         if ((long_ret < 0)||(long_ret > 1)){
            fprintf(stderr, "write to stationAp:bad value\n");
            return SNMP_ERR_WRONGVALUE;
        }
		  
          break;

        case RESERVE2:

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
			memset(cmd, 0, 128);
				if(long_ret==0)
					sprintf(cmd, "%s", "/usr/sbin/setautopower1.sh ignore");
				else
					sprintf(cmd, "%s", "/usr/sbin/setautopower1.sh increment");
				system(cmd);
					
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}



int
write_MaxStationNumPermitted(int      action,
            u_char   *var_val,
            u_char   var_val_type,
            size_t   var_val_len,
            u_char   *statP,
            oid      *name,
            size_t   name_len)
{
   static  char value[SNMP_STR_LEN + 1];
   static long long_ret;
   static int size;

    switch ( action ) {
        case RESERVE1:
          if (var_val_type != ASN_INTEGER) {
              fprintf(stderr, "write to stationAp not ASN_INTEGER\n");
              return SNMP_ERR_WRONGTYPE;
          }
          if (var_val_len > sizeof(long)) {
              fprintf(stderr,"write to stationAp: bad length\n");
              return SNMP_ERR_WRONGLENGTH;
          }

	long_ret = *((long *) var_val);
       if ((long_ret < 0)||(long_ret > 128)) 
	   	{
            fprintf(stderr, "write to stationAp:bad value\n");
            return SNMP_ERR_WRONGVALUE;
        }
          break;

        case RESERVE2:
         // size  = var_val_len;
         // value = * (long *) var_val;

          break;

        case FREE:
             /* Release any resources that have been allocated */
          break;

        case ACTION:
		for(size=0;size<name_len;size++)
		{
		printf("name[%d]%d\n",size,name[size]);
		}
		memset(nRc.ifName,0,IFNAME_LEN + 1);
		nRc.ifIndex=name[name_len-1];
               printf("nRc.ifIndex==%d\n",nRc.ifIndex);
		if_indextoname(nRc.ifIndex,nRc.ifName);
		memset(value,0,SNMP_STR_LEN + 1);
		sprintf(value,"%d",long_ret);
              wireless_config_maxsimultusers(get_vnum_by_vname(nRc.ifName), value);
          break;

        case UNDO:
             /* Back out any changes made in the ACTION case */
          break;

        case COMMIT:
             /*
              * Things are working well, so it's now safe to make the change
              * permanently.  Make sure that anything done here can't fail!
              */
          break;
    }
    return SNMP_ERR_NOERROR;
}


/****************************************************************************
*                                                                           *
*                      loadTables() - Load the Tables                       *
*                                                                           *
****************************************************************************/
static void AP_loadTables()
{
  int skfd;                               // generic raw socket desc
  struct iwreq wrq;                       // ioctl request structure
  struct ifreq ifr;
  struct timeval et;                      // elapsed time
  struct wireless_info info;              // workarea for wireless ioctl information
  FILE *fp;
  char  bfr[1024], ifName[1024];
  char *s, *t;

  gettimeofday ( &et, ( struct timezone * ) 0 );  // get time-of-day
  if ( et.tv_sec < lastLoad + MINLOADFREQ )       // only reload so often
    return;
  lastLoad = et.tv_sec;

  skfd = AP_openSocket();                            // open socket
  if ( skfd < 0 ) {
    syslog ( LOG_ERR, "SNMP ieee802dot11.loadTables() - %s\n", "socket open failure" );
    return;
  }

  AP_flushLists();

  // find interfaces in /proc/net/dev and find the wireless interfaces
  fp = fopen ( PROC_NET_DEV, "r" );
  if ( fp ) {
    while ( fgets ( bfr, sizeof ( bfr ), fp )) {
      if ( strstr ( bfr, ":" )) {
        s = bfr; t = ifName;
        while ( isspace ( *s ))                     // discard white space
          *s++;
        while ( *s != ':' )                         // get interface name
          *t++ = *s++;
        *t = '\0';

        // verify as a wireless device
        memset (( char * ) &info, 0, sizeof ( struct wireless_info ));
		
        strncpy ( wrq.ifr_name, ifName, IFNAMSIZ );
		
        if ( ioctl ( skfd, SIOCGIWNAME, &wrq ) >= 0 ) {
          AP_initStructs();
          AP_loadWiExt( skfd, ifName, &info );
          AP_load80211Structs ( skfd, ifName, &info );
        }
      }
    }
    fclose ( fp );
  }

  close ( skfd );
}





/****************************************************************************
*                                                                           *
*              load80211Structs() - load the 802.11 structures              *
*                                                                           *
****************************************************************************/
static void 
AP_load80211Structs ( int skfd, char *ifName, struct wireless_info *wi )
{
  int rc, ifIndex = 0;
  struct ifreq ifr;
  char  MACAddress [ MACADDR_LEN + 1 ];

  strcpy ( ifr.ifr_name, ifName );
  rc = ioctl ( skfd, SIOCGIFHWADDR, &ifr );
  if ( rc >= 0 ) {

    sprintf ( MACAddress, "%02X:%02X:%02X:%02X:%02X:%02X\0", 
                 ( UCHAR ) ifr.ifr_hwaddr.sa_data[0], ( UCHAR ) ifr.ifr_hwaddr.sa_data[1], 
                 ( UCHAR ) ifr.ifr_hwaddr.sa_data[2], ( UCHAR ) ifr.ifr_hwaddr.sa_data[3], 
                 ( UCHAR ) ifr.ifr_hwaddr.sa_data[4], ( UCHAR ) ifr.ifr_hwaddr.sa_data[5] );

    nSc.haveStationID = TRUE;
    strcpy  ( nSc.stationID, MACAddress );
    nOp.haveMACAddress = TRUE;
    strcpy  ( nOp.MACAddress, MACAddress );
    nRi.haveManufacturerOUI = TRUE;
    strncpy ( nRi.manufacturerOUI, MACAddress, MAN_OUI_LEN ); 

    ifIndex = if_nametoindex ( ifName );
    if ( !ifIndex ) {
      syslog ( LOG_ERR, "SNMP %s - %s %s\n", 
        "ieee802dot11.load80211Structs()", ifName, "has no ifIndex" );
      return;
    }

    AP_loadWiExtTo80211Structs ( ifIndex, ifName, wi );

    if ( AP_hasChanged (( char * ) &nAc, sizeof ( nAc ))) {
      nAc.ifIndex = ifIndex;
      sprintf ( nAc.UID, "%04d\0", nAc.ifIndex );
      strcpy ( nAc.ifName, ifName );
      AP_addList (( char * ) &acList, ( char * ) &nAc, sizeof ( nAc ));
    }
     if ( AP_hasChanged (( char * ) &nSe, sizeof ( nSe ))) {
      nSe.ifIndex = ifIndex;
      sprintf ( nSe.UID, "%04d\0", nSe.ifIndex );
      strcpy ( nSe.ifName, ifName );
      AP_addList (( char * ) &seList, ( char * ) &nSe, sizeof ( nSe ));
	  }

    if ( AP_hasChanged (( char * ) &nSn, sizeof ( nSn ))) {
      nSn.ifIndex = ifIndex;
      sprintf ( nSn.UID, "%04d\0", nSn.ifIndex );
      strcpy ( nSn.ifName, ifName );
      AP_addList (( char * ) &snList, ( char * ) &nSn, sizeof ( nSn ));
	 }

    if ( AP_hasChanged (( char * ) &nRc, sizeof ( nRc ))) {
      nRc.ifIndex = ifIndex;
      sprintf ( nRc.UID, "%04d\0", nRc.ifIndex );
      strcpy ( nRc.ifName, ifName );
      AP_addList (( char * ) &rcList, ( char * ) &nRc, sizeof ( nRc ));
	  }






  }

}




static void AP_initStructs()
{
  int i;

  memset (( char * ) &nAc, 0, sizeof ( nAc ));
  memset (( char * ) &nSe, 0, sizeof ( nSe ));
  memset (( char * ) &nAd, 0, sizeof ( nAd ));
  memset (( char * ) &nTx, 0, sizeof ( nTx ));
  memset (( char * ) &nRx, 0, sizeof ( nRx ));
  memset (( char * ) &nRp, 0, sizeof ( nRp ));
  memset (( char * ) &nUt, 0, sizeof ( nUt ));
  memset (( char * ) &nAr, 0, sizeof (nAr ));
  memset (( char * ) &nCr, 0, sizeof ( nCr ));
  memset (( char * ) &nTr, 0, sizeof ( nTr ));
  memset (( char * ) &nEr, 0, sizeof ( nEr ));
  memset (( char * ) &nSd, 0, sizeof ( nSd ));
  memset (( char * ) &nRk, 0, sizeof ( nRk ));
  memset (( char * ) &nSg, 0, sizeof ( nSg ));
  memset (( char * ) &nSp, 0, sizeof ( nSp ));
  memset (( char * ) &nSi, 0, sizeof ( nSi ));
  memset (( char * ) &nWm, 0, sizeof (nWm ));
  memset (( char * ) &nIp, 0, sizeof (nIp ));
  memset (( char * ) &nSu, 0, sizeof (nSu ));
  memset (( char * ) &nSk, 0, sizeof (nSk ));
  memset (( char * ) &nPs, 0, sizeof (nPs ));
  memset (( char * ) &nRc, 0, sizeof (nRc ));
  memset (( char * ) &nSn, 0, sizeof (nSn ));
  
  // Wireless Extensions
  wepCurrentKey = 0;
  haveWepCurrentKey = FALSE;
  for ( i = 0; i < MAX_WEP_KEYS; i++ ) {
    wep[i].len = 0;
    wep[i].key[0] = '\0';
    wep[i].haveKey = FALSE;
  }
}





/****************************************************************************
*                                                                           *
*                Wireless Extensions Specific Functions                     *
*                                                                           *
****************************************************************************/
/****************************************************************************
*                                                                           *
* loadWiExtTo80211Structs() - load wireless extensions to 802.11 structures *
*                                                                           *
****************************************************************************/
static void 
AP_loadWiExtTo80211Structs ( int ifIndex, char *ifName, struct wireless_info *wi )
{
  int  total_min = 0;
 char str_mac_n[10]={0};
  char cmd[128];
  char bfr[128];
  char strBuf[128];
  char strTem[128];
  int bg_num=0;
  int ifnum=0;
  prop_data properties[255];
  int prop_count=0;
  char  para[128];
  char  string[128];

nAc.haveSSIDEnabled = TRUE;
nAc.ifIndex = ifIndex;
strcpy(nAc.ifName,ifName);
memset(strBuf,0,128);
wireless_get_enable(get_vnum_by_vname( nAc.ifName ),strBuf,64);
printf("strBuf:%s\n",strBuf);
if(0==strcmp(strBuf,"yes"))
  {nAc.SSIDEnabled=1;}
else{nAc.SSIDEnabled=0;}
  
nAc.haveSSIDHidden = TRUE;
nAc.ifIndex = ifIndex;
strcpy(nAc.ifName,ifName);
{ 
  FILE *fp;
 memset( cmd, 0, 128 );
  sprintf(cmd, "%s %s %s ", "/usr/sbin/iwpriv",nAc.ifName,"get_hide_ssid|awk -F \":\" '{print $2}'");
  fp=popen(cmd,"r");
  if(fp)
   {
  	 memset( bfr, 0, 128 );
  	 fgets(bfr,sizeof(bfr),fp);
	 bfr[strlen(bfr)-1] = '\0';
	 nAc.SSIDHidden=atoi(bfr);
	 pclose(fp);

   }
  }

nAc.haveStaIsolate = TRUE;
nAc.ifIndex = ifIndex;
strcpy(nAc.ifName,ifName);
{ 
   FILE *fp;
   int res = 0;
   memset( cmd, 0, 128 );
  sprintf(cmd, "%s %s %s ", "/usr/sbin/iwpriv",nAc.ifName,"get_ap_bridge|awk -F \":\" '{print $2}'");
  printf("heyanhua test cmd:%s\n",cmd);
  fp=popen(cmd,"r");
  if(fp)
   {
	 memset( bfr, 0, 128 );
  	 fgets(bfr,sizeof(bfr),fp);
	 bfr[strlen(bfr)-1] = '\0';
	 if(atoi(bfr) == 0)
	 {
	 	res = 1;
	 }
//	 else if(atoi(bfr) == 1)
//	 	res = 0;
	 	
	 	nAc.StaIsolate=res;
	 pclose(fp);
   }
  	 printf("heyh test ! atoi(bfr)=%d,res=%d\n",atoi(bfr),res);
	// nAc.StaIsolate=res;
  }



nAc.haveEAPAuthenSupport = TRUE;
{
  strcpy(nAc.ifName,ifName);
  memset(string,0,128);
  memset(para,0,128);
  sprintf(string,"%s%s",nAc.ifName,"_EAP");
  prop_count=load_prop(SEP_EQUAL,SNMP_AGENT_CONF,properties);
  get_prop(string,para,properties,prop_count);
  free_prop(properties,prop_count) ;
  nAc.EAPAuthenSupport=atoi(para);
}

nAc.haveApConnectUsers = TRUE;
strcpy(nAc.ifName,ifName);
{ 
   int num;
    FILE *fp;
  memset( cmd, 0, 128 );
  sprintf(cmd, "%s %s %s %s", "/usr/sbin/wlanconfig",nAc.ifName,"list","|wc -l");
  fp=popen(cmd,"r");
  if(fp)
   {
  	 memset( bfr, 0, 128 );
  	 fgets(bfr,sizeof(bfr),fp);
	 bfr[strlen(bfr)-1] = '\0';
	 num=atoi(bfr);
	 if(num>1)
	 nAc.apConnectUsers=num-1;
	 pclose(fp);
	}
  
}

nAc.haveApMaxSimultUsers = TRUE;
{
	strcpy(nAc.ifName,ifName);
	memset(strBuf,0,32);
	wireless_get_maxsimultusers(get_vnum_by_vname( nAc.ifName ),strBuf, 20);
	nAc.apMaxSimultUsers=atoi(strBuf);
}
nAc.haveApBGmode = TRUE;
{
	memset(strBuf,0,32);
	strcpy(strBuf,wi->name);
	printf("strBuf:%s\n",strBuf);
	if(0==strcmp(strBuf,"IEEE 802.11a"))
	    {bg_num=1;}
	if(0==strcmp(strBuf,"IEEE 802.11b"))
	   {bg_num=2;}
	if(0==strcmp(strBuf,"IEEE 802.11g"))
	   {bg_num=6;}
	if(0==strcmp(strBuf,"IEEE 802.11an"))
	   {bg_num=8;}
	if(0==strcmp(strBuf,"IEEE 802.11gn"))
	   {bg_num=16;}
	  nAc.apBGmode=bg_num;
}

nAc.haveUsrReqJoinCount = TRUE;
nAc.ifIndex = ifIndex;
strcpy(nAc.ifName,ifName);
{  FILE *fp;
   memset(cmd, 0, 128 );
  sprintf(cmd,"%s%s%s","cat /proc/sys/net/",nAc.ifName,"/users_join_counter");
  printf("cmd:%s\n",cmd);
  fp=popen(cmd,"r");
  if(fp)
   {
  	 memset(bfr, 0, 128 );
  	 fgets(bfr,sizeof(bfr),fp);
	 printf("bfr:%s",bfr);
	 bfr[strlen(bfr)-1] = '\0';
	 nAc.UsrReqJoinCount=atoi(bfr);
	 pclose(fp);
   }
  }


nAc.haveApRespUserCount = TRUE;
nAc.ifIndex = ifIndex;
strcpy(nAc.ifName,ifName);
{  FILE *fp;
    memset(cmd, 0, 128 );
  sprintf(cmd,"%s%s%s","cat /proc/sys/net/",nAc.ifName,"/respond_users_join_cnt");
  printf("cmd:%s\n",cmd);
  fp=popen(cmd,"r");
  if(fp)
   {
  	 memset(bfr, 0, 128 );
  	 fgets(bfr,sizeof(bfr),fp);
	 bfr[strlen(bfr)-1] = '\0';
	 nAc.apRespUserCount=atoi(bfr);
	 pclose(fp);
   }
  }

nAc.haveUsrJoinSucCount = TRUE;
nAc.ifIndex = ifIndex;
strcpy(nAc.ifName,ifName);
{  FILE *fp;
  memset(cmd, 0, 128 );
  sprintf(cmd,"%s%s%s","cat /proc/sys/net/",nAc.ifName,"/users_join_successful_counter");
  printf("cmd:%s\n",cmd);
  fp=popen(cmd,"r");

  if(fp)
   { 
  	 memset( bfr, 0, 128 );
  	 fgets(bfr,sizeof(bfr),fp);
	 bfr[strlen(bfr)-1] = '\0';
	 nAc.UsrJoinSucCount=atoi(bfr);
	 pclose(fp);
   }
  }

nAc.haveap80211stats = TRUE;
nAc.ifIndex = ifIndex;
{
	 FILE *fp;
	memset(strBuf,0,32);
	memset(strTem,0,128);
	memset(nAc.ap80211stats,0,2048);
	sprintf(strBuf,"%s %s","/usr/sbin/80211stats  -a  -i",nAc.ifName);
	  if(fp=popen( strBuf,"r"))
	  	{
		  while(NULL != fgets(strTem,sizeof(strTem),fp)){
		  	strcat(nAc.ap80211stats, strTem);
		        }
		  pclose(fp);
	      }
}

nAc.haveapUtilResource = TRUE;
{   
   char string[128];
    double   percent;
    double   double_ret;
	 int sum = 0;
	 int r=0,t=0;
	 char str_cmd1[128];
	 char str_cmd2[128];
	 FILE *fp;	 
	 nAc.ifIndex = ifIndex;
	  		 memset (nAc.apUtilResource, 0, 32);
			 memset( str_cmd1, 0, 128 );
			 memset( str_cmd2, 0, 128 );
			 sprintf( str_cmd1, "%s%s%s", "cat /tmp/interface-rate |awk '/",nAc.ifName,"/{print $2}'");
                       sprintf( str_cmd2, "%s%s%s", "cat /tmp/interface-rate |awk '/",nAc.ifName,"/{print $3}'");
			 fp=popen(str_cmd1,"r");
			 if(fp)
				{
					memset (string, 0, 128);
					while(fgets(string,sizeof(string),fp)) 
				       {
						  CGetChar(&sum, string);
				        }
					   r=sum;
					   pclose(fp);
				 }
			 printf("r===%d\n",r);
			 fp=popen(str_cmd2,"r");
			 if(fp)
				{
					memset (string, 0, 128);
					while(fgets(string,sizeof(string),fp)) 
				       {
						  CGetChar(&sum, string);
				        }
					   t=sum;
					   pclose(fp);
				 }
			 
			 printf("t===%d\n",t);
			 
	  printf("t+r:%d\n",t+r);
	   percent =((double)((t+r)*8*100)/(23*1024*1024));	
	   printf("percent:%f\n",percent);
          double_ret= (percent) > 100 ? 100 : percent;
	   printf("double_ret:%f\n",double_ret);
	   sprintf(nAc.apUtilResource,"%f%%",double_ret);
	   printf("nAc.apUtilResource:%s\n",nAc.apUtilResource);
	}

nAc.haveVapFlag = TRUE;
nAc.ifIndex = ifIndex;
strcpy(nAc.ifName,ifName);
{ FILE *fp;
  char bfr[STR_BUF];
  char cmd[STR_BUF];
  memset(cmd, 0, STR_BUF );
  sprintf(cmd,"%s   %s   %s","/usr/sbin/autelan   traffic_limit ",nAc.ifName,"get_vap_flag|awk '{print $NF}'");
  printf("cmd:%s\n",cmd);
  fp=popen(cmd,"r");

  if(fp)
   {
  	 memset( bfr, 0, STR_BUF );
  	 fgets(bfr,sizeof(bfr),fp);
	 bfr[strlen(bfr)-1] = '\0';
	 strcpy(nAc.vapFlag,bfr);
	 pclose(fp);
   }
  }


nAc.haveVapTraffic = TRUE;
nAc.ifIndex = ifIndex;
strcpy(nAc.ifName,ifName);
{ FILE *fp;
  char bfr[STR_BUF];
  char cmd[STR_BUF];
  memset(cmd, 0, STR_BUF );
  sprintf(cmd,"%s   %s   %s","/usr/sbin/autelan   traffic_limit ",nAc.ifName,"get_vap |awk '{print $NF}'");
  printf("cmd:%s\n",cmd);
  fp=popen(cmd,"r");

  if(fp)
   {
  	 memset( bfr, 0, STR_BUF );
  	 fgets(bfr,sizeof(bfr),fp);
	 bfr[strlen(bfr)-1] = '\0';
	 strcpy(nAc.vapTraffic,bfr);
	 pclose(fp);
   }
  }


nAc.haveEveryNodeFlag = TRUE;
nAc.ifIndex = ifIndex;
strcpy(nAc.ifName,ifName);
{ FILE *fp;
  char bfr[STR_BUF];
  char cmd[STR_BUF];
  memset(cmd, 0, STR_BUF );
  sprintf(cmd,"%s   %s   %s","/usr/sbin/autelan   traffic_limit ",nAc.ifName,"get_every_node_flag|awk '{print $NF}'");
  printf("cmd:%s\n",cmd);
  fp=popen(cmd,"r");

  if(fp)
   {
  	 memset( bfr, 0, STR_BUF );
  	 fgets(bfr,sizeof(bfr),fp);
	 bfr[strlen(bfr)-1] = '\0';
	 strcpy(nAc.everyNodeFlag,bfr);
	 pclose(fp);
   }
  }

nAc.haveEveryNodeTraffic = TRUE;
nAc.ifIndex = ifIndex;
strcpy(nAc.ifName,ifName);
{ FILE *fp;
  char bfr[STR_BUF];
  char cmd[STR_BUF];
  memset(cmd, 0, STR_BUF );
  sprintf(cmd,"%s   %s   %s","/usr/sbin/autelan   traffic_limit ",nAc.ifName,"get_every_node|awk '{print $NF}'");
  printf("cmd:%s\n",cmd);
  fp=popen(cmd,"r");

  if(fp)
   {
  	 memset( bfr, 0, STR_BUF );
  	 fgets(bfr,sizeof(bfr),fp);
	 bfr[strlen(bfr)-1] = '\0';
	 strcpy(nAc.everyNodeTraffic,bfr);
	 pclose(fp);
   }
  }



nAc.haveSpecificNodeFlag = TRUE;
nAc.ifIndex = ifIndex;
strcpy(nAc.ifName,ifName);
{ FILE *fp;
  char bfr[STR_BUF];
  char cmd[STR_BUF];
  memset(cmd, 0, STR_BUF );
  sprintf(cmd,"%s   %s   %s","/usr/sbin/autelan   traffic_limit ",nAc.ifName,"get_specific_node_flag|awk '{print $NF}'");
  printf("cmd:%s\n",cmd);
  fp=popen(cmd,"r");

  if(fp)
   {
  	 memset( bfr, 0, STR_BUF );
  	 fgets(bfr,sizeof(bfr),fp);
	 bfr[strlen(bfr)-1] = '\0';
	 strcpy(nAc.specificNodeFlag,bfr);
	 pclose(fp);
   }
  }



#if 0
nAc.haveSpecificNodeTraffic = TRUE;
nAc.ifIndex = ifIndex;
strcpy(nAc.ifName,ifName);
{ FILE *fp;
  char bfr[STR_BUF];
  char cmd[STR_BUF];
  memset(cmd, 0, STR_BUF );
  sprintf(cmd,"%s   %s   %s","/usr/sbin/autelan   traffic_limit ",nAc.ifName,"get_specific_node|awk '{print $NF}'",);
  printf("cmd:%s\n",cmd);
  fp=popen(cmd,"r");

  if(fp)
   {
  	 memset( bfr, 0, STR_BUF );
  	 fgets(bfr,sizeof(bfr),fp);
	 bfr[strlen(bfr)-1] = '\0';
	 strcpy(nAc.specificNodeTraffic,bfr);
	 pclose(fp);
   }
  }

#endif

nAc.haveSnrBSSIDTxSignalPkts = TRUE;
strcpy(nAc.ifName,ifName);
nAc.ifIndex = ifIndex;
{ FILE *fp;
  char bfr[STR_BUF];
  char cmd[STR_BUF];
  memset(cmd, 0, STR_BUF );
  sprintf(cmd,"%s  %s  %s","/usr/sbin/80211stats  -i ",nAc.ifName,"|awk '/tx management/{print $1}'");
  printf("cmd:%s\n",cmd);
  fp=popen(cmd,"r");
  if(fp)
   {
  	 memset( bfr, 0, STR_BUF );
  	 fgets(bfr,sizeof(bfr),fp);
	 bfr[strlen(bfr)-1] = '\0';
	 nAc.SnrBSSIDTxSignalPkts=atoi(bfr);
	 pclose(fp);
   }
  }

nAc.haveSnrBSSIDRxSignalPkts = TRUE;
strcpy(nAc.ifName,ifName);
nAc.ifIndex = ifIndex;
{ FILE *fp;
  char bfr[STR_BUF];
  char cmd[STR_BUF];
  memset(cmd, 0, STR_BUF );
  sprintf(cmd,"%s  %s  %s","/usr/sbin/80211stats  -i ",nAc.ifName,"|awk '/rx management/{print $1}'");
  printf("cmd:%s\n",cmd);
  fp=popen(cmd,"r");
  if(fp)
   {
  	 memset( bfr, 0, STR_BUF );
  	 fgets(bfr,sizeof(bfr),fp);
	 bfr[strlen(bfr)-1] = '\0';
	 nAc.SnrBSSIDRxSignalPkts=atoi(bfr);
	 pclose(fp);
   }
  }
nAc.haveSnrBSSIDSignalPkts = TRUE;
strcpy(nAc.ifName,ifName);
nAc.ifIndex = ifIndex;
nAc.SnrBSSIDSignalPkts=nAc.SnrBSSIDTxSignalPkts+ nAc.SnrBSSIDRxSignalPkts;

nAc.haveapFloodDetect = TRUE;
{ FILE *fp;
  char bfr[STR_BUF];
  char cmd[STR_BUF];
  memset(cmd, 0, STR_BUF );
  sprintf(cmd,"%s  %s  %s","/usr/sbin/iwpriv",nAc.ifName,"get_flood_detect|awk  -F \":\" '{print $2}'");
  printf("cmd:%s\n",cmd);
  fp=popen(cmd,"r");
  if(fp)
   {
  	 memset( bfr, 0, STR_BUF );
  	 fgets(bfr,sizeof(bfr),fp);
	 bfr[strlen(bfr)-1] = '\0';
	 nAc.apFloodDetect=atoi(bfr);
	 pclose(fp);
   }
  }

nAc.haveapSpoofDetect = TRUE;
{ FILE *fp;
  char bfr[STR_BUF];
  char cmd[STR_BUF];
  memset(cmd, 0, STR_BUF );
  sprintf(cmd,"%s  %s  %s","/usr/sbin/iwpriv",nAc.ifName,"get_spoof_detect|awk  -F \":\" '{print $2}'");
  printf("cmd:%s\n",cmd);
  fp=popen(cmd,"r");
  if(fp)
   {
  	 memset( bfr, 0, STR_BUF );
  	 fgets(bfr,sizeof(bfr),fp);
	 bfr[strlen(bfr)-1] = '\0';
	 nAc.apSpoofDetect=atoi(bfr);
	 pclose(fp);
   }
  }

nAc.haveapWKIVDectect = TRUE;
{ FILE *fp;
  char bfr[STR_BUF];
  char cmd[STR_BUF];
  memset(cmd, 0, STR_BUF );
  sprintf(cmd,"%s  %s  %s","/usr/sbin/iwpriv",nAc.ifName,"get_wk_iv_detect|awk  -F \":\" '{print $2}'");
  printf("cmd:%s\n",cmd);
  fp=popen(cmd,"r");
  if(fp)
   {
  	 memset( bfr, 0, STR_BUF );
  	 fgets(bfr,sizeof(bfr),fp);
	 bfr[strlen(bfr)-1] = '\0';
	 nAc.apWKIVDectect =atoi(bfr);
	 pclose(fp);
   }
  }

nAc.haveapClearAttackHistory = TRUE;
nAc.apClearAttackHistory = 0;

nAc.haveapClearIllegalHistory = TRUE;
nAc.apClearIllegalHistory = 0;

nAc.haveapClearAttackStatistics = TRUE;
nAc.apClearAttackStatistics = 0;



nAc.haveRadioIfIndex = TRUE;
strcpy(nAc.ifName,ifName);
nAc.RadioIfIndex=ifIndex;

nAc.haveSSIDindex = TRUE;
{
  strcpy(nAc.ifName,ifName);
  memset(string,0,128);
  memset(para,0,128);
  sprintf(string,"%s%s",nAc.ifName,"_SSIDINDEX");
  prop_count=load_prop(SEP_EQUAL,SNMP_AGENT_CONF,properties);
  get_prop(string,para,properties,prop_count);
  free_prop(properties,prop_count) ;
  nAc.SSIDindex=atoi(para);
}


nAc.haveBSSID = TRUE;
{ FILE *fp;
  char bfr[STR_BUF];
  char cmd[STR_BUF];
  memset(cmd, 0, STR_BUF );
  strcpy(nAc.ifName,ifName);
  sprintf(cmd,"%s  %s  %s","/sbin/ifconfig",nAc.ifName,"|awk  '/HWaddr/{print $5}'");
  printf("cmd:%s\n",cmd);
  fp=popen(cmd,"r");
  if(fp)
   {
  	 memset( bfr, 0, STR_BUF );
  	 fgets(bfr,sizeof(bfr),fp);
	 bfr[strlen(bfr)-1] = '\0';
	 memset(nAc.BSSIDmac,0,18);
	 strcpy(nAc.BSSIDmac,bfr);
	 pclose(fp);
   }
  }



if ( wi->has_range ) 
{
       char ciphertype[64];
       char wepmode[64];
	char wapmode[64];
       int retu=0;
	int ifnum=0;
	strcpy( nSe.ifName,ifName);
	
	memset (ciphertype, 0,64);
	memset (wepmode, 0,64);
	memset (wapmode, 0,64);
       ifnum=get_vnum_by_vname( nSe.ifName );
	nSe.haveApSecurityType=TRUE;
	wireless_sec_get_type(ifnum,ciphertype, 64 );
	if(0==strcmp(ciphertype,"none"))
	      { retu=1;}
	else if (0==strcmp(ciphertype,"wep"))
	      {
		      wireless_sec_get_authmode(ifnum,wepmode,64);
	              if(0==strcmp(wepmode,"1"))
	              	 {retu=2;}
	             if(0==strcmp(wepmode,"2"))
	             	 {retu=3;}
		      if(0==strcmp(wepmode,"3"))
		      	 {retu=4;}
	        }
      else if (0==strcmp(ciphertype,"wpa"))
	      {
		      wireless_sec_get_mode(ifnum,wapmode,64);
			if(0==strcmp(wapmode,"PSK"))
				{retu=5;}
			if(0==strcmp(wapmode,"RADIUS"))
				{retu=7;}
	       }
	else if (0==strcmp(ciphertype,"wpa2"))
		{
		      wireless_sec_get_mode(ifnum,wapmode,64);
			if(0==strcmp(wapmode,"PSK"))
				{retu=6;}
			if(0==strcmp(wapmode,"RADIUS"))
				{retu=8;}
	   }

	else if (0==strcmp(ciphertype,"wapi"))
	      {retu=9;}

    nSe.apSecurityType=retu;
   

}

 
if ( wi->has_range ) 
{
	 strcpy( nSe.ifName,ifName);
	  ifnum=get_vnum_by_vname( nSe.ifName );

	 nSe.haveApwpaAuthMode=TRUE;
	{ 
		 memset(strBuf,0,32);
		 wireless_sec_get_mode(ifnum,strBuf,64);
		 if(0==strcmp(strBuf,"PSK"))
		   {nSe.apwpaAuthMode=1;}
		 if(0==strcmp(strBuf,"RADIUS"))
		   {nSe.apwpaAuthMode=2;}
	 }
	 nSe.haveApwpaCipher=TRUE;
	 { 
		 memset(strBuf,0,32);
	       wireless_sec_get_wpaencrypt(ifnum, strBuf, 64);
		  printf("strBuf:%s\n",strBuf);
		 if(0==strcmp(strBuf,"TKIP"))
		   {nSe.apwpaCipher=1;}
		 if(0==strcmp(strBuf,"AES"))
		   {nSe.apwpaCipher=2;}
	  }
		nSe.haveApwpaKeyValue=TRUE;
	    {
		memset (nSe.apwpaKeyValue, 0, sizeof( nSe.apwpaKeyValue));
		wireless_sec_get_wpakey(ifnum, nSe.apwpaKeyValue,128);
             }
}




if ( wi->has_range ) 
{
		char keytype[32];
		char authmode[32];
		char strBit[32];
		char keynum[32];
		unsigned int ifnum=0;
	       strcpy( nSe.ifName,ifName);
		ifnum=get_vnum_by_vname( nSe.ifName );
		nSe.haveApwepAuthMode=TRUE;
		wireless_sec_get_authmode(ifnum,authmode, 32);
		nSe.apwepAuthMode=atoi(authmode);
		
		nSe.haveApwepKeyType=TRUE;
		wireless_sec_get_wepkeytype(ifnum, keytype, 32);
		{
		   if(0==strcmp(keytype,"hex"))
			nSe.apwepKeyType=2;
		   else
			nSe.apwepKeyType=1;
		}
		
		nSe.haveApwepBitLevel=TRUE;
		memset(strBit,0,32);
		wireless_sec_get_wepkey_level(ifnum, strBit, 32);
		nSe.apwepBitLevel=atoi(strBit);
		nSe.haveApwepKeyNum=TRUE;
		wireless_sec_get_wepkey_seq(ifnum, keynum, 32);
		nSe.apwepKeyNum=atoi(keynum);
		nSe.haveApwepKeyValue=TRUE;
		wireless_sec_get_wepkey(ifnum,keynum,nSe.apwepKeyValue, 128);

}



if ( wi->has_range ) 
 {
  char cmd_n[STR_BUF];
  char cmd_l[STR_BUF];
  char cmd_a[STR_BUF];
  char cmd_p[STR_BUF];
  char cmd_u[STR_BUF];
  char cmd_c[STR_BUF];
  char cmd_m[STR_BUF];
  char line[STR_BUF];
  char bfr[STR_BUF];
  char mac[STR_BUF];
  char cmd_ip[STR_BUF];
  int  nomal_row=0;
  int  num_row = 0;
  int  nomal_bf=0;
  int  nomal_af=0;
  int  i = 0,k=0;
  char *token;
  FILE  *fp,*fp1,*fp2;
  int   if_min = 0;
  int   buf_min=0;
  char buffer[2][32];
  int   wmmState=0;
  int   powState=0;
  strcpy(nAd.ifName,ifName);
  strcpy(nRp.ifName,ifName);
  strcpy(nUt.ifName,ifName);
  strcpy(nWm.ifName,ifName); 
  strcpy(nIp.ifName,ifName); 
  strcpy(nPs.ifName,ifName);
  strcpy(nSu.ifName,ifName); 
  strcpy(nSk.ifName,ifName); 

  memset(cmd_n,0, STR_BUF);
  sprintf(cmd_n, "%s %s %s %s", WLANCONF, nAd.ifName,"list","|wc -l");
   fp1=popen(cmd_n,"r");
    if(fp1)
      {
  	 memset( bfr, 0, STR_BUF );
  	 fgets(bfr,sizeof(bfr),fp1);
	 bfr[strlen(bfr)-1] = '\0';
	 num_row=atoi(bfr);
	 pclose(fp1);
      }
     for(i=2;i<= num_row;i++)
   	  {
              nAd.ifIndex= ifIndex;
	       nRp.ifIndex= ifIndex;
		nUt.ifIndex= ifIndex;
		nIp.ifIndex= ifIndex;
		nPs.ifIndex= ifIndex;
		nWm.ifIndex= ifIndex;
		
		nAd.apStatMacAddrIndex= i-1 ;
	       nRp.apStatRxPowerIndex= i-1 ;
	       nUt.apStatUpTimeIndex= i-1 ;
		nPs.StaPowerSaveModeIndex= i-1 ;		   
		nIp.StaIPAddressIndex= i-1 ;
		nWm.StaWMMAttrIndex= i-1 ;
		nSu.StaUplinkMaxRateIndex= i-1 ;
		nSk.StaDwlinkMaxRateIndex= i-1 ;
	     memset(nAd.apStatMacAddrValue, 0, MACADDR_LEN+1);
            memset(cmd_l,0, STR_BUF);
            memset(cmd_a,0, STR_BUF);
	     memset(cmd_p,0, STR_BUF);
	     memset(cmd_u,0, STR_BUF);
	     memset(cmd_c,0, STR_BUF);
	     memset(cmd_m,0, STR_BUF);
            sprintf(cmd_l,"%s %s %s %d %s",WLANCONF,ifName,"list|awk 'NR==",i,		\
			                          "{for(i=1;i<NF;i++){if($i==\"Normal\"){print  i}}}'");
	    printf("cmd_l:%s\n",cmd_l);
            fp = popen(cmd_l, "r");
		if(fp){  
	  	     memset( mac, 0, STR_BUF );
  	             fgets(mac,sizeof(mac),fp);
	             mac[strlen(mac)-1] = '\0';
		      nomal_row=atoi(mac);
		      nomal_af=nomal_row+1;
		      nomal_bf=nomal_row-1;
		      pclose(fp);
           	}
        sprintf(cmd_a,"%s %s %s %d %s",WLANCONF, nAd.ifName,"list|awk 'NR==",i,"{print $1}'");
        sprintf(cmd_p,"%s %s %s %d %s",WLANCONF, nRp.ifName,"list|awk 'NR==",i,"{print $5}'");
	 printf("cmd_p:%s\n",cmd_p);
	 
	 sprintf(cmd_u,"%s %s %s %d %s%d %s",WLANCONF, nUt.ifName,"list|awk 'NR==",i,"{print   $(", nomal_af, ")}'");
         printf("cmd_u:%s\n",cmd_u);
		 
	  sprintf(cmd_c,"%s %s %s %d %s%d %s",WLANCONF, nPs.ifName,"list|awk 'NR==",i,"{print   $(", nomal_bf, ")}'");
         printf("cmd_c:%s\n",cmd_c);
		 
	 fp2 = popen(cmd_a,"r");
	    if(fp2)
            {
  	             memset( mac, 0, STR_BUF );
  	             fgets(mac,sizeof(mac),fp2);
	             mac[strlen(mac)-1] = '\0';
		      pclose(fp2);
		      strcpy(nAd.apStatMacAddrValue,mac);
		      printf("nAd.apStatMacAddrValue:%s\n",nAd.apStatMacAddrValue);
	             nAd.haveApStatMacAddrValue = TRUE;
		      sprintf ( nAd.UID, "%04d%04d\0", nAd.ifIndex, nAd.apStatMacAddrIndex );
		       AP_addList (( char * ) &adList, ( char * ) &nAd, sizeof ( nAd ));
		}
		else 	
			nAd.haveApStatMacAddrValue = FALSE;

 nIp.haveStaIPAddress=TRUE;
 fp=fopen("/tmp/dhcpsnooping.log","r");       
  if(fp){
  	    memset(line, 0, STR_BUF);
	 if( fgets(line,255,fp)!=NULL){
	 	printf("nAd.apStatMacAddrValue:%s\n",nAd.apStatMacAddrValue);
            if (strstr(line,nAd.apStatMacAddrValue)!=0){
		 memset(cmd_ip, 0, STR_BUF);
	 	 sprintf(cmd_ip," %s%s%s ","cat /tmp/dhcpsnooping.log |awk  '/MAC:",nAd.apStatMacAddrValue,"/{print $4}'");
	        printf("cmd_ip:%s\n",cmd_ip);
		 fp2=popen(cmd_ip,"r");
		 if(fp2)
	          {
	             memset( mac, 0, STR_BUF );
		      memset(buffer[0], 0 ,32);
		      memset(buffer[1], 0 ,32);
	             fgets(mac,sizeof(mac),fp2);
	             mac[strlen(mac)-1] = '\0';
		      pclose(fp2);
		   }
	           printf("mac:%s\n",mac);
			    k=0;  
			    token = strtok(mac, ":");
		  	       while (NULL != token) {
			       strcpy(buffer[k],token);   
				token = strtok(NULL,":");
				k++;
			     }
            	
			printf("buffer[0]:%s\n",buffer[0]);
			printf("buffer[1]:%s\n",buffer[1]);
		      	 strcpy(nIp.StaIPAddress,buffer[1]);	
		        sprintf ( nIp.UID, "%04d%04d\0", nIp.ifIndex, nIp.StaIPAddressIndex );
		       	 AP_addList (( char * ) &ipList, ( char * ) &nIp, sizeof ( nIp ));
	           }
		}
	 fclose(fp);
  }
        
  nSu.haveStaUplinkMaxRate=TRUE;
 	{
	  memset(cmd,0,STR_BUF);
	  sprintf(cmd,"%s   %s   %s   %s   %s","/usr/sbin/autelan   traffic_limit ", nSu.ifName, \
	  	    		"get_specific_node",nAd.apStatMacAddrValue,"|awk '{print $NF}'");
	   printf("cmd:%s\n",cmd);
	   fp2 = popen(cmd,"r");
	   if(fp2)
	    {  	
	   	memset( mac, 0, STR_BUF );
	       fgets(mac,sizeof(mac),fp2);
	       mac[strlen(mac)-1] = '\0';
	       pclose(fp2);
		 nSu.StaUplinkMaxRate=atoi(mac);
	        sprintf ( nSu.UID, "%04d%04d\0", nSu.ifIndex, nSu.StaUplinkMaxRateIndex );
	       	 AP_addList (( char * ) &suList, ( char * ) &nSu, sizeof ( nSu ));
	    }
  	}
 
  nSk.haveStaDwlinkMaxRate=TRUE;
   {
	  memset(cmd,0,STR_BUF);
	  sprintf(cmd,"%s   %s   %s   %s   %s","/usr/sbin/autelan   traffic_limit ",nSk.ifName, \
	  	    		"get_specific_node",nAd.apStatMacAddrValue,"|awk '{print $NF}'");
	   printf("cmd:%s\n",cmd);
	   fp2 = popen(cmd,"r");
	   if(fp2)
	    {  	
	   	memset( mac, 0, STR_BUF );
	       fgets(mac,sizeof(mac),fp2);
	       mac[strlen(mac)-1] = '\0';
	       pclose(fp2);
		 nSk.StaDwlinkMaxRate=atoi(mac);
	        sprintf ( nSk.UID, "%04d%04d\0", nSk.ifIndex, nSk.StaDwlinkMaxRateIndex );
	       	 AP_addList (( char * ) &skList, ( char * ) &nSk, sizeof ( nSk ));
	    }
   }

			
	fp2=popen(cmd_p,"r");
	    if(fp2)
            {
  	             memset( mac, 0, STR_BUF );
  	             fgets(mac,sizeof(mac),fp2);
	             mac[strlen(mac)-1] = '\0';
	             nRp.apStatRxPowerValue=atoi(mac);
	             nRp.haveApStatRxPowerValue = TRUE;
		       sprintf ( nRp.UID, "%04d%04d\0", nRp.ifIndex, nRp.apStatRxPowerIndex );
		        AP_addList (( char * ) &rpList, ( char * ) &nRp, sizeof ( nRp ));
			pclose(fp2);

             }
		else 	
			nRp.haveApStatRxPowerValue = FALSE;

        fp2=popen(cmd_u,"r");
	    if(fp2)
            {
  	             memset( mac, 0, STR_BUF );
  	             fgets(mac,sizeof(mac),fp2);
	             mac[strlen(mac)-1] = '\0';
			printf("mac:%s\n",mac);
		      if_min=GetMinutesFromString(mac) ;
			printf("if_min:%d\n",if_min);
		      nUt.apStatUpTimeValue=if_min*6000;
		      printf("nUt.apStatUpTimeValue:%d\n\n",nUt.apStatUpTimeValue);
		      buf_min+=if_min;
	              nUt.haveApStatUpTimeValue = TRUE;
		         sprintf ( nUt.UID, "%04d%04d\0", nUt.ifIndex, nUt.apStatUpTimeIndex );
		         AP_addList (( char * ) &utList, ( char * ) &nUt, sizeof ( nUt ));
				 pclose(fp2);
            }
		  else
		  	 nUt.haveApStatUpTimeValue = FALSE;


	fp2=popen(cmd_c,"r");
	    if(fp2)
            {
  	             memset( mac, 0, STR_BUF );
  	             fgets(mac,sizeof(mac),fp2);
	             mac[strlen(mac)-1] = '\0';
		      wmmState=atoi(mac);
		      printf("wmmState:%d\n",wmmState);
		      if(wmmState&WMM )
	             		{ nWm.StaWMMAttr=1;}
		     else 
		      		{nWm.StaWMMAttr=0;}
	              nWm.haveStaWMMAttr = TRUE;
		       sprintf ( nWm.UID, "%04d%04d\0", nWm.ifIndex, nWm.StaWMMAttrIndex );
		        AP_addList (( char * ) &wmList, ( char * ) &nWm, sizeof ( nWm ));
			pclose(fp2);

             }
		else 	
			nWm.haveStaWMMAttr = FALSE;


	fp2=popen(cmd_c,"r");
	    if(fp2)
            {
  	             memset( mac, 0, STR_BUF );
  	             fgets(mac,sizeof(mac),fp2);
	             mac[strlen(mac)-1] = '\0';
		      powState=atoi(mac);
		      printf("powState:%d\n",powState);
		      if(powState&POWSAVE)
	             		{ nPs.StaPowerSaveMode=1;}
		     else 
		      		{nPs.StaPowerSaveMode=0;}
	              nPs.haveStaPowerSaveMode = TRUE;
		       sprintf ( nPs.UID, "%04d%04d\0", nPs.ifIndex, nPs.StaPowerSaveModeIndex );
		        AP_addList (( char * ) &psList, ( char * ) &nPs, sizeof ( nPs));
			pclose(fp2);
             }
		else 	
			nPs.haveStaPowerSaveMode = FALSE;
		  
       }

	           total_min+=buf_min;
		    printf("total_min=%d\n\n",total_min);

}

nAc.haveApUsrTotalTime = TRUE;
nAc.ifIndex = ifIndex;
strcpy(nAc.ifName,ifName);
 nAc.apUsrTotalTime=total_min;


if ( wi->has_range ) 
 {
  char cmd_n[STR_BUF];
  char cmd_a[STR_BUF];
  char cmd_u[STR_BUF];

  char bfr[STR_BUF];
  char mac[STR_BUF];
  int  num_row = 0;
  int  i = 0;
  FILE *fp1;
  FILE *fp2;

  strcpy(nAr.ifName,ifName);
  strcpy(nCr.ifName,ifName);
  strcpy(nTr.ifName,ifName);
  
  memset(cmd_n,0, STR_BUF);
  sprintf(cmd_n, "%s%s%s", "cat /tmp/user-rate|awk '/",nAr.ifName,"/'|wc -l");
  fp1=popen(cmd_n,"r");
  if(fp1)
   {
  	 memset( bfr, 0, STR_BUF );
  	 fgets(bfr,sizeof(bfr),fp1);
	 bfr[strlen(bfr)-1] = '\0';
	 num_row=atoi(bfr);
   }

	 if(num_row>=1);
	{
	     for(i=1;i<= num_row;i++)
   	 	 {
	   	  	nAr.ifIndex= ifIndex;
		 	nCr.ifIndex= ifIndex;
		  	nSd.ifIndex= ifIndex;
			
			nAr.apStatTxSpeedIndex= i ;
		   	nCr.apStatRxSpeedIndex= i ;
	   		nSd.apStationSpeedIndex= i ;
			memset(cmd_a,0, STR_BUF);
			memset(cmd_u,0, STR_BUF);
			
	        	sprintf(cmd_a,"%s%s%s%d%s","cat /tmp/user-rate |awk '/",nAr.ifName,"/'|awk 'NR==\"", i, "\"{print $4}'");
			sprintf(cmd_u,"%s%s%s%d%s","cat /tmp/user-rate |awk '/",nCr.ifName,"/'|awk 'NR==\"", i, "\"{print $3}'");

			fp2=popen(cmd_a,"r");
		  	  if(fp2)
	            	   {
	  	             memset( mac, 0, STR_BUF );
	  	             fgets(mac,sizeof(mac),fp2);
		             mac[strlen(mac)-1] = '\0';
		             nAr.apStatTxSpeedValue=atoi(mac);
		             nAr.haveApStatTxSpeedValue = TRUE;
			         sprintf ( nAr.UID, "%04d%04d\0", nAr.ifIndex, nAr.apStatTxSpeedIndex );
			         AP_addList (( char * ) &arList, ( char * ) &nAr, sizeof ( nAr ));
				  pclose(fp2);

	            		}
			else 	
				nAr.haveApStatTxSpeedValue = FALSE;

	            fp2=popen(cmd_u,"r");
		      if(fp2)
	                {
	  	             memset( mac, 0, STR_BUF );
	  	             fgets(mac,sizeof(mac),fp2);
		             mac[strlen(mac)-1] = '\0';
		             nCr.apStatRxSpeedValue=atoi(mac);
		             nCr.haveApStatRxSpeedValue = TRUE;
			         sprintf ( nCr.UID, "%04d%04d\0", nCr.ifIndex, nCr.apStatRxSpeedIndex );
			         AP_addList (( char * ) &crList, ( char * ) &nCr, sizeof ( nCr ));
				 pclose(fp2);
	                 }
			  else
			  	 nCr.haveApStatRxSpeedValue = FALSE;

		  

	            nSd.haveApStationSpeedValue = TRUE;
		     nSd.apStationSpeedValue= nAr.apStatTxSpeedValue+nCr.apStatRxSpeedValue;
		     sprintf ( nSd.UID, "%04d%04d\0", nSd.ifIndex, nSd.apStationSpeedValue );
		    AP_addList (( char * ) &sdList, ( char * ) &nSd, sizeof ( nSd ));



			
     	          }
	     }

}



if ( wi->has_range ) 
 {
	  char cmd_n[STR_BUF];
	  char cmd_t[STR_BUF];
	  char cmd_r[STR_BUF];
	  char cmd_e[STR_BUF];
	  char cmd_g[STR_BUF];
	  char cmd_p[STR_BUF];
	  long count_tx=0;
	  long count_rx=0;
	  char bfr[STR_BUF];
	  char mac[STR_BUF];
	  int  num_row = 0;
	  int  i = 0;
	  int  j = 0;
	  FILE *fp1;
	  FILE *fp2;

	  strcpy(nTx.ifName,ifName);
	  strcpy(nRx.ifName,ifName);
	  strcpy(nEr.ifName,ifName);
	  strcpy(nSg.ifName,ifName);
	  strcpy(nSp.ifName,ifName);
	  strcpy(nSp.ifName,ifName);
	  memset(cmd_n,0, STR_BUF);
	  sprintf(cmd_n, "%s %s %s", "/usr/sbin/80211stats -a -i",nTx.ifName,"|wc -l");
	  printf("cmd_n:%s\n",cmd_n);
	  fp1=popen(cmd_n,"r");
	    if(fp1)
           {
	  	 memset( bfr, 0, STR_BUF );
	  	 fgets(bfr,sizeof(bfr),fp1);
		 bfr[strlen(bfr)-1] = '\0';
		 num_row=atoi(bfr);
	    }

     for(i=0;i<num_row/4;i++)
   	  {
		nTx.ifIndex= ifIndex;
		nRx.ifIndex= ifIndex;
		nTr.ifIndex= ifIndex;
		nEr.ifIndex= ifIndex;
	       nRk.ifIndex= ifIndex;
		nSg.ifIndex= ifIndex;
		nSp.ifIndex= ifIndex;
		nSi.ifIndex= ifIndex;
		
	    	 nTx.apStatTxTrafficIndex= i+1;
	   	 nRx.apStatRxTrafficIndex= i+1 ;
	   	 nTr.apStationTrafficIndex= i+1 ;
	   	 nEr.apStatRxErrPksIndex= i+1 ;
	    	nRk.apStatRxSucPksIndex= i+1 ;
	    	nSg.apTxSignalPktsIndex= i+1 ;
	    	nSp.apRxSignalPktsIndex= i+1 ;
	   	nSi.apSignalPktsIndex= i+1 ;
		
		memset(cmd_t,0, STR_BUF);
		memset(cmd_r,0, STR_BUF);
		memset(cmd_e,0, STR_BUF);
		memset(cmd_g,0, STR_BUF);
		memset(cmd_p,0, STR_BUF);
		
		sprintf(cmd_t,"%s %s %s %d %s","/usr/sbin/80211stats -a -i",nTx.ifName,"|awk 'NR==",i*4+3,"{print $6}'");
		sprintf(cmd_r,"%s %s %s %d %s","/usr/sbin/80211stats -a -i",nRx.ifName,"|awk 'NR==",i*4+2,"{print $6}'");
		sprintf(cmd_e,"%s %s %s %d %s","/usr/sbin/80211stats -a -i",nEr.ifName,"|awk 'NR==",i*4+2,"{print $NF}'");
		sprintf(cmd_g,"%s %s %s %d %s","/usr/sbin/80211stats -a -i",nSg.ifName,"|awk 'NR==",i*4+3,"{print $4}'");
		sprintf(cmd_p,"%s %s %s %d %s","/usr/sbin/80211stats -a -i",nSp.ifName,"|awk 'NR==",i*4+2,"{print $4}'");


		  fp2=popen(cmd_t,"r");
		    if(fp2)
	              {
	  	             memset( mac, 0, STR_BUF );
	  	             fgets(mac,sizeof(mac),fp2);
		             mac[strlen(mac)-1] = '\0';
		            nTx.apStatTxTrafficValue=atoi(mac);
				nTx.haveApStatTxTrafficValue = TRUE;
			         sprintf ( nTx.UID, "%04d%04d\0", nTx.ifIndex, nTx.apStatTxTrafficIndex );
			         AP_addList (( char * ) &txList, ( char * ) &nTx, sizeof ( nTx ));
					 pclose(fp2);

	              }
			else 
				    nTx.haveApStatTxTrafficValue = FALSE;


		fp2=popen(cmd_r,"r");
	    if(fp2)
            {
  	             memset( mac, 0, STR_BUF );
  	             fgets(mac,sizeof(mac),fp2);
	             mac[strlen(mac)-1] = '\0';
	             nRx.apStatRxTrafficValue=atoi(mac);
	             nRx.haveApStatRxTrafficValue = TRUE;
		         sprintf ( nRx.UID, "%04d%04d\0", nRx.ifIndex, nRx.apStatRxTrafficIndex );
		         AP_addList (( char * ) &rxList, ( char * ) &nRx, sizeof ( nRx ));
				 pclose(fp2);
		   }
		else 
	        nRx.haveApStatRxTrafficValue = FALSE ;

          nTr.haveApStationTafficValue = TRUE;
	  nTr.apStationTrafficValue =nTx.apStatTxTrafficValue+nRx.apStatRxTrafficValue;	  
	  sprintf ( nTr.UID, "%04d%04d\0", nTr.ifIndex, nTr.apStationTrafficIndex );
	  AP_addList (( char * ) &trList, ( char * ) &nTr, sizeof ( nTr ));

	   fp2=popen(cmd_e,"r");
	    if(fp2)
            {
  	             memset( mac, 0, STR_BUF );
  	             fgets(mac,sizeof(mac),fp2);
	             mac[strlen(mac)-1] = '\0';
	               nEr.apStatRxErrPksValue=atoi(mac);
			nEr.haveApStatRxErrPksValue = TRUE;
		         sprintf ( nEr.UID, "%04d%04d\0", nEr.ifIndex, nEr.apStatRxErrPksIndex );
		         AP_addList (( char * ) &erList, ( char * ) &nEr, sizeof ( nEr ));
			pclose(fp2);

            }

         nRk.haveApStatRxSucPksValue = TRUE;
	 nRk.apStatRxSucPksValue= nTx.apStatTxTrafficValue-nEr.apStatRxErrPksValue;
	sprintf ( nRk.UID, "%04d%04d\0", nRk.ifIndex, nRk.apStatRxSucPksIndex );
         AP_addList (( char * ) &rkList, ( char * ) &nRk, sizeof ( nRk ));

		 
		fp2=popen(cmd_g,"r");
		    if(fp2)
	            {
	  	             memset( mac, 0, STR_BUF );
	  	             fgets(mac,sizeof(mac),fp2);
		             mac[strlen(mac)-1] = '\0';
		            nSg.apTxSignalPkts=atoi(mac);
				nSg.haveapTxSignalPkts = TRUE;
				count_tx+= nSg.apTxSignalPkts;
			         sprintf ( nSg.UID, "%04d%04d\0", nSg.ifIndex, nSg.apTxSignalPktsIndex );
			         AP_addList (( char * ) &sgList, ( char * ) &nSg, sizeof ( nSg ));
					 pclose(fp2);

	            }
			else 
				    nSg.haveapTxSignalPkts = FALSE;


		fp2=popen(cmd_p,"r");
		    if(fp2)
	            {
	  	             memset( mac, 0, STR_BUF );
	  	             fgets(mac,sizeof(mac),fp2);
		             mac[strlen(mac)-1] = '\0';
		            nSp.apRxSignalPkts=atoi(mac);
				nSp.haveapRxSignalPkts = TRUE;
				count_rx+= nSp.apRxSignalPkts;
			         sprintf ( nSp.UID, "%04d%04d\0", nSp.ifIndex, nSp.apRxSignalPktsIndex );
			         AP_addList (( char * ) &spList, ( char * ) &nSp, sizeof ( nSp ));
					 pclose(fp2);

	            }
			else 
				    nSp.haveapRxSignalPkts = FALSE;

		
	  nSi.haveapSignalPkts = TRUE;
	  nSi.apSignalPkts=nSg.apTxSignalPkts+  nSp.apRxSignalPkts;
	  printf("nSi.apSignalPkts:%d\n",nSi.apSignalPkts);
	  sprintf ( nSi.UID, "%04d%04d\0", nSi.ifIndex, nSi.apSignalPktsIndex );
	   AP_addList (( char * ) &siList, ( char * ) &nSi, sizeof ( nSi ));

     }

}





  if ( wi->has_range ) {
     int i=0,channel=0;
    for ( i = 0; i < wi->range.num_frequency; i++ ) {
      if ((( double ) ( wi->range.freq[i].e * 10 ) * ( double ) wi->range.freq[i].m ) == wi->freq ) {
       nRc.haveChanAutoSelectEnable=TRUE;
       nRc.haveRadioChannelConfig=TRUE;
       nRc.haveRadioChannelUsing=TRUE;
	strcpy(nRc.ifName,ifName);
       channel = wi->range.freq[i].i;
	if(0!=channel)
		{
			nRc.ChanAutoSelectEnable =0;		
	 	}
	else 
		{
			nRc.ChanAutoSelectEnable =1;
		}
        nRc.RadioChannelConfig = wi->range.freq[i].i;
        nRc.RadioChannelUsing  = wi->range.freq[i].i;
      }
    }
  }



if ( wi->has_range ) 
{
  nRc.haveTransmitSpeedConfig=TRUE;
  strcpy ( nRc.ifName, ifName );
  memset(para,0,128);
  memset(string,0,128);
  sprintf(string,"%s%s",nRc.ifName,"_SPEED");
  prop_count=load_prop(SEP_EQUAL,SNMP_AGENT_CONF,properties);
  get_prop(string,para,properties,prop_count);
  free_prop(properties,prop_count) ;
  strcpy(nRc.TransmitSpeedConfig,para);
}

if ( wi->has_range ) 
{
   int txpower=0;
   char line[128];
   FILE *fp;
   
  strcpy ( nRc.ifName, ifName );

  nRc.haveMaxTxPwrLvl=TRUE;
  nRc.MaxTxPwrLvl=20;
  
  nRc.havePwrAttRange=TRUE;
  nRc.PwrAttRange=20;  
  
  nRc.haveAntennaGain=TRUE;
  strcpy ( nRc.ifName, ifName );
  nRc.AntennaGain=5;
  
  
  nRc.havePowerMgmtEnable=TRUE;
  strcpy ( nRc.ifName, ifName );
  fp=popen("/usr/sbin/getautopower1.sh","r"); //add by heyanhua 2010-5-25
  if(fp){
  	memset(line,0,128);
	fgets(line,sizeof(line),fp);
	line[strlen(line)-1]='\0';
	if(strstr(line,"ignore"))
		nRc.PowerMgmtEnable=0;
	else
		nRc.PowerMgmtEnable=1;
  	}
/*  txpower= wi->txpower.value;
  if(0!=txpower)
	{
	  nRc.PowerMgmtEnable=0;
	}
  else 
       { 
         nRc.PowerMgmtEnable=1;
       }
  */
  nRc.haveMaxStationNumPermitted=TRUE;
 {	
	memset(strBuf,0,32);
	wireless_get_maxsimultusers(get_vnum_by_vname( nRc.ifName ),strBuf, 20);
	nRc.MaxStationNumPermitted=atoi(strBuf);
  }  	
}



if( wi->has_range )
{
   FILE *fp;
   char  cmd_n[STR_BUF];
   int num_row=0;
   char ciphertype[64];
   char wepmode[64];
   char wapmode[64];
   int retu=0;
   unsigned int ifnum=0;
   char strBit[32];
   int bitlevel=0;
   memset(cmd_n,0, STR_BUF);
   sprintf(cmd_n, "%s %s %s %s", "/usr/sbin/wlanconfig",ifName,"list","|wc -l");
   fp=popen(cmd_n,"r");
    if(fp)
      {
  	 memset( bfr, 0, STR_BUF );
  	 fgets(bfr,sizeof(bfr),fp);
	 bfr[strlen(bfr)-1] = '\0';
	 num_row=atoi(bfr);
	 pclose(fp);
      }
	if(num_row>=2)
	 {
	   nSn.haveStaRadioMode = TRUE;
	  {
		strcpy(nSn.ifName,ifName);
		memset(strBuf,0,32);
		strcpy(strBuf,wi->name);
		printf("strBuf:%s\n",strBuf);
		if(0==strcmp(strBuf,"IEEE 802.11a"))
		    {bg_num=1;}
		if(0==strcmp(strBuf,"IEEE 802.11b"))
		   {bg_num=2;}
		if(0==strcmp(strBuf,"IEEE 802.11g"))
		   {bg_num=6;}
		if(0==strcmp(strBuf,"IEEE 802.11an"))
		   {bg_num=8;}
		if(0==strcmp(strBuf,"IEEE 802.11gn"))
		   {bg_num=16;}
	       nSn.StaRadioMode=bg_num;
	  }

nSn.haveStaRadioChannel = TRUE;
	  if ( wi->has_range ) { 
	  int i =0;
             for ( i = 0; i < wi->range.num_frequency; i++ ) {
             if ((( double ) ( wi->range.freq[i].e * 10 ) * ( double ) wi->range.freq[i].m ) == wi->freq ) {
             strcpy(nSn.ifName,ifName);
		   nSn.StaRadioChannel = wi->range.freq[i].i; }}}

		
nSn.haveStaVlanId = TRUE;
		
		
nSn.haveStaSSIDName = TRUE;
 if ( wi->has_essid && strlen ( wi->essid )) {
	strcpy ( nSn.StaSSIDName, wi->essid ); 
   }
 
nSn.haveStaAuthenMode = TRUE;
   {
  	  strcpy( nSn.ifName,ifName);
  	  memset (ciphertype, 0,64);
  	  memset (wepmode, 0,64);
  	  memset (wapmode, 0,64);
       ifnum=get_vnum_by_vname( nSn.ifName );
	nSe.haveApSecurityType=TRUE;
	wireless_sec_get_type(ifnum,ciphertype, 64 );
	if(0==strcmp(ciphertype,"none"))
	      { retu=1;}
	else if (0==strcmp(ciphertype,"wep"))
	       {
		      wireless_sec_get_authmode(ifnum,wepmode,64);
	              if(0==strcmp(wepmode,"1"))
	              	 {retu=2;}
	             if(0==strcmp(wepmode,"2"))
	             	 {retu=3;}
		      if(0==strcmp(wepmode,"3"))
		      	 {retu=4;}
	        }
	  else if (0==strcmp(ciphertype,"wpa"))
	      {
		      wireless_sec_get_mode(ifnum,wapmode,64);
			if(0==strcmp(wapmode,"PSK"))
				{retu=5;}
			if(0==strcmp(wapmode,"RADIUS"))
				{retu=7;}
	       }
  	else if (0==strcmp(ciphertype,"wpa2"))
 		{
 		      wireless_sec_get_mode(ifnum,wapmode,64);
 			if(0==strcmp(wapmode,"PSK"))
 				{retu = 6;}
 			if(0==strcmp(wapmode,"RADIUS"))
 				{retu = 8;}
 	       }
     	else if (0 == strcmp(ciphertype,"wapi"))
		          {retu = 9;}
	        nSn.StaAuthenMode = retu;
	}

   nSn.haveStaSecurityCiphers = TRUE;
	{
	       ifnum = get_vnum_by_vname( nSn.ifName );
		memset(ciphertype, 0, 64);
		wireless_sec_get_type(ifnum,ciphertype, 64 );
		 if(0 == strcmp(ciphertype,"none"))
		      { retu=1;}
		else if (0 == strcmp(ciphertype,"wep")) {
			memset(strBit,0,32);
			wireless_sec_get_wepkey_level(ifnum, strBit, 32);
			bitlevel=atoi(strBit);
			 if(64 == bitlevel)
			 { retu = 2;}
			 else  if(128==bitlevel)
			{ retu = 3;}
		  }
	         else if (0 == strcmp(ciphertype,"wpa")){
			  memset(strBuf, 0, 128);
	       		  wireless_sec_get_wpaencrypt(ifnum, strBuf, 64);
			  printf("strBuf:%s\n",strBuf);
		 	  if(0 == strcmp(strBuf,"TKIP"))
		          {retu = 4;}
		 	  if(0==strcmp(strBuf,"AES"))
		   		{retu = 5;}
		   }
	    	 else if (0==strcmp(ciphertype,"wapi")){
			 retu = 6;}
		 nSn.StaSecurityCiphers=retu;
	}
			 	

		
		
    }

}


}




/****************************************************************************
*                                                                           *
*      loadWiExt() - load wireless extensions structures;                   *
*                    use ioctl calls and read /proc/net/wireless            *
*                                                                           *
****************************************************************************/
static void AP_loadWiExt ( int skfd, char *ifname, struct wireless_info *wi )
{
  struct iwreq wrq;                       // ioctl request structure
  FILE *fp;
  char  bfr[1024];
  char  buffer[sizeof ( iwrange ) * 2]; /* Large enough */
  char *s, *t;
  int i, j;

  strncpy ( wrq.ifr_name, ifname, IFNAMSIZ );

  /* Get wireless name */
  if ( ioctl ( skfd, SIOCGIWNAME, &wrq ) >= 0 ) {
    strncpy ( wi->name, wrq.u.name, IFNAMSIZ );
    wi->name[IFNAMSIZ] = '\0';
  }

  /* Get ranges */    // NOTE: some version checking in iwlib.c
  memset ( buffer, 0, sizeof ( buffer ));
  wrq.u.data.pointer = ( caddr_t ) &buffer;
  wrq.u.data.length = sizeof ( buffer );
  wrq.u.data.flags = 0;
  if ( ioctl ( skfd, SIOCGIWRANGE, &wrq ) >= 0 ) {
    memcpy (( char * ) &wi->range, buffer, sizeof ( iwrange ));
    wi->has_range = 1;
  }

  /* Get network ID */
  if ( ioctl ( skfd, SIOCGIWNWID, &wrq ) >= 0 ) {
    memcpy ( &wi->nwid, &wrq.u.nwid, sizeof ( iwparam ));
    wi->has_nwid = 1;
  }

  /* Get frequency / channel */         // THIS NUMBER LOOKS FUNNY
  if ( ioctl ( skfd, SIOCGIWFREQ, &wrq ) >= 0 ) {
    wi->has_freq = 1;
  wi->freq = (( double ) wrq.u.freq.m ) * my_pow( 10, wrq.u.freq.e );
  }

  /* Get sensitivity */
  if ( ioctl ( skfd, SIOCGIWSENS, &wrq ) >= 0 ) {
    wi->has_sens = 1;
    memcpy ( &wi->sens, &wrq.u.sens, sizeof ( iwparam ));
  }

  /* Get encryption information */
  wrq.u.data.pointer = ( caddr_t ) &wi->key;
  wrq.u.data.length = IW_ENCODING_TOKEN_MAX;
  wrq.u.data.flags = 0;
  if ( ioctl ( skfd, SIOCGIWENCODE, &wrq ) >= 0 ) {
    wi->has_key = 1;
    wi->key_size = wrq.u.data.length;
    wi->key_flags = wrq.u.data.flags;
    wepCurrentKey = wrq.u.data.flags & IW_ENCODE_INDEX;
  }

  for ( i = 0; i < wi->range.max_encoding_tokens; i++ ) {
    wrq.u.data.pointer = ( caddr_t ) &wi->key;
    wrq.u.data.length = IW_ENCODING_TOKEN_MAX;
    wrq.u.data.flags = i;
    if ( ioctl ( skfd, SIOCGIWENCODE, &wrq ) >= 0 ) {
      if ( ( wrq.u.data.length != 0 ) &&
          !( wrq.u.data.flags & IW_ENCODE_DISABLED )) {
        wep[i].len = wrq.u.data.length;
        wep[i].haveKey = TRUE;
        t = wep[i].key;
        for ( j = 0; j < wrq.u.data.length; j++ ) {
          if (( j & 0x1 ) == 0 && j != 0 )
        	  strcpy ( t++, "-");
          sprintf ( t, "%.2X", wi->key[j] );
          t += 2;
        }
        t = '\0';
      }
    }
  }

  /* Get ESSID */
  wrq.u.essid.pointer = ( caddr_t ) &wi->essid;
  wrq.u.essid.length = IW_ESSID_MAX_SIZE + 1;
  wrq.u.essid.flags = 0;
  if ( ioctl ( skfd, SIOCGIWESSID, &wrq ) >= 0 ) {
    wi->has_essid = 1;
    wi->essid_on = wrq.u.data.flags;
  }

  /* Get AP address */
  if ( ioctl ( skfd, SIOCGIWAP, &wrq ) >= 0 ) {
    wi->has_ap_addr = 1;
    memcpy ( &wi->ap_addr, &wrq.u.ap_addr, sizeof ( sockaddr ));
  }

  /* Get NickName */
  wrq.u.essid.pointer = ( caddr_t ) &wi->nickname;
  wrq.u.essid.length = IW_ESSID_MAX_SIZE + 1;
  wrq.u.essid.flags = 0;
  if ( ioctl ( skfd, SIOCGIWNICKN, &wrq ) >= 0 ) {
    if ( wrq.u.data.length > 1 )
      wi->has_nickname = 1;
  }

  /* Get bit rate */
  if ( ioctl ( skfd, SIOCGIWRATE, &wrq ) >= 0 ) {
    wi->has_bitrate = 1;
    memcpy ( &wi->bitrate, &wrq.u.bitrate, sizeof ( iwparam ));
  }

  /* Get RTS threshold */
  if ( ioctl ( skfd, SIOCGIWRTS, &wrq ) >= 0 ) {
    wi->has_rts = 1;
    memcpy ( &wi->rts, &wrq.u.rts, sizeof ( iwparam ));
  }

  /* Get fragmentation threshold */
  if ( ioctl ( skfd, SIOCGIWFRAG, &wrq ) >= 0 ) {
      wi->has_frag = 1;
      memcpy ( &wi->frag, &wrq.u.frag, sizeof ( iwparam ));
    }

  /* Get operation mode */
  if ( ioctl ( skfd, SIOCGIWMODE, &wrq ) >= 0 ) {
      wi->mode = wrq.u.mode;
      if ( wi->mode < IW_NUM_OPER_MODE && wi->mode >= 0 )
        wi->has_mode = 1;
  }

  /* Get Power Management settings */                 // #if WIRELESS_EXT > 9
  wrq.u.power.flags = 0;
  if ( ioctl ( skfd, SIOCGIWPOWER, &wrq ) >= 0 ) {
    wi->has_power = 1;
    memcpy ( &wi->power, &wrq.u.power, sizeof ( iwparam ));
  }

  /* Get retry limit/lifetime */                      // #if WIRELESS_EXT > 10
  if ( ioctl ( skfd, SIOCGIWRETRY, &wrq ) >= 0 ) {    
    wi->has_retry = 1;
    memcpy ( &wi->retry, &wrq.u.retry, sizeof ( iwparam ));
  }

  /* Get stats */                                     // #if WIRELESS_EXT > 11
  wrq.u.data.pointer = ( caddr_t ) &wi->stats;
  wrq.u.data.length = 0;
  wrq.u.data.flags = 1;   /* Clear updated flag */
  if ( ioctl ( skfd, SIOCGIWSTATS, &wrq ) < 0 )
    wi->has_stats = 1;

  if ( !wi->has_stats ) {                        // no ioctl support, go to file
    fp = fopen ( PROC_NET_WIRELESS, "r" );
    if ( fp ) {
      while ( fgets ( bfr, sizeof ( bfr ), fp )) {
        bfr [ sizeof ( bfr ) - 1 ] = '\0';        // no buffer overruns here!
        strtok (( char * ) &bfr, "\n" );          // '\n' => '\0'
        if ( strstr ( bfr, ifname ) && strstr ( bfr, ":" )) {
          wi->has_stats = 1;
          s = bfr;
          s = strchr ( s, ':' ); s++;             /* Skip ethX:   */
          s = strtok ( s, " " );                  /* ' ' => '\0'  */
          sscanf ( s, "%X", &wi->stats.status ); // status 

          s = strtok ( NULL, " " );               // link quality
          if ( strchr ( s, '.' ) != NULL )
            wi->stats.qual.updated |= 1;
          sscanf ( s, "%d", &wi->stats.qual.qual );

          s = strtok ( NULL, " " );               // signal level
          if ( strchr ( s,'.' ) != NULL )
            wi->stats.qual.updated |= 2;
          sscanf ( s, "%d", &wi->stats.qual.level );

          s = strtok ( NULL, " " );               // noise level
          if ( strchr ( s, '.' ) != NULL )
            wi->stats.qual.updated += 4;
          sscanf ( s, "%d", &wi->stats.qual.noise );

          s = strtok ( NULL, " " ); sscanf ( s, "%d", &wi->stats.discard.nwid     );
          s = strtok ( NULL, " " ); sscanf ( s, "%d", &wi->stats.discard.code     );
          s = strtok ( NULL, " " ); sscanf ( s, "%d", &wi->stats.discard.fragment );
          s = strtok ( NULL, " " ); sscanf ( s, "%d", &wi->stats.discard.retries  );
          s = strtok ( NULL, " " ); sscanf ( s, "%d", &wi->stats.discard.misc     );
          s = strtok ( NULL, " " ); sscanf ( s, "%d", &wi->stats.miss.beacon      );
        }
      }
      fclose ( fp );
    }
  }

// printf ( "%s bfr: %s\n", "loadTables()", bfr );
}



/****************************************************************************
*                                                                           *
*                        Linked List Functions                              *
*                                                                           *
****************************************************************************/
/****************************************************************************
*                                                                           *
*                addList() - add an entry to a linked list                  *
*                                                                           *
****************************************************************************/
static void 
AP_addList ( char *l, char *data, int len  )
{
  char uid[256];
  LIST_HEAD ( , avNode ) *list;       

  // NOTE: this assumes the UID is at the begining of the 
  //       data structure and that UIDs are strings
  
  list = ( LIST_HEAD ( , avNode ) * ) l;            // NOTE: don't know how to get 
  strcpy ( uid, data );                             //  rid of compiler warning on
 // printf("nRr.uid:%s  nRr.data:%s\n",uid,data);                                                
                                                //  LISTHEAD typecast
  // create a new node and the data that goes in it
  newNode = malloc ( sizeof ( struct avNode ));
  newNode->data = malloc ( len );
  memcpy ( newNode->data, data, len );
  //printf("newNode->data:%s\n",newNode->data);  
  // this deals with an empty list
  if ( LIST_EMPTY ( list )) {
    LIST_INSERT_HEAD ( list, newNode, nodes );
    return;
  }

  // this deals with UIDs that match
  for ( np = LIST_FIRST ( list ); np != NULL; np = LIST_NEXT ( np, nodes )) {
    if ( strncmp ( uid, np->data, strlen ( uid )) == 0 ) {                      // found matching UID
      LIST_INSERT_AFTER ( np, newNode, nodes );
      if ( np->data )
        free ( np->data );
      LIST_REMOVE ( np, nodes );
      free ( np );
      return;
    }
  }

  // this deals with inserting a new UID in the list
  for ( np = LIST_FIRST ( list ); np != NULL; np = LIST_NEXT ( np, nodes )) {
    lastNode = np;
    if ( strncmp ( np->data, uid, strlen ( uid )) > 0 ) {                       // old ID > new ID AND
      LIST_INSERT_BEFORE ( np, newNode, nodes );
      return;
    }
  }

  // this deals with a UID that needs to go on the end of the list
  LIST_INSERT_AFTER ( lastNode, newNode, nodes );

  return;
}




static void AP_initLists()
{
 
 LIST_INIT ( &acList );
 LIST_INIT ( &seList );
 LIST_INIT ( &adList );  
 LIST_INIT ( &txList ); 
 LIST_INIT ( &rxList ); 
 LIST_INIT ( &rpList );
 LIST_INIT ( &utList );
 
 LIST_INIT ( &arList );
 LIST_INIT ( &crList );
 LIST_INIT ( &trList );
 
 LIST_INIT ( &erList ); 
 LIST_INIT ( &sdList ); 
 LIST_INIT ( &rkList );
  LIST_INIT ( &sgList ); //signal tx
 LIST_INIT ( &spList );//signal rx
 LIST_INIT ( &siList );//signal all
 
 LIST_INIT ( &wmList );//station wmm
 LIST_INIT ( &ipList );//station ip
  LIST_INIT ( &suList );//station  uplink
 LIST_INIT ( &skList );//station  downlink

 LIST_INIT ( &psList );//sta powersave
 LIST_INIT ( &rcList );//radio  channel
 LIST_INIT ( &snList );//station info
}




/****************************************************************************
*                                                                           *
*                 flushLists() - flush all linked lists                     *
*                                                                           *
****************************************************************************/
static void AP_flushLists()
{
  
 AP_flushList (( char * ) &acList );
 AP_flushList (( char * ) &seList );
 AP_flushList (( char * ) &adList );
 AP_flushList (( char * ) &txList );
 AP_flushList (( char * ) &rxList );
 AP_flushList (( char * ) &rpList );
 AP_flushList (( char * ) &utList ); 
 AP_flushList (( char * ) &arList ); 
 AP_flushList (( char * ) &crList ); 
 AP_flushList (( char * ) &trList ); 
 AP_flushList (( char * ) &erList ); 
 AP_flushList (( char * ) &sdList ); 
 AP_flushList (( char * ) &rkList ); 
 AP_flushList (( char * ) &sgList ); 
 AP_flushList (( char * ) &spList ); 
 AP_flushList (( char * ) &siList ); 
 
 AP_flushList (( char * ) &wmList ); 
 AP_flushList (( char * ) &ipList ); 
 AP_flushList (( char * ) &psList ); 
 AP_flushList (( char * ) &rcList ); 
 AP_flushList (( char * ) &snList); 

}


/****************************************************************************
*                                                                           *
*                   flushList() - flush a linked list                       *
*                                                                           *
****************************************************************************/
static void AP_flushList ( char *l )
{
  LIST_HEAD ( , avNode ) *list;
  
  list = ( LIST_HEAD ( , avNode ) * ) l;    // NOTE: don't know how to get 
  while ( !LIST_EMPTY ( list )) {           //  rid of compiler warning on
    np = LIST_FIRST ( list );               //  LISTHEAD typecast
    if ( np->data )
      free ( np->data );
    LIST_REMOVE ( np, nodes );
    free ( np );
  }
}


/****************************************************************************
*                                                                           *
*                            Utility Functions                              *
*                                                                           *
****************************************************************************/
/****************************************************************************
*                                                                           *
*        The following two routines were taken directly from iwlib.c        *
*                                                                           *
****************************************************************************/
 /*
 * Open a socket.
 * Depending on the protocol present, open the right socket. The socket
 * will allow us to talk to the driver.
 */
static int AP_openSocket ( void )
{
  static const int families[] = {
    AF_INET, AF_IPX, AF_AX25, AF_APPLETALK
  };
  unsigned int  i;
  int   sock;

  /*
   * Now pick any (exisiting) useful socket family for generic queries
   * Note : don't open all the socket, only returns when one matches,
   * all protocols might not be valid.
   * Workaround by Jim Kaba <jkaba@sarnoff.com>
   * Note : in 99% of the case, we will just open the inet_sock.
   * The remaining 1% case are not fully correct...
   */

  /* Try all families we support */
  for(i = 0; i < sizeof(families)/sizeof(int); ++i) {
      /* Try to open the socket, if success returns it */
      sock = socket(families[i], SOCK_DGRAM, 0);
      if(sock >= 0)
  return sock;
  }

  return -1;
}



/*------------------------------------------------------------------*/
/*
 * Convert a value in milliWatt to a value in dBm.
 */
static int AP_mWatt2dbm ( int in )
{
#ifdef WE_NOLIBM
  /* Version without libm : slower */
  double  fin = (double) in;
  int   res = 0;

  /* Split integral and floating part to avoid accumulating rounding errors */
  while(fin > 10.0)
    {
      res += 10;
      fin /= 10.0;
    }
  while(fin > 1.000001) /* Eliminate rounding errors, take ceil */
    {
      res += 1;
      fin /= LOG10_MAGIC;
    }
  return(res);
#else /* WE_NOLIBM */
  /* Version with libm : faster */
  return((int) (ceil(10.0 * log10((double) in))));
#endif  /* WE_NOLIBM */
}



static  int
AP_dbm2mwatt(int	in)
{
#ifdef WE_NOLIBM
  /* Version without libm : slower */
  int		ip = in / 10;
  int		fp = in % 10;
  int		k;
  double	res = 1.0;

  /* Split integral and floating part to avoid accumulating rounding errors */
  for(k = 0; k < ip; k++)
    res *= 10;
  for(k = 0; k < fp; k++)
    res *= LOG10_MAGIC;
  return((int) res);
#else	/* WE_NOLIBM */
  /* Version with libm : faster */
 return((int) (floor(my_pow(10.0, (((double) in) / 10.0)))));
#endif	/* WE_NOLIBM */
}


/****************************************************************************
*                                                                           *
*                 htob - converts hex string to binary                      *
*                                                                           *
****************************************************************************/
static char *AP_htob ( char *s )
{
    char nibl, *byt;
    static char bin[20];

    byt = bin;

    while ((nibl = *s++) && nibl != ' ') {    /* While not end of string. */
      nibl -= ( nibl > '9') ?  ('a' - 10): '0';
      *byt = nibl << 4;                              /* place high nibble */
      if((nibl = *s++) && nibl != ' ') {
        nibl -= ( nibl > '9') ?  ('a' - 10): '0';
        *byt |= nibl;                                /*  place low nibble */
      }
      else break;
      ++byt;
    }
    *++byt = '\0';
    return ( bin );
}

static char *AP_HtoB ( char *s )
{
    char nibl, *byt;
    static char bin[20];

    byt = bin;

    while ((nibl = *s++) && nibl != ' ') {    /* While not end of string. */
      nibl -= ( nibl > '9') ?  ('A' - 10): '0';
      *byt = nibl << 4;                              /* place high nibble */
      if((nibl = *s++) && nibl != ' ') {
        nibl -= ( nibl > '9') ?  ('A' - 10): '0';
        *byt |= nibl;                                /*  place low nibble */
      }
      else break;
      ++byt;
    }
    *++byt = '\0';
    return ( bin );
}


/****************************************************************************
*                                                                           *
*           hasChanged() - see if area has been changed from NULLs          *
*                                                                           *
****************************************************************************/
static int AP_hasChanged ( char *loc, int len )
{
  char *wrk;
  int changed = TRUE;

  wrk = malloc ( len );
  memset ( wrk, 0, len );
  if ( memcmp ( loc, wrk, len ) == 0 )
    changed = FALSE;
  free ( wrk );

  return ( changed );
}




int    GetMinutesFromString(char *timeString)
{
	//
	int  total = 0;
	char hour[3];
	char minute[3];
	char second[3];
        int i=0;
	 int j=0;
	 int k=0;
	 int  tem = 0; 
	//

    for (i=0;i<2;i++)
    {
        hour[i] = timeString[i];
    }
	hour[2]='\0';

	
   tem = atoi(hour) * 60;
   total += tem;

    for ( j=0;j<2;j++)
    {
	minute[j] = timeString[3+j];
    }
	minute[2]='\0';

	tem = atoi(minute);
	total +=tem;

#if   0
for(k = 0;k<2;k++)
	{
		second[k] = timeString[6+k];
	}
     	second[2]='\0';

	tem = second;

	total +=tem;

#endif
	return total;

}


